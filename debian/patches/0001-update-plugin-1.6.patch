From: Emilio

Update plugin to 1.6
---
diff -ur a/src/ssreflect.ml4 b/src/ssreflect.ml4
--- a/src/ssreflect.ml4	2014-03-11 17:39:43.000000000 +0100
+++ b/src/ssreflect.ml4	2016-01-24 17:01:50.663675080 +0100
@@ -1,31 +1,35 @@
-(* (c) Copyright Microsoft Corporation and Inria.                       *)
-(* You may distribute this file under the terms of the CeCILL-B license *)
+(* (c) Copyright 2006-2015 Microsoft Corporation and Inria.                  *)
+(* Distributed under the terms of CeCILL-B.                                  *)
 
 (* This line is read by the Makefile's dist target: do not remove. *)
-let ssrversion = "1.5";;
+DECLARE PLUGIN "ssreflect"
+let ssrversion = "1.6";;
 let ssrAstVersion = 1;;
 let () = Mltop.add_known_plugin (fun () ->
   if Flags.is_verbose () && not !Flags.batch_mode then begin
     Printf.printf "\nSmall Scale Reflection version %s loaded.\n" ssrversion;
-    Printf.printf "Copyright 2005-2012 Microsoft Corporation and INRIA.\n";
+    Printf.printf "Copyright 2005-2014 Microsoft Corporation and INRIA.\n";
     Printf.printf "Distributed under the terms of the CeCILL-B license.\n\n"
-  end;
-  (* Disable any semantics associated with bullets *)
-  Goptions.set_string_option_value_gen
-    (Some false) ["Bullet";"Behavior"] "None")
+  end)
   "ssreflect"
 ;;
-(* Defining grammar rules with "xx" in it automatically declares keywords too *)
+
+(* Defining grammar rules with "xx" in it automatically declares keywords too,
+ * we thus save the lexer to restore it at the end of the file *)
 let frozen_lexer = Lexer.freeze () ;;
 
 (*i camlp4use: "pa_extend.cmo" i*)
-(*i camlp4deps: "parsing/grammar.cma" i*)
+(*i camlp4deps: "grammar/grammar.cma" i*)
 
 open Names
 open Pp
 open Pcoq
 open Genarg
+open Stdarg
+open Constrarg
 open Term
+open Vars
+open Context
 open Topconstr
 open Libnames
 open Tactics
@@ -42,15 +46,56 @@
 open Goptions
 open Tacexpr
 open Tacinterp
-open Pretyping.Default
+open Pretyping
 open Constr
 open Tactic
 open Extraargs
 open Ppconstr
 open Printer
 
+open Globnames
+open Misctypes
+open Decl_kinds
+open Evar_kinds
+open Constrexpr
+open Constrexpr_ops
+open Notation_term
+open Notation_ops
+open Locus
+open Locusops
+
+open Compat
+open Tok
+
 open Ssrmatching
 
+
+(* Tentative patch from util.ml *)
+
+let array_fold_right_from n f v a =
+  let rec fold n =
+    if n >= Array.length v then a else f v.(n) (fold (succ n))
+  in
+  fold n
+
+let array_app_tl v l =
+  if Array.length v = 0 then invalid_arg "array_app_tl";
+  array_fold_right_from 1 (fun e l -> e::l) v l
+
+let array_list_of_tl v =
+  if Array.length v = 0 then invalid_arg "array_list_of_tl";
+  array_fold_right_from 1 (fun e l -> e::l) v []
+
+(* end patch *)
+
+module Intset = Evar.Set
+
+type loc = Loc.t
+let dummy_loc = Loc.ghost
+let errorstrm = Errors.errorlabstrm "ssreflect"
+let loc_error loc msg = Errors.user_err_loc (loc, msg, str msg)
+let anomaly s = Errors.anomaly (str s)
+
 (** look up a name in the ssreflect internals module *)
 let ssrdirpath = make_dirpath [id_of_string "ssreflect"]
 let ssrqid name = make_qualid ssrdirpath (id_of_string name) 
@@ -60,11 +105,18 @@
 let mkSsrRef name =
   try locate_reference (ssrqid name) with Not_found ->
   try locate_reference (ssrtopqid name) with Not_found ->
-  error "Small scale reflection library not loaded"
-let mkSsrRRef name = GRef (dummy_loc, mkSsrRef name)
-let mkSsrConst name = constr_of_reference (mkSsrRef name)
-let loc_error loc msg = user_err_loc (loc, msg, str msg)
-let errorstrm = errorlabstrm "ssreflect"
+  Errors.error "Small scale reflection library not loaded"
+let mkSsrRRef name = GRef (dummy_loc, mkSsrRef name,None), None
+let mkSsrConst name env sigma =
+  Evd.fresh_global env sigma (mkSsrRef name)
+let pf_mkSsrConst name gl =
+  let sigma, env, it = project gl, pf_env gl, sig_it gl in
+  let sigma, t = mkSsrConst name env sigma in
+  t, re_sig it sigma
+let pf_fresh_global name gl =
+  let sigma, env, it = project gl, pf_env gl, sig_it gl in
+  let sigma,t  = Evd.fresh_global env sigma name in
+  t, re_sig it sigma
 
 (** Ssreflect load check. *)
 
@@ -76,18 +128,12 @@
 (* some caching, repeating the test only when the environment changes.  *)
 (*   We check for protect_term because it is the first constant loaded; *)
 (* ssr_have would ultimately be a better choice.                        *)
-let ssr_loaded =
-  let cache = ref (Global.safe_env (), false) in
-  fun () ->
-    Lexer.is_keyword "is" &&
-    let new_lbl = Global.safe_env () in
-    match !cache with
-    | lbl, loaded when lbl == new_lbl -> loaded
-    | _ ->
-       let loaded =
-         (try ignore (mkSsrRef "protect_term"); true with _ -> false) in
-       cache := new_lbl, loaded; loaded
- 
+let ssr_loaded = Summary.ref ~name:"SSR:loaded" false
+let is_ssr_loaded () =
+  !ssr_loaded ||
+  (if Lexer.is_keyword "SsrSyntax_is_Imported" then ssr_loaded:=true;
+   !ssr_loaded)
+
 (* 0 cost pp function. Active only if env variable SSRDEBUG is set *)
 (* or if SsrDebug is Set                                                  *)
 let pp_ref = ref (fun _ -> ())
@@ -112,10 +158,12 @@
 let get_index = function ArgArg i -> i | _ ->
   anomaly "Uninterpreted index"
 (* Toplevel constr must be globalized twice ! *)
-let glob_constr ist gsigma genv = function
+let glob_constr ist genv = function
   | _, Some ce ->
-    let ltacvars = List.map fst ist.lfun, [] in
-    Constrintern.intern_gen false ~ltacvars:ltacvars gsigma genv ce
+    let vars = Id.Map.fold (fun x _ accu -> Id.Set.add x accu) ist.lfun Id.Set.empty in
+    let ltacvars = {
+      Constrintern.empty_ltac_sign with Constrintern.ltac_vars = vars } in
+    Constrintern.intern_gen WithoutTypeConstraint ~ltacvars genv ce
   | rc, None -> rc
 
 (* Term printing utilities functions for deciding bracketing.  *)
@@ -155,32 +203,33 @@
 
 (** Adding a new uninterpreted generic argument type *)
 let add_genarg tag pr =
-  let wit, globwit, rawwit as wits = create_arg None tag in
-  let glob _ rarg = in_gen globwit (out_gen rawwit rarg) in
-  let interp _ gl garg = Tacmach.project gl,in_gen wit (out_gen globwit garg) in
-  let subst _ garg = garg in
-  add_interp_genarg tag (glob, interp, subst);
+  let wit = Genarg.make0 None tag in
+  let glob ist x = (ist, x) in
+  let subst _ x = x in
+  let interp ist gl x = (gl.Evd.sigma, x) in
   let gen_pr _ _ _ = pr in
-  Pptactic.declare_extra_genarg_pprule
-    (rawwit, gen_pr) (globwit, gen_pr) (wit, gen_pr);
-  wits
+  let () = Genintern.register_intern0 wit glob in
+  let () = Genintern.register_subst0 wit subst in
+  let () = Geninterp.register_interp0 wit interp in
+  Pptactic.declare_extra_genarg_pprule wit gen_pr gen_pr gen_pr;
+  wit
 
 (** Constructors for cast type *)
-let dC t = CastConv (DEFAULTcast,t)
+let dC t = CastConv t
 
 (** Constructors for constr_expr *)
-let mkCProp loc = CSort (loc, GProp Null)
-let mkCType loc = CSort (loc, GType None)
-let mkCVar loc id = CRef (Ident (loc, id))
-let isCVar = function CRef (Ident _) -> true | _ -> false
-let destCVar = function CRef (Ident (_, id)) -> id | _ ->
+let mkCProp loc = CSort (loc, GProp)
+let mkCType loc = CSort (loc, GType [])
+let mkCVar loc id = CRef (Ident (loc, id),None)
+let isCVar = function CRef (Ident _,_) -> true | _ -> false
+let destCVar = function CRef (Ident (_, id),_) -> id | _ ->
   anomaly "not a CRef"
 let rec mkCHoles loc n =
-  if n <= 0 then [] else CHole (loc, None) :: mkCHoles loc (n - 1)
-let mkCHole loc = CHole (loc, None)
+  if n <= 0 then [] else CHole (loc, None, IntroAnonymous, None) :: mkCHoles loc (n - 1)
+let mkCHole loc = CHole (loc, None, IntroAnonymous, None)
 let rec isCHoles = function CHole _ :: cl -> isCHoles cl | cl -> cl = []
 let mkCExplVar loc id n =
-   CAppExpl (loc, (None, Ident (loc, id)), mkCHoles loc n)
+   CAppExpl (loc, (None, Ident (loc, id), None), mkCHoles loc n)
 let mkCLambda loc name ty t = 
    CLambdaN (loc, [[loc, name], Default Explicit, ty], t)
 let mkCLetIn loc name bo t = 
@@ -189,27 +238,39 @@
    CProdN (loc, [[dummy_loc,Anonymous], Default Explicit, ty], t)
 let mkCCast loc t ty = CCast (loc,t, dC ty)
 (** Constructors for rawconstr *)
-let mkRHole = GHole (dummy_loc, InternalHole)
+let mkRHole = GHole (dummy_loc, InternalHole, IntroAnonymous, None)
 let rec mkRHoles n = if n > 0 then mkRHole :: mkRHoles (n - 1) else []
 let rec isRHoles = function GHole _ :: cl -> isRHoles cl | cl -> cl = []
 let mkRApp f args = if args = [] then f else GApp (dummy_loc, f, args)
-let mkRVar id = GRef (dummy_loc, VarRef id)
+let mkRVar id = GRef (dummy_loc, VarRef id,None)
 let mkRltacVar id = GVar (dummy_loc, id)
 let mkRCast rc rt =  GCast (dummy_loc, rc, dC rt)
-let mkRType =  GSort (dummy_loc, GType None)
-let mkRProp =  GSort (dummy_loc, GProp Null)
+let mkRType =  GSort (dummy_loc, GType [])
+let mkRProp =  GSort (dummy_loc, GProp)
 let mkRArrow rt1 rt2 = GProd (dummy_loc, Anonymous, Explicit, rt1, rt2)
-let mkRConstruct c = GRef (dummy_loc, ConstructRef c)
-let mkRInd mind = GRef (dummy_loc, IndRef mind)
+let mkRConstruct c = GRef (dummy_loc, ConstructRef c,None)
+let mkRInd mind = GRef (dummy_loc, IndRef mind,None)
 let mkRLambda n s t = GLambda (dummy_loc, n, Explicit, s, t)
 
 (** Constructors for constr *)
+let pf_e_type_of gl t =
+  let sigma, env, it = project gl, pf_env gl, sig_it gl in
+  let sigma, ty = Typing.type_of env sigma t in
+  re_sig it sigma, ty
 
 let mkAppRed f c = match kind_of_term f with
 | Lambda (_, _, b) -> subst1 c b
 | _ -> mkApp (f, [|c|])
-let mkProt t c = mkApp (mkSsrConst "protect_term", [|t; c|])
-let mkRefl t c = mkApp ((build_coq_eq_data()).refl, [|t; c|])
+
+let mkProt t c gl =
+  let prot, gl = pf_mkSsrConst "protect_term" gl in
+  mkApp (prot, [|t; c|]), gl
+
+let mkRefl t c gl =
+  let refl, gl = pf_fresh_global (build_coq_eq_data()).refl gl in
+  mkApp (refl, [|t; c|]), gl
+
+
 (* Application to a sequence of n rels (for building eta-expansions). *)
 (* The rel indices decrease down to imin (inclusive), unless n < 0,   *)
 (* in which case they're incresing (from imin).                       *)
@@ -224,7 +285,7 @@
   if n = 0 then c else match kind_of_term c with
   | Lambda (_, _, c') -> whdEtaApp c' (n - 1)
   | _ -> mkEtaApp (lift n c) n 1
-let mkType () = mkType (Univ.fresh_local_univ ())
+let mkType () = Universes.new_Type (Lib.cwd ())
 
 (* ssrterm conbinators *)
 let combineCG t1 t2 f g = match t1, t2 with
@@ -233,72 +294,22 @@
  | _, (_, (_, None)) -> anomaly "have: mixed C-G constr"
  | _ -> anomaly "have: mixed G-C constr"
 let loc_ofCG = function
- | (_, (s, None)) -> loc_of_glob_constr s
- | (_, (_, Some s)) -> constr_loc s
+ | (_, (s, None)) -> Glob_ops.loc_of_glob_constr s
+ | (_, (_, Some s)) -> Constrexpr_ops.constr_loc s
 
 let mk_term k c = k, (mkRHole, Some c)
-let mk_lterm = mk_term ' '
+let mk_lterm c = mk_term ' ' c
 
-(* Backport from coq trunk *)
-let array_smartfoldmap f accu (ar : 'a array) =
-  let len = Array.length ar in
-  let i = ref 0 in
-  let break = ref true in
-  let r = ref accu in
-  (** This variable is never accessed unset *)
-  let temp = ref None in
-  while !break && (!i < len) do
-    let v = Array.unsafe_get ar !i in
-    let (accu, v') = f !r v in
-    r := accu;
-    if v == v' then incr i
-    else begin
-      break := false;
-      temp := Some v';
-    end
-  done;
-  if !i < len then begin
-    let ans : 'a array = Array.make len (Array.unsafe_get ar 0) in
-    (** TODO: use unsafe_blit in 4.01 *)
-    Array.blit ar 0 ans 0 !i;
-    let v = match !temp with None -> assert false | Some x -> x in
-    Array.unsafe_set ans !i v;
-    incr i;
-    while !i < len do
-      let v = Array.unsafe_get ar !i in
-      let (accu, v') = f !r v in
-      r := accu;
-      Array.unsafe_set ans !i v';
-      incr i
-    done;
-    !r, ans
-  end else !r, ar
-
-let array_for_all2 f v1 v2 =
-  let rec allrec = function
-    | -1 -> true
-    | n ->
-      let ans = f (Array.unsafe_get v1 n) (Array.unsafe_get v2 n) in
-      ans && (allrec (n-1))
-  in
-  let lv1 = Array.length v1 in
-  lv1 = Array.length v2 && allrec (pred lv1)
-  
-let fold_left2 f a v1 v2 =
-  let lv1 = Array.length v1 in
-  let rec fold a n =
-    if n >= lv1 then a
-    else fold (f a (Array.unsafe_get v1 n) (Array.unsafe_get v2 n)) (succ n)
-  in
-  if Array.length v2 <> lv1 then invalid_arg "Array.fold_left2";
-  fold a 0
-(* /Backport *)
+let pf_type_of gl t = let sigma, ty = pf_type_of gl t in re_sig (sig_it gl)  sigma, ty
 
 let map_fold_constr g f ctx acc cstr =
   let array_f ctx acc x = let x, acc = f ctx acc x in acc, x in
   match kind_of_term cstr with
   | (Rel _ | Meta _ | Var _   | Sort _ | Const _ | Ind _ | Construct _) ->
       cstr, acc
+  | Proj (x,c) ->
+      let c', acc = f ctx acc c in
+      (if c == c' then cstr else mkProj (x,c')), acc
   | Cast (c,k, t) ->
       let c', acc = f ctx acc c in
       let t', acc = f ctx acc t in
@@ -318,34 +329,37 @@
       (if b==b' && t==t' && c==c' then cstr else mkLetIn (na, b', t', c')), acc
   | App (c,al) ->
       let c', acc = f ctx acc c in
-      let acc, al' = array_smartfoldmap (array_f ctx) acc al in
-      (if c==c' && array_for_all2 (==) al al' then cstr else mkApp (c', al')),
+      let acc, al' = CArray.smartfoldmap (array_f ctx) acc al in
+      (if c==c' && Array.for_all2 (==) al al' then cstr else mkApp (c', al')),
       acc
   | Evar (e,al) ->
-      let acc, al' = array_smartfoldmap (array_f ctx) acc al in
-      (if array_for_all2 (==) al al' then cstr else mkEvar (e, al')), acc
+      let acc, al' = CArray.smartfoldmap (array_f ctx) acc al in
+      (if Array.for_all2 (==) al al' then cstr else mkEvar (e, al')), acc
   | Case (ci,p,c,bl) ->
       let p', acc = f ctx acc p in
       let c', acc = f ctx acc c in
-      let acc, bl' = array_smartfoldmap (array_f ctx) acc bl in
-      (if p==p' && c==c' && array_for_all2 (==) bl bl' then cstr else
+      let acc, bl' = CArray.smartfoldmap (array_f ctx) acc bl in
+      (if p==p' && c==c' && Array.for_all2 (==) bl bl' then cstr else
         mkCase (ci, p', c', bl')),
       acc
   | Fix (ln,(lna,tl,bl)) ->
-      let acc, tl' = array_smartfoldmap (array_f ctx) acc tl in
-      let ctx' = array_fold_left2 (fun l na t -> g (na,None,t) l) ctx lna tl in
-      let acc, bl' = array_smartfoldmap (array_f ctx') acc bl in
-      (if array_for_all2 (==) tl tl' && array_for_all2 (==) bl bl'
+      let acc, tl' = CArray.smartfoldmap (array_f ctx) acc tl in
+      let ctx' = Array.fold_left2 (fun l na t -> g (na,None,t) l) ctx lna tl in
+      let acc, bl' = CArray.smartfoldmap (array_f ctx') acc bl in
+      (if Array.for_all2 (==) tl tl' && Array.for_all2 (==) bl bl'
       then cstr
       else mkFix (ln,(lna,tl',bl'))), acc
   | CoFix(ln,(lna,tl,bl)) ->
-      let acc, tl' = array_smartfoldmap (array_f ctx) acc tl in
-      let ctx' = array_fold_left2 (fun l na t -> g (na,None,t) l) ctx lna tl in
-      let acc,bl' = array_smartfoldmap (array_f ctx') acc bl in
-      (if array_for_all2 (==) tl tl' && array_for_all2 (==) bl bl'
+      let acc, tl' = CArray.smartfoldmap (array_f ctx) acc tl in
+      let ctx' = Array.fold_left2 (fun l na t -> g (na,None,t) l) ctx lna tl in
+      let acc,bl' = CArray.smartfoldmap (array_f ctx') acc bl in
+      (if Array.for_all2 (==) tl tl' && Array.for_all2 (==) bl bl'
       then cstr
       else mkCoFix (ln,(lna,tl',bl'))), acc
 
+let pf_merge_uc_of sigma gl =
+  let ucst = Evd.evar_universe_context sigma in
+  pf_merge_uc ucst gl
 
 (* }}} *)
 
@@ -428,7 +442,7 @@
 let inVersion = Libobject.declare_object {
   (Libobject.default_object "SSRASTVERSION") with
   Libobject.load_function = (fun _ (_,v) -> 
-    if v <> ssrAstVersion then error "Please recompile your .vo files");
+    if v <> ssrAstVersion then Errors.error "Please recompile your .vo files");
   Libobject.classify_function = (fun v -> Libobject.Keep v);
 }
 
@@ -450,7 +464,7 @@
 (** 1. Utilities *)
 
 
-let ssroldreworder = ref true
+let ssroldreworder = Summary.ref ~name:"SSR:oldreworder" true
 let _ =
   Goptions.declare_bool_option
     { Goptions.optsync  = false;
@@ -518,7 +532,7 @@
 (* debug *)
 
 let pf_msg gl =
-   let ppgl = pr_lconstr_env (pf_env gl) (pf_concl gl) in
+   let ppgl = pr_lconstr_env (pf_env gl) (project gl) (pf_concl gl) in
    msgnl (str "goal is " ++ ppgl)
 
 let msgtac gl = pf_msg gl; tclIDTAC gl
@@ -536,18 +550,18 @@
 
 let pf_ids_of_proof_hyps gl =
   let add_hyp (id, _, _) ids = if not_section_id id then id :: ids else ids in
-  Sign.fold_named_context add_hyp (pf_hyps gl) ~init:[]
+  Context.fold_named_context add_hyp (pf_hyps gl) ~init:[]
 
 let pf_nf_evar gl e = Reductionops.nf_evar (project gl) e
 
 let pf_partial_solution gl t evl =
   let sigma, g = project gl, sig_it gl in
   let sigma = Goal.V82.partial_solution sigma g t in
-  re_sig (List.map (fun x -> Goal.build (fst (destEvar x))) evl) sigma
+  re_sig (List.map (fun x -> (fst (destEvar x))) evl) sigma
 
 let pf_new_evar gl ty =
   let sigma, env, it = project gl, pf_env gl, sig_it gl in
-  let sigma, extra = Evarutil.new_evar sigma env ty in
+  let sigma, extra = Evarutil.new_evar env sigma ty in
   re_sig it sigma, extra
 
 (* Basic tactics *)
@@ -555,10 +569,14 @@
 let convert_concl_no_check t = convert_concl_no_check t DEFAULTcast
 let convert_concl t = convert_concl t DEFAULTcast
 let reduct_in_concl t = reduct_in_concl (t, DEFAULTcast)
-let havetac id = pose_proof (Name id)
+let havetac id c = Proofview.V82.of_tactic (pose_proof (Name id) c)
 let settac id c = letin_tac None (Name id) c None
-let posetac id cl = settac id cl nowhere
-let basecuttac name c = apply (mkApp (mkSsrConst name, [|c|]))
+let posetac id cl = Proofview.V82.of_tactic (settac id cl nowhere)
+let basecuttac name c gl =
+  let hd, gl = pf_mkSsrConst name gl in
+  let t = mkApp (hd, [|c|]) in
+  let gl, _ = pf_e_type_of gl t in
+  Proofview.V82.of_tactic (apply t) gl
 
 (* we reduce head beta redexes *)
 let betared env = 
@@ -571,11 +589,12 @@
    match kind_of_term g with
    | App (hd, _) when isLambda hd -> 
      let g = Closure.whd_val (betared env) (Closure.inject g) in
-     convert_concl_no_check g gl
+     Proofview.V82.of_tactic (convert_concl_no_check g) gl
    | _ -> tclIDTAC gl)
-  (intro_mustbe_force name)
+  (Proofview.V82.of_tactic (intro_mustbe_force name))
 ;;
 
+
 (** Name generation {{{ *******************************************************)
 
 (* Since Coq now does repeated internal checks of its external lexical *)
@@ -587,7 +606,7 @@
 (* when the ssreflect Module is present this is normally an error,     *)
 (* but we provide a compatibility flag to reduce this to a warning.    *)
 
-let ssr_reserved_ids = ref true
+let ssr_reserved_ids = Summary.ref ~name:"SSR:idents" true
 
 let _ =
   Goptions.declare_bool_option
@@ -607,21 +626,23 @@
 let is_internal_name s = List.exists (fun p -> p s) !internal_names
 
 let ssr_id_of_string loc s =
-  if is_ssr_reserved s && ssr_loaded () then begin
+  if is_ssr_reserved s && is_ssr_loaded () then begin
     if !ssr_reserved_ids then
       loc_error loc ("The identifier " ^ s ^ " is reserved.")
     else if is_internal_name s then
-      warning ("Conflict between " ^ s ^ " and ssreflect internal names.")
-    else warning (
+      msg_warning (str ("Conflict between " ^ s ^ " and ssreflect internal names."))
+    else msg_warning (str (
      "The name " ^ s ^ " fits the _xxx_ format used for anonymous variables.\n"
-  ^ "Scripts with explicit references to anonymous variables are fragile.")
+  ^ "Scripts with explicit references to anonymous variables are fragile."))
     end; id_of_string s
 
 let ssr_null_entry = Gram.Entry.of_parser "ssr_null" (fun _ -> ())
 
+let (!@) = Compat.to_coqloc
+
 GEXTEND Gram 
   GLOBAL: Prim.ident;
-  Prim.ident: [[ s = IDENT; ssr_null_entry -> ssr_id_of_string loc s ]];
+  Prim.ident: [[ s = IDENT; ssr_null_entry -> ssr_id_of_string !@loc s ]];
 END
 
 let mk_internal_id s =
@@ -670,7 +691,7 @@
 let wildcard_tag = "_the_"
 let wildcard_post = "_wildcard_"
 let mk_wildcard_id i =
-  id_of_string (sprintf "%s%s%s" wildcard_tag (ordinal i) wildcard_post)
+  id_of_string (sprintf "%s%s%s" wildcard_tag (String.ordinal i) wildcard_post)
 let has_wildcard_tag s = 
   let n = String.length s in let m = String.length wildcard_tag in
   let m' = String.length wildcard_post in
@@ -725,11 +746,10 @@
 let rec constr_name c = match kind_of_term c with
   | Var id -> Name id
   | Cast (c', _, _) -> constr_name c'
-  | Const cn -> Name (id_of_label (con_label cn))
+  | Const (cn,_) -> Name (id_of_label (con_label cn))
   | App (c', _) -> constr_name c'
   | _ -> Anonymous
 
-
 (* }}} *)
 
 (** Open term to lambda-term coercion  {{{ ************************************)
@@ -762,15 +782,15 @@
 (* the number of dependencies, so that the transformation is reversible. *)
 
 let pf_abs_evars gl (sigma, c0) =
-  let sigma0 = project gl in
+  let sigma0, ucst = project gl, Evd.evar_universe_context sigma in
   let nenv = env_size (pf_env gl) in
   let abs_evar n k =
     let evi = Evd.find sigma k in
-    let dc = list_firstn n (evar_filtered_context evi) in
+    let dc = List.firstn n (evar_filtered_context evi) in
     let abs_dc c = function
     | x, Some b, t -> mkNamedLetIn x b t (mkArrow t c)
     | x, None, t -> mkNamedProd x t c in
-    let t = Sign.fold_named_context_reverse abs_dc ~init:evi.evar_concl dc in
+    let t = Context.fold_named_context_reverse abs_dc ~init:evi.evar_concl dc in
     Evarutil.nf_evar sigma t in
   let rec put evlist c = match kind_of_term c with
   | Evar (k, a) ->  
@@ -779,7 +799,7 @@
     let t = abs_evar n k in (k, (n, t)) :: put evlist t
   | _ -> fold_constr put evlist c in
   let evlist = put [] c0 in
-  if evlist = [] then 0, c0,[] else
+  if evlist = [] then 0, c0,[], ucst else
   let rec lookup k i = function
     | [] -> 0, 0
     | (k', (n, _)) :: evl -> if k = k' then i, n else lookup k (i + 1) evl in
@@ -793,7 +813,7 @@
   | (_, (n, t)) :: evl ->
     loop (mkLambda (mk_evar_name n, get (i - 1) t, c)) (i - 1) evl
   | [] -> c in
-  List.length evlist, loop (get 1 c0) 1 evlist, List.map fst evlist
+  List.length evlist, loop (get 1 c0) 1 evlist, List.map fst evlist, ucst
 
 
 
@@ -809,21 +829,24 @@
 
 (* Thanks to Arnaud Spiwack for this snippet *)
 let call_on_evar tac e s =
-  let { it = gs ; sigma = s } = tac { it = Goal.build e ; sigma = s } in gs, s
+  let { it = gs ; sigma = s } =
+    tac { it = e ; sigma = s; } in
+  gs, s
 
 let pf_abs_evars_pirrel gl (sigma, c0) =
   pp(lazy(str"==PF_ABS_EVARS_PIRREL=="));
   pp(lazy(str"c0= " ++ pr_constr c0));
   let sigma0 = project gl in
+  let c0 = Evarutil.nf_evar sigma0 (Evarutil.nf_evar sigma c0) in
   let nenv = env_size (pf_env gl) in
   let abs_evar n k =
     let evi = Evd.find sigma k in
-    let dc = list_firstn n (evar_filtered_context evi) in
+    let dc = List.firstn n (evar_filtered_context evi) in
     let abs_dc c = function
     | x, Some b, t -> mkNamedLetIn x b t (mkArrow t c)
     | x, None, t -> mkNamedProd x t c in
-    let t = Sign.fold_named_context_reverse abs_dc ~init:evi.evar_concl dc in
-    Evarutil.nf_evar sigma t in
+    let t = Context.fold_named_context_reverse abs_dc ~init:evi.evar_concl dc in
+    Evarutil.nf_evar sigma0 (Evarutil.nf_evar sigma t) in
   let rec put evlist c = match kind_of_term c with
   | Evar (k, a) ->  
     if List.mem_assoc k evlist || Evd.mem sigma0 k then evlist else
@@ -837,10 +860,12 @@
   let evlist = put [] c0 in
   if evlist = [] then 0, c0 else
   let pr_constr t = pr_constr (Reductionops.nf_beta (project gl) t) in
+  pp(lazy(str"evlist=" ++ pr_list (fun () -> str";")
+    (fun (k,_) -> str(Evd.string_of_existential k)) evlist));
   let evplist = 
     let depev = List.fold_left (fun evs (_,(_,t,_)) -> 
-        Intset.union evs (Evarutil.evars_of_term t)) Intset.empty evlist in
-    List.filter (fun i,(_,_,b) -> b && Intset.mem i depev) evlist in
+        Intset.union evs (Evarutil.undefined_evars_of_term sigma t)) Intset.empty evlist in
+    List.filter (fun (i,(_,_,b)) -> b && Intset.mem i depev) evlist in
   let evlist, evplist, sigma = 
     if evplist = [] then evlist, [], sigma else
     List.fold_left (fun (ev, evp, sigma) (i, (_,t,_) as p) ->
@@ -877,7 +902,7 @@
   | [] -> c in
   let rec loop c i = function
   | (_, (n, t, _)) :: evl ->
-    let evs = Evarutil.evars_of_term t in
+    let evs = Evarutil.undefined_evars_of_term sigma t in
     let t_evplist = List.filter (fun (k,_) -> Intset.mem k evs) evplist in
     let t = loopP t_evplist (get t_evplist 1 t) 1 t_evplist in
     let t = get evlist (i - 1) t in
@@ -888,7 +913,7 @@
     loop (mkLambda (mk_evar_name n, t, c)) (i - 1) evl
   | [] -> c in
   let res = loop (get evlist 1 c0) 1 evlist in
-  pp(lazy(str"res= " ++ pr_constr res)); 
+  pp(lazy(str"res= " ++ pr_constr res));
   List.length evlist, res
 
 (* Strip all non-essential dependencies from an abstracted term, generating *)
@@ -961,7 +986,7 @@
   | LetIn (x, b, t, c1) when i < j ->
     let _, _, c2 = destProd c1 in
     mk_evar j (push_rel (x, Some (unabs i b), unabs i t) env) (i + 1) c2
-  | _ -> Evarutil.e_new_evar ise env (unabs i c) in
+  | _ -> Evarutil.e_new_evar env ise (unabs i c) in
   let rec unabs_evars c =
     if !nev = n then unabs n c else match kind_of_term c with
   | Lambda (x, t, c1) when !nev < n ->
@@ -978,29 +1003,18 @@
 (* The TACTIC EXTEND facility can't be used for defining new user   *)
 (* tacticals, because:                                              *)
 (*  - the concrete syntax must start with a fixed string            *)
-(*  - the lexical Ltac environment is NOT used to interpret tactic  *)
-(*    arguments                                                     *)
-(* The second limitation means that the extended tacticals will     *)
-(* exhibit run-time scope errors if used inside Ltac functions or   *)
-(* pattern-matching constructs.                                     *)
 (*   We use the following workaround:                               *)
-(*  - We use the (unparsable) "Qed"  token for tacticals that      *)
+(*  - We use the (unparsable) "YouShouldNotTypeThis"  token for tacticals that      *)
 (*    don't start with a token, then redefine the grammar and       *)
 (*    printer using GEXTEND and set_pr_ssrtac, respectively.        *)
-(*  - We use a global stack and side effects to pass the lexical    *)
-(*    Ltac evaluation context to the extended tactical. The context *)
-(*    is grabbed by interpreting an (empty) ltacctx argument,    *)
-(*    which should appear last in the grammar rules; the            *)
-(*    get_ltacctx function pops the stack and returns the context.  *)
-(*      For additional safety, the push returns an integer key that *)
-(*    is checked by the pop; since arguments are interpreted        *)
-(*    left-to-right, this checks that only one tactic argument      *)
-(*    pushes a context.                                             *)
-(* - To avoid a spurrious option type, we don't push the context    *)
-(*    for a null tag.                                               *)
 
 type ssrargfmt = ArgSsr of string | ArgCoq of argument_type | ArgSep of string
 
+let ssrtac_name name = {
+  mltac_plugin = "ssreflect";
+  mltac_tactic = "ssr" ^ name;
+}
+
 let set_pr_ssrtac name prec afmt =
   let fmt = List.map (function ArgSep s -> Some s | _ -> None) afmt in
   let rec mk_akey = function
@@ -1008,14 +1022,20 @@
   | ArgCoq a :: afmt' -> a :: mk_akey afmt'
   | ArgSep _ :: afmt' -> mk_akey afmt'
   | [] -> [] in
-  let tacname = "ssr" ^ name in
-  Pptactic.declare_extra_tactic_pprule (tacname, mk_akey afmt, (prec, fmt))
+  let tacname = ssrtac_name name in
+   Pptactic.declare_ml_tactic_pprule tacname
+    { Pptactic.pptac_args = mk_akey afmt;
+      Pptactic.pptac_prods = (prec, fmt) }
+
+let ssrtac_atom loc name args = TacML (loc, ssrtac_name name, args)
+let ssrtac_expr = ssrtac_atom
 
-let ssrtac_atom loc name args = TacExtend (loc, "ssr" ^ name, args)
-let ssrtac_expr loc name args = TacAtom (loc, ssrtac_atom loc name args)
 
 let ssrevaltac ist gtac =
-  interp_tac_gen ist.lfun [] ist.debug (globTacticIn (fun _ -> gtac))
+  let debug = match TacStore.get ist.extra f_debug with
+  | None -> Tactic_debug.DebugOff | Some level -> level
+  in
+  Proofview.V82.of_tactic (interp_tac_gen ist.lfun [] debug (globTacticIn (fun _ -> gtac)))
 
 (* fun gl -> let lfun = [tacarg_id, val_interp ist gl gtac] in
   interp_tac_gen lfun [] ist.debug tacarg_expr gl *)
@@ -1023,23 +1043,37 @@
 (** Generic argument-based globbing/typing utilities *)
 
 
-let interp_wit globwit wit ist gl x = 
-  let globarg = in_gen globwit x in
-  let sigma, arg = interp_genarg ist gl globarg in
-  sigma, out_gen wit arg
+let interp_wit wit ist gl x = 
+  let globarg = in_gen (glbwit wit) x in
+  let sigma, arg = interp_genarg ist (pf_env gl) (project gl) (pf_concl gl) gl.Evd.it globarg in
+  sigma, out_gen (topwit wit) arg
 
-let interp_intro_pattern = interp_wit globwit_intro_pattern wit_intro_pattern
+let interp_intro_pattern = interp_wit wit_intro_pattern
 
-let interp_constr = interp_wit globwit_constr wit_constr
+let interp_constr = interp_wit wit_constr
 
 let interp_open_constr ist gl gc =
-  interp_wit globwit_open_constr wit_open_constr ist gl ((), gc)
+  interp_wit wit_open_constr ist gl ((), gc)
 
 let interp_refine ist gl rc =
-   let roc = (), (rc, None) in
-   interp_wit globwit_casted_open_constr wit_casted_open_constr ist gl roc
+  let constrvars = extract_ltac_constr_values ist (pf_env gl) in
+  let vars = { Pretyping.empty_lvar with
+    Pretyping.ltac_constrs = constrvars; ltac_genargs = ist.lfun
+  } in
+  let kind = OfType (pf_concl gl) in
+  let flags = {
+    use_typeclasses = true;
+    use_unif_heuristics = true;
+    use_hook = None;
+    fail_evar = false;
+    expand_evars = true }
+  in
+  let sigma, c = understand_ltac flags (pf_env gl) (project gl) vars kind rc in
+(*   pp(lazy(str"sigma@interp_refine=" ++ pr_evar_map None sigma)); *)
+  pp(lazy(str"c@interp_refine=" ++ pr_constr c));
+  (sigma, (sigma, c))
 
-let pf_match = pf_apply (fun e s c t -> understand_tcc s e ~expected_type:t c)
+let pf_match = pf_apply (fun e s c t -> understand_tcc e s ~expected_type:t c)
 
 (* Estimate a bound on the number of arguments of a raw constr. *)
 (* This is not perfect, because the unifier may fail to         *)
@@ -1059,7 +1093,8 @@
   try
     let rc6 = mkRApp rc (mkRHoles 6) in
     let sigma, t = interp_open_constr ist gl (rc6, None) in
-    let si = sig_it gl in let gl = re_sig si sigma in
+    let si = sig_it gl in
+    let gl = re_sig si sigma in
     6 + nbargs_open_constr gl t
   with _ -> 5
 
@@ -1071,7 +1106,8 @@
 let interp_view_nbimps ist gl rc =
   try
     let sigma, t = interp_open_constr ist gl (rc, None) in
-    let si = sig_it gl in let gl = re_sig si sigma in
+    let si = sig_it gl in
+    let gl = re_sig si sigma in
     let pl, c = splay_open_constr gl t in
     if isAppInd gl c then List.length pl else ~-(List.length pl)
   with _ -> 0
@@ -1113,9 +1149,10 @@
   | impls ->
     Impargs.declare_manual_implicits locality fref ~enriching:false [impls]
 
-VERNAC COMMAND EXTEND Ssrpreneximplicits
+VERNAC COMMAND EXTEND Ssrpreneximplicits CLASSIFIED AS SIDEFF
   | [ "Prenex" "Implicits" ne_global_list(fl) ]
-  -> [ let locality = Vernacexpr.use_section_locality () in
+  -> [ let locality =
+         Locality.make_section_locality (Locality.LocalityFixme.consume ()) in
        List.iter (declare_one_prenex_implicit locality) fl ]
 END
 
@@ -1125,49 +1162,24 @@
   GLOBAL: gallina_ext;
   gallina_ext:
    [ [ IDENT "Import"; IDENT "Prenex"; IDENT "Implicits" ->
-      Vernacexpr.VernacUnsetOption (None, ["Printing"; "Implicit"; "Defensive"])
+      Vernacexpr.VernacUnsetOption (["Printing"; "Implicit"; "Defensive"])
    ] ]
   ;
 END
 
-(* Remove the silly restriction that forces coercion classes to be precise *)
-(* aliases, e.g., allowing notations that specify some class parameters.   *)
-
-let qualify_ref clref =
-  let loc, qid = qualid_of_reference clref in
-  try match Nametab.locate_extended qid with
-  | TrueGlobal _ -> clref
-  | SynDef kn ->
-    let rec head_of = function
-    |  ARef gref ->
-          Qualid (loc, Nametab.shortest_qualid_of_global Idset.empty gref)
-    |  AApp (rc, _) -> head_of rc
-    |  ACast (rc, _) -> head_of rc
-    |  ALetIn (_, _, rc) -> head_of rc
-    | rc ->
-       user_err_loc (loc, "qualify_ref",
-        str "The definition of " ++ Ppconstr.pr_qualid qid
-             ++ str " does not have a head constant") in
-    head_of (snd (Syntax_def.search_syntactic_definition kn))
-  with _ -> clref
-
-let class_rawexpr = G_vernac.class_rawexpr in
-GEXTEND Gram
-  GLOBAL: class_rawexpr;
-  ssrqref: [[ gref = global -> qualify_ref gref ]];
-  class_rawexpr: [[ class_ref = ssrqref -> Vernacexpr.RefClass (Genarg.AN class_ref) ]];
-END
-
 (** Extend Search to subsume SearchAbout, also adding hidden Type coercions. *)
 
 (* Main prefilter *)
 
+type raw_glob_search_about_item =
+  | RGlobSearchSubPattern of constr_expr
+  | RGlobSearchString of Loc.t * string * string option
+
 let pr_search_item = function
-  | Search.GlobSearchString s -> str s
-  | Search.GlobSearchSubPattern p -> pr_constr_pattern p
+  | RGlobSearchString (_,s,_) -> str s
+  | RGlobSearchSubPattern p -> pr_constr_expr p
 
-let wit_ssr_searchitem, globwit_ssr_searchitem, rawwit_ssr_searchitem =
-  add_genarg "ssr_searchitem" pr_search_item
+let wit_ssr_searchitem = add_genarg "ssr_searchitem" pr_search_item
 
 let interp_search_notation loc s opt_scope =
   try
@@ -1181,7 +1193,7 @@
         let ambig = "This string refers to a complex or ambiguous notation." in
         str ambig ++ str "\nTry searching with one of\n" ++ ntns
       with _ -> str "This string is not part of an identifier or notation." in
-    user_err_loc (loc, "interp_search_notation", diagnosis)
+    Errors.user_err_loc (loc, "interp_search_notation", diagnosis)
 
 let pr_ssr_search_item _ _ _ = pr_search_item
 
@@ -1192,7 +1204,7 @@
 let is_ident_part s = is_ident ("H" ^ s)
 
 let interp_search_notation loc tag okey =
-  let err msg = user_err_loc (loc, "interp_search_notation", msg) in
+  let err msg = Errors.user_err_loc (loc, "interp_search_notation", msg) in
   let mk_pntn s for_key =
     let n = String.length s in
     let s' = String.make (n + 2) ' ' in
@@ -1238,7 +1250,7 @@
   | "Lonely notation" -> last_sc := ""; last := ""
   | "\"" ->
       let pntn, m = mk_pntn s true in
-      if string_string_contains pntn ptag then begin
+      if String.string_contains pntn ptag then begin
         let ntn = trim_ntn (pntn, m) in
         match !ntns with
         | [] -> ntns := [ntn]; scs := [!last_sc]
@@ -1274,37 +1286,29 @@
     let m_sc =
       if osc <> None then str "In " ++ str sc ++ pr_comma() else mt() in
     let ntn_pat = trim_ntn (mk_pntn pat false) in
-    let rbody = glob_constr_of_aconstr loc body in
+    let rbody = glob_constr_of_notation_constr loc body in
     let m_body = hov 0 (Constrextern.without_symbols prl_glob_constr rbody) in
     let m = m_sc ++ pr_ntn ntn_pat ++ spc () ++ str "denotes " ++ m_body in
     msgnl (hov 0 m) in
   if List.length !scs > 1 then
-    let scs' = list_remove sc !scs in
+    let scs' = List.remove (=) sc !scs in
     let w = pr_ntn ntn ++ str " is also defined " ++ pr_scs scs' in
     msg_warning (hov 4 w)
-  else if string_string_contains ntn " .. " then
+  else if String.string_contains ntn " .. " then
     err (pr_ntn ntn ++ str " is an n-ary notation");
   let nvars = List.filter (fun (_,(_,typ)) -> typ = NtnTypeConstr) nvars in
   let rec sub () = function
-  | AVar x when List.mem_assoc x nvars -> GPatVar (loc, (false, x))
+  | NVar x when List.mem_assoc x nvars -> GPatVar (loc, (false, x))
   | c ->
-    glob_constr_of_aconstr_with_binders loc (fun _ x -> (), x) sub () c in
-  let _, npat = Pattern.pattern_of_glob_constr (sub () body) in
+    glob_constr_of_notation_constr_with_binders loc (fun _ x -> (), x) sub () c in
+  let _, npat = Patternops.pattern_of_glob_constr (sub () body) in
   Search.GlobSearchSubPattern npat
 
 ARGUMENT EXTEND ssr_search_item TYPED AS ssr_searchitem
   PRINTED BY pr_ssr_search_item
-  | [ string(s) ] ->
-    [ if is_ident_part s then Search.GlobSearchString s else
-      interp_search_notation loc s None ]
-  | [ string(s) "%" preident(key) ] ->
-    [ interp_search_notation loc s (Some key) ]
-  | [ constr_pattern(p) ] -> 
-    [ try
-        let intern = Constrintern.intern_constr_pattern Evd.empty in
-        Search.GlobSearchSubPattern (snd (intern (Global.env()) p))
-      with e -> raise (Cerrors.process_vernac_interp_error e)
-  ]
+  | [ string(s) ] -> [ RGlobSearchString (loc,s,None) ]
+  | [ string(s) "%" preident(key) ] -> [ RGlobSearchString (loc,s,Some key) ]
+  | [ constr_pattern(p) ] -> [ RGlobSearchSubPattern p ]
 END
 
 let pr_ssr_search_arg _ _ _ =
@@ -1324,7 +1328,7 @@
   | Pattern.PApp (fp, args) -> splay_search_pattern (na + Array.length args) fp
   | Pattern.PLetIn (_, _, bp) -> splay_search_pattern na bp
   | Pattern.PRef hr -> hr, na
-  | _ -> error "no head constant in head search pattern"
+  | _ -> Errors.error "no head constant in head search pattern"
 
 let coerce_search_pattern_to_sort hpat =
   let env = Global.env () and sigma = Evd.empty in
@@ -1332,9 +1336,10 @@
     let args' = Array.append (Array.make n_imps (Pattern.PMeta None)) args in
     Pattern.PApp (fp, args') in
   let hr, na = splay_search_pattern 0 hpat in
-  let dc, ht = Reductionops.splay_prod env sigma (Global.type_of_global hr) in
+  let dc, ht =
+    Reductionops.splay_prod env sigma (Universes.unsafe_type_of_global hr) in
   let np = List.length dc in
-  if np < na then error "too many arguments in head search pattern" else
+  if np < na then Errors.error "too many arguments in head search pattern" else
   let hpat' = if np = na then hpat else mkPApp hpat (np - na) [||] in
   let warn () =
     msg_warning (str "Listing only lemmas with conclusion matching " ++ 
@@ -1364,29 +1369,44 @@
   | Cast (c', _, _) -> loop c'
   | Prod (_, _, c') -> loop c'
   | LetIn (_, _, _, c') -> loop c'
-  | _ -> Matching.is_matching p c in
+  | _ -> Constr_matching.is_matching (Global.env()) Evd.empty p c in
   filter_head, loop
 
 let all_true _ = true
 
-let interp_search_arg a =
-  let hpat, a1 = match a with
+let rec interp_search_about args accu = match args with
+| [] -> accu
+| (flag, arg) :: rem ->
+  fun gr env typ ->
+    let ans = Search.search_about_filter arg gr env typ in
+    (if flag then ans else not ans) && interp_search_about rem accu gr env typ
+
+let interp_search_arg arg =
+  let arg = List.map (fun (x,arg) -> x, match arg with
+  | RGlobSearchString (loc,s,key) ->
+      if is_ident_part s then Search.GlobSearchString s else
+      interp_search_notation loc s key
+  | RGlobSearchSubPattern p ->
+      try
+        let intern = Constrintern.intern_constr_pattern in 
+        Search.GlobSearchSubPattern (snd (intern (Global.env()) p))
+      with e -> let e = Errors.push e in iraise (Cerrors.process_vernac_interp_error e)) arg in
+  let hpat, a1 = match arg with
   | (_, Search.GlobSearchSubPattern (Pattern.PMeta _)) :: a' -> all_true, a'
   | (true, Search.GlobSearchSubPattern p) :: a' ->
      let filter_head, p = interp_head_pat p in
-     if filter_head then p, a' else all_true, a
-  | _ -> all_true, a in
+     if filter_head then p, a' else all_true, arg
+  | _ -> all_true, arg in
   let is_string =
     function (_, Search.GlobSearchString _) -> true | _ -> false in
   let a2, a3 = List.partition is_string a1 in
-  hpat, a2 @ a3
+  interp_search_about (a2 @ a3) (fun gr env typ -> hpat typ)
 
 (* Module path postfilter *)
 
 let pr_modloc (b, m) = if b then str "-" ++ pr_reference m else pr_reference m
 
-let wit_ssrmodloc, globwit_ssrmodloc, rawwit_ssrmodloc =
-  add_genarg "ssrmodloc" pr_modloc
+let wit_ssrmodloc = add_genarg "ssrmodloc" pr_modloc
 
 let pr_ssr_modlocs _ _ _ ml =
   if ml = [] then str "" else spc () ++ str "in " ++ pr_list spc pr_modloc ml
@@ -1405,26 +1425,29 @@
   let interp_mod (_, mr) =
     let (loc, qid) = qualid_of_reference mr in
     try Nametab.full_name_module qid with Not_found ->
-    user_err_loc (loc, "interp_modloc", str "No Module " ++ pr_qualid qid) in
+    Errors.user_err_loc (loc, "interp_modloc", str "No Module " ++ pr_qualid qid) in
   let mr_out, mr_in = List.partition fst mr in
-  let interp_bmod b rmods =
-    if rmods = [] then fun _ _ _ -> true else
-    Search.filter_by_module_from_list (List.map interp_mod rmods, b) in
+  let interp_bmod b = function
+  | [] -> fun _ _ _ -> true
+  | rmods -> Search.module_filter (List.map interp_mod rmods, b) in
   let is_in = interp_bmod false mr_in and is_out = interp_bmod true mr_out in
-  fun gr env -> is_in gr env () && is_out gr env ()
+  fun gr env typ -> is_in gr env typ && is_out gr env typ
 
 (* The unified, extended vernacular "Search" command *)
 
 let ssrdisplaysearch gr env t =
-  let pr_res = pr_global gr ++ spc () ++ str " " ++ pr_lconstr_env env t in
+  let pr_res = pr_global gr ++ spc () ++ str " " ++ pr_lconstr_env env Evd.empty t in
   msg (hov 2 pr_res ++ fnl ())
 
-VERNAC COMMAND EXTEND SsrSearchPattern
+VERNAC COMMAND EXTEND SsrSearchPattern CLASSIFIED AS QUERY
 | [ "Search" ssr_search_arg(a) ssr_modlocs(mr) ] ->
-  [ let hpat, a' = interp_search_arg a in
+  [ let hpat = interp_search_arg a in
     let in_mod = interp_modloc mr in
-    let post_filter gr env typ = in_mod gr env && hpat typ in
-    Search.raw_search_about post_filter ssrdisplaysearch a' ]
+    let post_filter gr env typ = in_mod gr env typ && hpat gr env typ in
+    let display gr env typ =
+      if post_filter gr env typ then ssrdisplaysearch gr env typ
+    in
+    Search.generic_search None display ]
 END
 
 (* }}} *)
@@ -1454,7 +1477,6 @@
 (* as this can't be done from an ML extension file, the new       *)
 (* syntax will only work when ssreflect.v is imported.            *)
 
-
 let no_ct = None, None and no_rt = None in 
 let aliasvar = function
   | [_, [CPatAlias (loc, _, id)]] -> Some (loc,Name id)
@@ -1468,31 +1490,31 @@
 GEXTEND Gram
   GLOBAL: binder_constr;
   ssr_rtype: [[ "return"; t = operconstr LEVEL "100" -> mk_rtype t ]];
-  ssr_mpat: [[ p = pattern -> [loc, [p]] ]];
+  ssr_mpat: [[ p = pattern -> [!@loc, [p]] ]];
   ssr_dpat: [
-    [ mp = ssr_mpat; "in"; t = lconstr; rt = ssr_rtype -> mp, mk_ctype mp t, rt
+    [ mp = ssr_mpat; "in"; t = pattern; rt = ssr_rtype -> mp, mk_ctype mp t, rt
     | mp = ssr_mpat; rt = ssr_rtype -> mp, mk_cnotype mp, rt
     | mp = ssr_mpat -> mp, no_ct, no_rt
   ] ];
-  ssr_dthen: [[ dp = ssr_dpat; "then"; c = lconstr -> mk_dthen loc dp c ]];
-  ssr_elsepat: [[ "else" -> [loc, [CPatAtom (loc, None)]] ]];
-  ssr_else: [[ mp = ssr_elsepat; c = lconstr -> loc, mp, c ]];
+  ssr_dthen: [[ dp = ssr_dpat; "then"; c = lconstr -> mk_dthen !@loc dp c ]];
+  ssr_elsepat: [[ "else" -> [!@loc, [CPatAtom (!@loc, None)]] ]];
+  ssr_else: [[ mp = ssr_elsepat; c = lconstr -> !@loc, mp, c ]];
   binder_constr: [
     [ "if"; c = operconstr LEVEL "200"; "is"; db1 = ssr_dthen; b2 = ssr_else ->
-      let b1, ct, rt = db1 in CCases (loc, MatchStyle, rt, [c, ct], [b1; b2])
+      let b1, ct, rt = db1 in CCases (!@loc, MatchStyle, rt, [c, ct], [b1; b2])
     | "if"; c = operconstr LEVEL "200";"isn't";db1 = ssr_dthen; b2 = ssr_else ->
       let b1, ct, rt = db1 in 
       let b1, b2 = 
         let (l1, p1, r1), (l2, p2, r2) = b1, b2 in (l1, p1, r2), (l2, p2, r1) in
-      CCases (loc, MatchStyle, rt, [c, ct], [b1; b2])
+      CCases (!@loc, MatchStyle, rt, [c, ct], [b1; b2])
     | "let"; ":"; mp = ssr_mpat; ":="; c = lconstr; "in"; c1 = lconstr ->
-      mk_let loc no_rt [c, no_ct] mp c1
+      mk_let (!@loc) no_rt [c, no_ct] mp c1
     | "let"; ":"; mp = ssr_mpat; ":="; c = lconstr;
       rt = ssr_rtype; "in"; c1 = lconstr ->
-      mk_let loc rt [c, mk_cnotype mp] mp c1
-    | "let"; ":"; mp = ssr_mpat; "in"; t = lconstr; ":="; c = lconstr;
+      mk_let (!@loc) rt [c, mk_cnotype mp] mp c1
+    | "let"; ":"; mp = ssr_mpat; "in"; t = pattern; ":="; c = lconstr;
       rt = ssr_rtype; "in"; c1 = lconstr ->
-      mk_let loc rt [c, mk_ctype mp t] mp c1
+      mk_let (!@loc) rt [c, mk_ctype mp t] mp c1
   ] ];
 END
 
@@ -1500,7 +1522,7 @@
   GLOBAL: closed_binder;
   closed_binder: [
     [ ["of" | "&"]; c = operconstr LEVEL "99" ->
-      [LocalRawAssum ([loc, Anonymous], Default Explicit, c)]
+      [LocalRawAssum ([!@loc, Anonymous], Default Explicit, c)]
   ] ];
 END
 (* }}} *)
@@ -1517,7 +1539,7 @@
 
 GEXTEND Gram
   GLOBAL: tactic_expr;
-  ssrparentacarg: [[ "("; tac = tactic_expr; ")" -> loc, Tacexp tac ]];
+  ssrparentacarg: [[ "("; tac = tactic_expr; ")" -> !@loc, Tacexp tac ]];
   tactic_expr: LEVEL "0" [[ arg = ssrparentacarg -> TacArg arg ]];
 END
 
@@ -1534,9 +1556,9 @@
   let tacname = 
     try Nametab.locate_tactic (qualid_of_ident (id_of_string "done"))
     with Not_found -> try Nametab.locate_tactic (ssrqid "done")
-    with Not_found -> Util.error "The ssreflect library was not loaded" in
+    with Not_found -> Errors.error "The ssreflect library was not loaded" in
   let tacexpr = dummy_loc, Tacexpr.Reference (ArgArg (dummy_loc, tacname)) in
-  eval_tactic (Tacexpr.TacArg tacexpr) gl
+  Proofview.V82.of_tactic (eval_tactic (Tacexpr.TacArg tacexpr)) gl
 
 let prof_donetac = mk_profiler "donetac";;
 let donetac gl = prof_donetac.profile donetac gl;;
@@ -1547,8 +1569,8 @@
       try Nametab.locate_tactic (qualid_of_ident (id_of_string "ssrautoprop"))
       with Not_found -> Nametab.locate_tactic (ssrqid "ssrautoprop") in
     let tacexpr = dummy_loc, Tacexpr.Reference (ArgArg (dummy_loc, tacname)) in
-    eval_tactic (Tacexpr.TacArg tacexpr) gl
-  with Not_found -> Auto.full_trivial [] gl
+    Proofview.V82.of_tactic (eval_tactic (Tacexpr.TacArg tacexpr)) gl
+  with Not_found -> Proofview.V82.of_tactic (Auto.full_trivial []) gl
 
 let () = ssrautoprop_tac := ssrautoprop
 
@@ -1563,7 +1585,7 @@
 (* Force use of the tactic_expr parsing entry, to rule out tick marks. *)
 let pr_ssrtacarg _ _ prt = prt tacltop
 ARGUMENT EXTEND ssrtacarg TYPED AS tactic PRINTED BY pr_ssrtacarg
-| [ "Qed" ] -> [ Util.anomaly "Grammar placeholder match" ]
+| [ "YouShouldNotTypeThis" ] -> [ anomaly "Grammar placeholder match" ]
 END
 GEXTEND Gram
   GLOBAL: ssrtacarg;
@@ -1571,12 +1593,12 @@
 END
 
 (* Lexically closed tactic for tacticals. *)
-let pr_ssrtclarg _ _ prt (tac, _) = prt tacltop tac
-ARGUMENT EXTEND ssrtclarg TYPED AS ssrtacarg * ltacctx
+let pr_ssrtclarg _ _ prt tac = prt tacltop tac
+ARGUMENT EXTEND ssrtclarg TYPED AS ssrtacarg
     PRINTED BY pr_ssrtclarg
-| [ ssrtacarg(tac) ] -> [ tac, rawltacctx ]
+| [ ssrtacarg(tac) ] -> [ tac ]
 END
-let eval_tclarg (tac, ctx) = ssrevaltac (get_ltacctx ctx) tac
+let eval_tclarg ist tac = ssrevaltac ist tac
 
 let pr_ortacs prt = 
   let rec pr_rec = function
@@ -1638,33 +1660,33 @@
 (* tactics that generate more than two subgoals).                     *)
 
 TACTIC EXTEND ssrtclplus
-| [ "Qed" "+" ssrtclarg(arg) ] -> [ eval_tclarg arg ]
+| [ "YouShouldNotTypeThis" "+" ssrtclarg(arg) ] -> [ Proofview.V82.tactic (eval_tclarg ist arg) ]
 END
 set_pr_ssrtac "tclplus" 5 [ArgSep "+ "; ArgSsr "tclarg"]
 
 TACTIC EXTEND ssrtclminus
-| [ "Qed" "-" ssrtclarg(arg) ] -> [ eval_tclarg arg ]
+| [ "YouShouldNotTypeThis" "-" ssrtclarg(arg) ] -> [ Proofview.V82.tactic (eval_tclarg ist arg) ]
 END
 set_pr_ssrtac "tclminus" 5 [ArgSep "- "; ArgSsr "tclarg"]
 
 TACTIC EXTEND ssrtclstar
-| [ "Qed" "*" ssrtclarg(arg) ] -> [ eval_tclarg arg ]
+| [ "YouShouldNotTypeThis" "*" ssrtclarg(arg) ] -> [ Proofview.V82.tactic (eval_tclarg ist arg) ]
 END
 set_pr_ssrtac "tclstar" 5 [ArgSep "- "; ArgSsr "tclarg"]
 
-let gen_tclarg = in_gen rawwit_ssrtclarg
+let gen_tclarg = in_gen (rawwit wit_ssrtclarg)
 
 GEXTEND Gram
   GLOBAL: tactic tactic_mode;
   tactic: [
-    [ "+"; tac = ssrtclarg -> ssrtac_expr loc "tclplus" [gen_tclarg tac]
-    | "-"; tac = ssrtclarg -> ssrtac_expr loc "tclminus" [gen_tclarg tac]
-    | "*"; tac = ssrtclarg -> ssrtac_expr loc "tclstar" [gen_tclarg tac] 
+    [ "+"; tac = ssrtclarg -> ssrtac_expr !@loc "tclplus" [gen_tclarg tac]
+    | "-"; tac = ssrtclarg -> ssrtac_expr !@loc "tclminus" [gen_tclarg tac]
+    | "*"; tac = ssrtclarg -> ssrtac_expr !@loc "tclstar" [gen_tclarg tac] 
     ] ];
   tactic_mode: [
-    [ "+"; tac = G_vernac.subgoal_command -> tac None 
-    | "-"; tac = G_vernac.subgoal_command -> tac None 
-    | "*"; tac = G_vernac.subgoal_command -> tac None 
+    [ "+"; tac = G_vernac.subgoal_command -> tac None
+    | "-"; tac = G_vernac.subgoal_command -> tac None
+    | "*"; tac = G_vernac.subgoal_command -> tac None
     ] ];
 END
 
@@ -1679,10 +1701,9 @@
 END
 
 TACTIC EXTEND ssrtclby
-| [ "Qed" ssrhint(tac) ltacctx(ctx)] ->
-  [ hinttac (get_ltacctx ctx) true tac ]
+| [ "YouShouldNotTypeThis" ssrhint(tac) ] -> [ Proofview.V82.tactic (hinttac ist true tac) ]
 END
-set_pr_ssrtac "tclby" 0 [ArgSsr "hint"; ArgSsr "ltacctx"]
+set_pr_ssrtac "tclby" 0 [ArgSsr "hint"]
 
 (* We can't parse "by" in ARGUMENT EXTEND because it will only be made *)
 (* into a keyword in ssreflect.v; so we anticipate this in GEXTEND.    *)
@@ -1692,9 +1713,8 @@
   ssrhint: [[ "by"; arg = ssrhintarg -> arg ]];
   simple_tactic: [
   [ "by"; arg = ssrhintarg ->
-    let garg = in_gen rawwit_ssrhint arg in
-    let gctx = in_gen rawwit_ltacctx rawltacctx in
-    ssrtac_atom loc "tclby" [garg; gctx]
+    let garg = in_gen (rawwit wit_ssrhint) arg in
+    ssrtac_atom !@loc "tclby" [garg]
   ] ];
 END
 (* }}} *)
@@ -1713,19 +1733,18 @@
 let pr_hyp (SsrHyp (_, id)) = pr_id id
 let pr_ssrhyp _ _ _ = pr_hyp
 
-let wit_ssrhyprep, globwit_ssrhyprep, rawwit_ssrhyprep =
-  add_genarg "ssrhyprep" pr_hyp
+let wit_ssrhyprep = add_genarg "ssrhyprep" pr_hyp
 
 let hyp_err loc msg id =
-  user_err_loc (loc, "ssrhyp", str msg ++ pr_id id)
+  Errors.user_err_loc (loc, "ssrhyp", str msg ++ pr_id id)
 
 let intern_hyp ist (SsrHyp (loc, id) as hyp) =
-  let _ = intern_genarg ist (in_gen rawwit_var (loc, id)) in
+  let _ = Tacintern.intern_genarg ist (in_gen (rawwit wit_var) (loc, id)) in
   if not_section_id id then hyp else
   hyp_err loc "Can't clear section hypothesis " id
 
 let interp_hyp ist gl (SsrHyp (loc, id)) =
-  let s, id' = interp_wit globwit_var wit_var ist gl (loc, id) in
+  let s, id' = interp_wit wit_var ist gl (loc, id) in
   if not_section_id id' then s, SsrHyp (loc, id') else
   hyp_err loc "Can't clear section hypothesis " id'
 
@@ -1735,6 +1754,38 @@
   | [ ident(id) ] -> [ SsrHyp (loc, id) ]
 END
 
+type ssrhyp_or_id = Hyp of ssrhyp | Id of ssrhyp
+
+let hoik f = function Hyp x -> f x | Id x -> f x
+let hoi_id = hoik hyp_id
+let pr_hoi = hoik pr_hyp
+let pr_ssrhoi _ _ _ = pr_hoi
+
+let wit_ssrhoirep = add_genarg "ssrhoirep" pr_hoi
+
+let intern_ssrhoi ist = function
+  | Hyp h -> Hyp (intern_hyp ist h)
+  | Id (SsrHyp (_, id)) as hyp ->
+    let _ = Tacintern.intern_genarg ist (in_gen (rawwit wit_ident) id) in
+    hyp
+
+let interp_ssrhoi ist gl = function
+  | Hyp h -> let s, h' = interp_hyp ist gl h in s, Hyp h'
+  | Id (SsrHyp (loc, id)) ->
+    let s, id' = interp_wit wit_ident ist gl id in
+    s, Id (SsrHyp (loc, id'))
+
+ARGUMENT EXTEND ssrhoi_hyp TYPED AS ssrhoirep PRINTED BY pr_ssrhoi
+                       INTERPRETED BY interp_ssrhoi
+                       GLOBALIZED BY intern_ssrhoi
+  | [ ident(id) ] -> [ Hyp (SsrHyp(loc, id)) ]
+END
+ARGUMENT EXTEND ssrhoi_id TYPED AS ssrhoirep PRINTED BY pr_ssrhoi
+                       INTERPRETED BY interp_ssrhoi
+                       GLOBALIZED BY intern_ssrhoi
+  | [ ident(id) ] -> [ Id (SsrHyp(loc, id)) ]
+END
+
 type ssrhyps = ssrhyp list
 
 let pr_hyps = pr_list pr_spc pr_hyp
@@ -1748,7 +1799,7 @@
   | [] -> ()
 
 let check_hyp_exists hyps (SsrHyp(_, id)) =
-  try ignore(Sign.lookup_named id hyps)
+  try ignore(Context.lookup_named id hyps)
   with Not_found -> errorstrm (str"No assumption is named " ++ pr_id id)
 
 let interp_hyps ist gl ghyps =
@@ -1781,24 +1832,16 @@
 
 let ssrtermkind = Gram.Entry.of_parser "ssrtermkind" input_ssrtermkind
 
-let id_of_Cterm t = match id_of_cpattern t with
-  | Some x -> x
-  | None -> loc_error (loc_of_cpattern t) "Only identifiers are allowed here"
-let ssrhyp_of_ssrterm = function
-  | k, (_, Some c) as o ->
-     SsrHyp (constr_loc c, id_of_Cterm (cpattern_of_term o)), String.make 1 k
-  | _, (_, None) -> assert false
-
 (* terms *)
 let pr_ssrterm _ _ _ = pr_term
-let pf_intern_term ist gl (_, c) = glob_constr ist (project gl) (pf_env gl) c
-let intern_term ist sigma env (_, c) = glob_constr ist sigma env c
+let pf_intern_term ist gl (_, c) = glob_constr ist (pf_env gl) c
+let intern_term ist sigma env (_, c) = glob_constr ist env c
 let interp_term ist gl (_, c) = snd (interp_open_constr ist gl c)
 let force_term ist gl (_, c) = interp_constr ist gl c
 let glob_ssrterm gs = function
-  | k, (_, Some c) -> k, Tacinterp.intern_constr gs c
+  | k, (_, Some c) -> k, Tacintern.intern_constr gs c
   | ct -> ct
-let subst_ssrterm s (k, c) = k, Tacinterp.subst_glob_constr_and_expr s c
+let subst_ssrterm s (k, c) = k, Tacsubst.subst_glob_constr_and_expr s c
 let interp_ssrterm _ gl t = Tacmach.project gl, t
 
 ARGUMENT EXTEND ssrterm
@@ -1807,7 +1850,7 @@
      GLOBALIZED BY glob_ssrterm SUBSTITUTED BY subst_ssrterm
      RAW_TYPED AS cpattern RAW_PRINTED BY pr_ssrterm
      GLOB_TYPED AS cpattern GLOB_PRINTED BY pr_ssrterm
-| [ "Qed" constr(c) ] -> [ mk_lterm c ]
+| [ "YouShouldNotTypeThis" constr(c) ] -> [ mk_lterm c ]
 END
 
 GEXTEND Gram
@@ -1852,24 +1895,27 @@
 (* type ssrwgen = ssrclear * ssrhyp * string *)
 
 let pr_wgen = function 
-  | (clr, Some((id,k),None)) -> spc() ++ pr_clear mt clr ++ str k ++ pr_hyp id
+  | (clr, Some((id,k),None)) -> spc() ++ pr_clear mt clr ++ str k ++ pr_hoi id
   | (clr, Some((id,k),Some p)) ->
-      spc() ++ pr_clear mt clr ++ str"(" ++ str k ++ pr_hyp id ++ str ":=" ++
+      spc() ++ pr_clear mt clr ++ str"(" ++ str k ++ pr_hoi id ++ str ":=" ++
         pr_cpattern p ++ str ")"
   | (clr, None) -> spc () ++ pr_clear mt clr
 let pr_ssrwgen _ _ _ = pr_wgen
 
 (* no globwith for char *)
 ARGUMENT EXTEND ssrwgen
-  TYPED AS ssrclear * ((ssrhyp * string) * cpattern option) option
+  TYPED AS ssrclear * ((ssrhoi_hyp * string) * cpattern option) option
   PRINTED BY pr_ssrwgen
 | [ ssrclear_ne(clr) ] -> [ clr, None ]
-| [ ssrhyp(id) ]        -> [ [], Some((id, " "), None) ]
-| [ "@" ssrhyp(id) ]   -> [ [], Some((id, "@"), None) ]
-| [ "(" ssrhyp(id) ":=" lcpattern(p) ")" ] -> [ [], Some ((id," "),Some p) ]
-| [ "(" ssrhyp(id) ")" ] -> [ [], Some ((id,"("), None) ]
-| [ "(@" ssrhyp(id) ":=" lcpattern(p) ")" ] -> [ [], Some ((id,"@"),Some p) ]
-| [ "(" "@" ssrhyp(id) ":=" lcpattern(p) ")" ] -> [ [], Some ((id,"@"),Some p) ]
+| [ ssrhoi_hyp(hyp) ] -> [ [], Some((hyp, " "), None) ]
+| [ "@" ssrhoi_hyp(hyp) ] -> [ [], Some((hyp, "@"), None) ]
+| [ "(" ssrhoi_id(id) ":=" lcpattern(p) ")" ] ->
+  [ [], Some ((id," "),Some p) ]
+| [ "(" ssrhoi_id(id) ")" ] -> [ [], Some ((id,"("), None) ]
+| [ "(@" ssrhoi_id(id) ":=" lcpattern(p) ")" ] ->
+  [ [], Some ((id,"@"),Some p) ]
+| [ "(" "@" ssrhoi_id(id) ":=" lcpattern(p) ")" ] ->
+  [ [], Some ((id,"@"),Some p) ]
 END
 
 type ssrclseq = InGoal | InHyps
@@ -1884,9 +1930,7 @@
   | InHypsSeq       -> str " |-"
   | InAllHyps       -> str "* |-"
 
-let wit_ssrclseq, globwit_ssrclseq, rawwit_ssrclseq =
-  add_genarg "ssrclseq" pr_clseq
-
+let wit_ssrclseq = add_genarg "ssrclseq" pr_clseq
 let pr_clausehyps = pr_list pr_spc pr_wgen
 let pr_ssrclausehyps _ _ _ = pr_clausehyps
 
@@ -1941,8 +1985,8 @@
 let check_wgen_uniq gens =
   let clears = List.flatten (List.map fst gens) in
   check_hyps_uniq [] clears;
-  let ids = Util.list_map_filter
-    (function (_,Some ((SsrHyp (_,id),_),_)) -> Some id | _ -> None) gens in
+  let ids = CList.map_filter
+    (function (_,Some ((id,_),_)) -> Some (hoi_id id) | _ -> None) gens in
   let rec check ids = function
   | id :: _ when List.mem id ids ->
     errorstrm (str"Duplicate generalization " ++ pr_id id)
@@ -1951,23 +1995,25 @@
   check [] ids
 
 let pf_clauseids gl gens clseq =
-  let keep_clears = List.map (fun x, _ -> x, None) in
+  let keep_clears = List.map (fun (x, _) -> x, None) in
   if gens <> [] then (check_wgen_uniq gens; gens) else
   if clseq <> InAll && clseq <> InAllHyps then keep_clears gens else
-  Util.error "assumptions should be named explicitly"
+  Errors.error "assumptions should be named explicitly"
 
 let hidden_clseq = function InHyps | InHypsSeq | InAllHyps -> true | _ -> false
 
 let hidetacs clseq idhide cl0 =
   if not (hidden_clseq clseq) then  [] else
-  [posetac idhide cl0; convert_concl_no_check (mkVar idhide)]
+  [posetac idhide cl0;
+   Proofview.V82.of_tactic (convert_concl_no_check (mkVar idhide))]
 
 let discharge_hyp (id', (id, mode)) gl =
   let cl' = subst_var id (pf_concl gl) in
   match pf_get_hyp gl id, mode with
   | (_, None, t), _ | (_, Some _, t), "(" -> 
      apply_type (mkProd (Name id', t, cl')) [mkVar id] gl
-  | (_, Some v, t), _ -> convert_concl (mkLetIn (Name id', v, t, cl')) gl
+  | (_, Some v, t), _ ->
+     Proofview.V82.of_tactic (convert_concl (mkLetIn (Name id', v, t, cl'))) gl
 
 let endclausestac id_map clseq gl_id cl0 gl =
   let not_hyp' id = not (List.mem_assoc id id_map) in
@@ -1987,16 +2033,20 @@
   | LetIn (Name id, v, t, c') when List.mem_assoc id id_map ->
     mkLetIn (Name (orig_id id), unmark v, unmark t, unmark c')
   | _ -> map_constr unmark c in
-  let utac hyp = convert_hyp_no_check (map_named_declaration unmark hyp) in
+  let utac hyp =
+    Proofview.V82.of_tactic 
+     (convert_hyp_no_check (map_named_declaration unmark hyp)) in
   let utacs = List.map utac (pf_hyps gl) in
-  let ugtac gl' = convert_concl_no_check (unmark (pf_concl gl')) gl' in
+  let ugtac gl' =
+    Proofview.V82.of_tactic
+      (convert_concl_no_check (unmark (pf_concl gl'))) gl' in
   let ctacs = if hide_goal then [clear [gl_id]] else [] in
   let mktac itacs = tclTHENLIST (itacs @ utacs @ ugtac :: ctacs) in
-  let itac (_, id) = introduction id in
+  let itac (_, id) = Proofview.V82.of_tactic (introduction id) in
   if fits false (id_map, List.rev dc) then mktac (List.map itac id_map) gl else
   let all_ids = ids_of_rel_context dc @ pf_ids_of_hyps gl in
   if List.for_all not_hyp' all_ids && not c_hidden then mktac [] gl else
-  Util.error "tampering with discharged assumptions of \"in\" tactical"
+  Errors.error "tampering with discharged assumptions of \"in\" tactical"
 
 let is_id_constr c = match kind_of_term c with
   | Lambda(_,_,c) when isRel c -> 1 = destRel c
@@ -2006,40 +2056,48 @@
   | App(hd,args) when Array.length args = 1 && is_id_constr hd -> args.(0)
   | _ -> try Tacred.red_product env sigma c with _ -> c
 
-let abs_wgen keep_let ist gl f gen (args,c) =
+let abs_wgen keep_let ist f gen (gl,args,c) =
   let sigma, env = project gl, pf_env gl in
   let evar_closed t p =
     if occur_existential t then
-      Util.user_err_loc (loc_of_cpattern p,"ssreflect",
+      Errors.user_err_loc (loc_of_cpattern p,"ssreflect",
         pr_constr_pat t ++
         str" contains holes and matches no subterm of the goal") in
   match gen with
-  | _, Some ((SsrHyp(_,x), mode), None)
-    when mode = "@" || (mode = " " && keep_let) ->
+  | _, Some ((x, mode), None) when mode = "@" || (mode = " " && keep_let) ->
+     let x = hoi_id x in
      let _, bo, ty = pf_get_hyp gl x in
+     gl,
      (if bo <> None then args else mkVar x :: args),
      mkProd_or_LetIn (Name (f x),bo,ty) (subst_var x c)
-  | _, Some ((SsrHyp(_,x), _), None) ->
-     mkVar x :: args, mkProd (Name (f x), pf_get_hyp_typ gl x, subst_var x c)
-  | _, Some ((SsrHyp(_,x), "@"), Some p) -> 
+  | _, Some ((x, _), None) ->
+     let x = hoi_id x in
+     gl, mkVar x :: args, mkProd (Name (f x), pf_get_hyp_typ gl x, subst_var x c)
+  | _, Some ((x, "@"), Some p) -> 
+     let x = hoi_id x in
      let cp = interp_cpattern ist gl p None in
-     let t, c =
+     let (t, ucst), c =
        try fill_occ_pattern ~raise_NoMatch:true env sigma c cp None 1
        with NoMatch -> redex_of_pattern env cp, c in
      evar_closed t p;
      let ut = red_product_skip_id env sigma t in
-     args, mkLetIn(Name (f x), ut, pf_type_of gl t, c)
-  | _, Some ((SsrHyp(_,x), _), Some p) ->
+     let gl, ty = pf_type_of gl t in
+     pf_merge_uc ucst gl, args, mkLetIn(Name (f x), ut, ty, c)
+  | _, Some ((x, _), Some p) ->
+     let x = hoi_id x in
      let cp = interp_cpattern ist gl p None in
-     let t, c =
+     let (t, ucst), c =
        try fill_occ_pattern ~raise_NoMatch:true env sigma c cp None 1
        with NoMatch -> redex_of_pattern env cp, c in
      evar_closed t p;
-     t :: args, mkProd(Name (f x), pf_type_of gl t, c)
-  | _ -> args, c
+     let gl, ty = pf_type_of gl t in
+     pf_merge_uc ucst gl, t :: args, mkProd(Name (f x), ty, c)
+  | _ -> gl, args, c
 
 let clr_of_wgen gen clrs = match gen with
-  | clr, Some ((x, _), None) -> cleartac clr :: cleartac [x] :: clrs
+  | clr, Some ((x, _), None) ->
+     let x = hoi_id x in
+     cleartac clr :: cleartac [SsrHyp(Loc.ghost,x)] :: clrs
   | clr, _ -> cleartac clr :: clrs
     
 let tclCLAUSES ist tac (gens, clseq) gl =
@@ -2050,12 +2108,12 @@
   let cl0 = pf_concl gl in
   let dtac gl =
     let c = pf_concl gl in
-    let args, c =
-      List.fold_right (abs_wgen true ist gl mk_discharged_id) gens ([], c) in
+    let gl, args, c =
+      List.fold_right (abs_wgen true ist mk_discharged_id) gens (gl,[], c) in
     apply_type c args gl in
   let endtac =
-    let id_map = Util.list_map_filter (function
-      | _, Some ((SsrHyp(_,id),_),_) -> Some (mk_discharged_id id, id)
+    let id_map = CList.map_filter (function
+      | _, Some ((x,_),_) -> let id = hoi_id x in Some (mk_discharged_id id, id)
       | _, None -> None) gens in
     endclausestac id_map clseq gl_id cl0 in
   tclTHENLIST (hidetacs clseq gl_id cl0 @ [dtac; clear; tac; endtac]) gl
@@ -2073,8 +2131,7 @@
 
 let pr_ssrsimpl _ _ _ = pr_simpl
 
-let wit_ssrsimplrep, globwit_ssrsimplrep, rawwit_ssrsimplrep =
-  add_genarg "ssrsimplrep" pr_simpl
+let wit_ssrsimplrep = add_genarg "ssrsimplrep" pr_simpl
 
 ARGUMENT EXTEND ssrsimpl_ne TYPED AS ssrsimplrep PRINTED BY pr_ssrsimpl
 | [ "/=" ] -> [ Simpl ]
@@ -2091,7 +2148,7 @@
 
 let safe_simpltac gl =
   let cl' = red_safe Tacred.simpl (pf_env gl) (project gl) (pf_concl gl) in
-  convert_concl_no_check cl' gl
+  Proofview.V82.of_tactic (convert_concl_no_check cl') gl
 
 let simpltac = function
   | Simpl -> safe_simpltac
@@ -2106,10 +2163,11 @@
 
 let rewritetac dir c =
   (* Due to the new optional arg ?tac, application shouldn't be too partial *)
-  Equality.general_rewrite (dir = L2R) all_occurrences true false c
+  Proofview.V82.of_tactic begin
+    Equality.general_rewrite (dir = L2R) AllOccurrences true false c
+  end
 
-let wit_ssrdir, globwit_ssrdir, rawwit_ssrdir =
-  add_genarg "ssrdir" pr_dir
+let wit_ssrdir = add_genarg "ssrdir" pr_dir
 
 let dir_org = function L2R -> 1 | R2L -> 2
 
@@ -2125,7 +2183,7 @@
 
 let pr_index = function
   | ArgVar (_, id) -> pr_id id
-  | ArgArg n when n > 0 -> pr_int n
+  | ArgArg n when n > 0 -> int n
   | _ -> mt ()
 let pr_ssrindex _ _ _ = pr_index
 
@@ -2141,15 +2199,21 @@
   match idx with
   | ArgArg _ -> idx
   | ArgVar (loc, id) ->
-    let i = try match List.assoc id ist.lfun with
-    | VInteger i -> i
-    | VConstr ([],c) ->
-      let rc = Detyping.detype false [] [] c in
-      begin match Notation.uninterp_prim_token rc with
-      | _, Numeral bigi -> int_of_string (Bigint.to_string bigi)
-      | _ -> raise Not_found
-      end
-    | _ -> raise Not_found
+    let i =
+      try
+        let v = Id.Map.find id ist.lfun in
+        begin match Value.to_int v with
+        | Some i -> i
+        | None ->
+        begin match Value.to_constr v with
+        | Some c ->
+          let rc = Detyping.detype false [] (pf_env gl) (project gl) c in
+          begin match Notation.uninterp_prim_token rc with
+          | _, Numeral bigi -> int_of_string (Bigint.to_string bigi)
+          | _ -> raise Not_found
+          end
+        | None -> raise Not_found
+        end end
     with _ -> loc_error loc "Index not a number" in
     ArgArg (check_index loc i)
 
@@ -2187,9 +2251,9 @@
 END
 
 let pf_mkprod gl c ?(name=constr_name c) cl =
-  let t = pf_type_of gl c in
-  if name <> Anonymous || noccurn 1 cl then mkProd (name, t, cl) else
-  mkProd (Name (pf_type_id gl t), t, cl)
+  let gl, t = pf_type_of gl c in
+  if name <> Anonymous || noccurn 1 cl then gl, mkProd (name, t, cl) else
+  gl, mkProd (Name (pf_type_id gl t), t, cl)
 
 let pf_abs_prod name gl c cl = pf_mkprod gl c ~name (subst_term c cl)
 
@@ -2224,8 +2288,8 @@
 let rec isCxHoles = function (CHole _, None) :: ch -> isCxHoles ch | _ -> false
 
 let pr_raw_ssrhintref prc _ _ = function
-  | CAppExpl (_, (None, r), args) when isCHoles args ->
-    prc (CRef r) ++ str "|" ++ int (List.length args)
+  | CAppExpl (_, (None, r,x), args) when isCHoles args ->
+    prc (CRef (r,x)) ++ str "|" ++ int (List.length args)
   | CApp (_, (_, CRef _), _) as c -> prc c
   | CApp (_, (_, c), args) when isCxHoles args ->
     prc c ++ str "|" ++ int (List.length args)
@@ -2241,7 +2305,7 @@
 let pr_ssrhintref prc _ _ = prc
 
 let mkhintref loc c n = match c with
-  | CRef r -> CAppExpl (loc, (None, r), mkCHoles loc n)
+  | CRef (r,x) -> CAppExpl (loc, (None, r, x), mkCHoles loc n)
   | _ -> mkAppC (c, mkCHoles loc n)
 
 ARGUMENT EXTEND ssrhintref
@@ -2282,7 +2346,7 @@
 
 let _ =
   let init () = Array.fill viewtab 0 3 [] in
-  let freeze () = Array.copy viewtab in
+  let freeze _ = Array.copy viewtab in
   let unfreeze vt = Array.blit vt 0 viewtab 0 3 in
   Summary.declare_summary "ssrview"
     { Summary.freeze_function   = freeze;
@@ -2296,19 +2360,19 @@
   let pp_hints = pr_list spc pr_rawhintref viewtab.(i) in
   ppnl (pp_viewname ++ hov 0 pp_hints ++ Pp.cut ())
 
-VERNAC COMMAND EXTEND PrintView
+VERNAC COMMAND EXTEND PrintView CLASSIFIED AS QUERY
 | [ "Print" "Hint" "View" ssrviewpos(i) ] -> [ mapviewpos print_view_hints i 3 ]
 END
 
 (* Populating the table *)
 
 let cache_viewhint (_, (i, lvh)) =
-  let mem_raw h = List.exists (Topconstr.eq_glob_constr h) in 
+  let mem_raw h = List.exists (Notation_ops.eq_glob_constr h) in
   let add_hint h hdb = if mem_raw h hdb then hdb else h :: hdb in
   viewtab.(i) <- List.fold_right add_hint lvh viewtab.(i)
 
 let subst_viewhint ( subst, (i, lvh as ilvh)) =
-  let lvh' = list_smartmap (Detyping.subst_glob_constr subst) lvh in
+  let lvh' = List.smartmap (Detyping.subst_glob_constr subst) lvh in
   if lvh' == lvh then ilvh else i, lvh'
       
 let classify_viewhint x = Libobject.Substitute x
@@ -2321,11 +2385,11 @@
        Libobject.classify_function = classify_viewhint }
 
 let glob_view_hints lvh =
-  List.map (Constrintern.intern_constr Evd.empty (Global.env ())) lvh
+  List.map (Constrintern.intern_constr (Global.env ())) lvh
 
 let add_view_hints lvh i = Lib.add_anonymous_leaf (in_viewhint (i, lvh))
 
-VERNAC COMMAND EXTEND HintView
+VERNAC COMMAND EXTEND HintView CLASSIFIED AS SIDEFF
   |  [ "Hint" "View" ssrviewposspc(n) ne_ssrhintref_list(lvh) ] ->
      [ mapviewpos (add_view_hints (glob_view_hints lvh)) n 2 ]
 END
@@ -2381,7 +2445,8 @@
 let top_id = mk_internal_id "top assumption"
 
 let with_view ist si env gl0 c name cl prune =
-  let c2r ist x = { ist with lfun = (top_id, VConstr ([], x)) :: ist.lfun } in
+  let c2r ist x = { ist with lfun =
+    Id.Map.add top_id (Value.of_constr x) ist.lfun } in
   let rec loop (sigma, c') = function
   | f :: view ->
       let rid, ist = match kind_of_term c' with
@@ -2391,9 +2456,11 @@
   | [] ->
       let sigma = Typeclasses.resolve_typeclasses ~fail:false env sigma in
       let c' = Reductionops.nf_evar sigma c' in
-      let n, c', _ = pf_abs_evars gl0 (sigma, c') in
+      let n, c', _, ucst = pf_abs_evars gl0 (sigma, c') in
       let c' = if not prune then c' else pf_abs_cterm gl0 n c' in
-      pf_abs_prod name gl0 c' (prod_applist cl [c]), c'
+      let gl0 = pf_merge_uc ucst gl0 in
+      let gl0, ap = pf_abs_prod name gl0 c' (prod_applist cl [c]) in
+      ap, c', pf_merge_uc_of sigma gl0
   in loop
 
 let pf_with_view ist gl (prune, view) cl c =
@@ -2420,15 +2487,18 @@
 let remove_loc = snd
 
 let rec ipat_of_intro_pattern = function
-  | IntroIdentifier id -> IpatId id
-  | IntroWildcard -> IpatWild
-  | IntroOrAndPattern iorpat ->
+  | IntroNaming (IntroIdentifier id) -> IpatId id
+  | IntroAction IntroWildcard -> IpatWild
+  | IntroAction (IntroOrAndPattern iorpat) ->
     IpatCase 
       (List.map (List.map ipat_of_intro_pattern) 
 	 (List.map (List.map remove_loc) iorpat))
-  | IntroAnonymous -> IpatAnon
-  | IntroRewrite b -> IpatRw (allocc, if b then L2R else R2L)
-  | IntroFresh id -> IpatAnon
+  | IntroNaming IntroAnonymous -> IpatAnon
+  | IntroAction (IntroRewrite b) -> IpatRw (allocc, if b then L2R else R2L)
+  | IntroNaming (IntroFresh id) -> IpatAnon
+  | IntroAction (IntroApplyOn _) -> (* to do *) Errors.error "TO DO"
+  | IntroAction (IntroInjection ips) ->
+      IpatCase [List.map ipat_of_intro_pattern (List.map remove_loc ips)]
   | IntroForthcoming _ -> (* Unable to determine which kind of ipat interp_introid could return [HH] *)
       assert false
 
@@ -2446,8 +2516,7 @@
 and pr_iorpat iorpat = pr_list pr_bar pr_ipats iorpat
 and pr_ipats ipats = pr_list spc pr_ipat ipats
 
-let wit_ssripatrep, globwit_ssripatrep, rawwit_ssripatrep =
-  add_genarg "ssripatrep" pr_ipat
+let wit_ssripatrep = add_genarg "ssripatrep" pr_ipat
 
 let pr_ssripat _ _ _ = pr_ipat
 let pr_ssripats _ _ _ = pr_ipats
@@ -2463,25 +2532,27 @@
 let intern_ipats ist = List.map (intern_ipat ist)
 
 let interp_introid ist gl id =
- try IntroIdentifier (hyp_id (snd (interp_hyp ist gl (SsrHyp (dummy_loc, id)))))
- with _ -> snd(snd (interp_intro_pattern ist gl (dummy_loc,IntroIdentifier id)))
+ try IntroNaming (IntroIdentifier (hyp_id (snd (interp_hyp ist gl (SsrHyp (dummy_loc, id))))))
+ with _ -> snd(snd (interp_intro_pattern ist gl (dummy_loc,IntroNaming (IntroIdentifier id))))
 
 let rec add_intro_pattern_hyps (loc, ipat) hyps = match ipat with
-  | IntroIdentifier id ->
+  | IntroNaming (IntroIdentifier id) ->
     if not_section_id id then SsrHyp (loc, id) :: hyps else
     hyp_err loc "Can't delete section hypothesis " id
-  | IntroWildcard -> hyps
-  | IntroOrAndPattern iorpat ->
+  | IntroAction IntroWildcard -> hyps
+  | IntroAction (IntroOrAndPattern iorpat) ->
     List.fold_right (List.fold_right add_intro_pattern_hyps) iorpat hyps
-  | IntroAnonymous -> []
-  | IntroFresh _ -> []
-  | IntroRewrite _ -> hyps
+  | IntroNaming IntroAnonymous -> []
+  | IntroNaming (IntroFresh _) -> []
+  | IntroAction (IntroRewrite _) -> hyps
+  | IntroAction (IntroInjection ips) -> List.fold_right add_intro_pattern_hyps ips hyps
+  | IntroAction (IntroApplyOn (c,pat)) -> add_intro_pattern_hyps pat hyps
   | IntroForthcoming _ -> 
     (* As in ipat_of_intro_pattern, was unable to determine which kind
       of ipat interp_introid could return [HH] *) assert false
 
 let rec interp_ipat ist gl =
-  let ltacvar id = List.mem_assoc id ist.lfun in
+  let ltacvar id = Id.Map.mem id ist.lfun in
   let rec interp = function
   | IpatId id when ltacvar id ->
     ipat_of_intro_pattern (interp_introid ist gl id)
@@ -2495,7 +2566,7 @@
   | IpatNewHidden l ->
       IpatNewHidden
         (List.map (function
-           | IntroIdentifier id -> id
+           | IntroNaming (IntroIdentifier id) -> id
            | _ -> assert false)
         (List.map (interp_introid ist gl) l))
   | ipat -> ipat in
@@ -2561,7 +2632,7 @@
 let reject_ssrhid strm =
   match Compat.get_tok (stream_nth 0 strm) with
   | Tok.KEYWORD "[" ->
-      (match Compat.get_tok (stream_nth 0 strm) with
+      (match Compat.get_tok (stream_nth 1 strm) with
       | Tok.KEYWORD ":" -> raise Stream.Failure
       | _ -> ())
   | _ -> ()
@@ -2569,7 +2640,7 @@
 let test_nohidden = Gram.Entry.of_parser "test_ssrhid" reject_ssrhid
 
 ARGUMENT EXTEND ssrcpat TYPED AS ssripatrep PRINTED BY pr_ssripat
-  | [ "Qed" ssriorpat(x) ] -> [ IpatCase x ]
+  | [ "YouShouldNotTypeThis" ssriorpat(x) ] -> [ IpatCase x ]
 END
 
 GEXTEND Gram
@@ -2588,7 +2659,7 @@
 
 (* subsets of patterns *)
 let check_ssrhpats loc w_binders ipats =
-  let err_loc s = user_err_loc (loc, "ssreflect", s) in
+  let err_loc s = Errors.user_err_loc (loc, "ssreflect", s) in
   let clr, ipats =
     let rec aux clr = function
       | IpatSimpl (cl, Nop) :: tl -> aux (clr @ cl) tl
@@ -2648,20 +2719,20 @@
   | [ "<-" ] -> [ IpatRw (allocc, R2L) ]
 END
 
-type ssrintros = ssripats * ltacctx
+type ssrintros = ssripats
 
-let pr_intros sep (intrs, _) =
+let pr_intros sep intrs =
   if intrs = [] then mt() else sep () ++ str "=> " ++ pr_ipats intrs
 let pr_ssrintros _ _ _ = pr_intros mt
 
-ARGUMENT EXTEND ssrintros_ne TYPED AS ssripat * ltacctx
+ARGUMENT EXTEND ssrintros_ne TYPED AS ssripat
  PRINTED BY pr_ssrintros
-  | [ "=>" ssripats_ne(pats) ] -> [ pats, rawltacctx ]
+  | [ "=>" ssripats_ne(pats) ] -> [ pats ]
 END
 
 ARGUMENT EXTEND ssrintros TYPED AS ssrintros_ne PRINTED BY pr_ssrintros
   | [ ssrintros_ne(intrs) ] -> [ intrs ]
-  | [ ] -> [ [], rawltacctx ]
+  | [ ] -> [ [] ]
 END
 
 let injecteq_id = mk_internal_id "injection equation"
@@ -2679,8 +2750,10 @@
 
 let equality_inj l b id c gl =
   let msg = ref "" in
-  try Equality.inj l b c gl
-  with Compat.Loc.Exc_located(_,UserError (_,s)) | UserError (_,s)
+  try Proofview.V82.of_tactic (Equality.inj l b None c) gl
+  with
+    | Compat.Exc_located(_,Errors.UserError (_,s))
+    | Errors.UserError (_,s)
   when msg := Pp.string_of_ppcmds s;
        !msg = "Not a projectable equality but a discriminable one." ||
        !msg = "Nothing to inject." ->
@@ -2688,7 +2761,7 @@
     discharge_hyp (id, (id, "")) gl
 
 let injectidl2rtac id c gl =
-  tclTHEN (equality_inj [] true id c) (revtoptac (pf_nb_prod gl)) gl
+  tclTHEN (equality_inj None true id c) (revtoptac (pf_nb_prod gl)) gl
 
 let injectl2rtac c = match kind_of_term c with
 | Var id -> injectidl2rtac id (mkVar id, NoBindings)
@@ -2697,21 +2770,24 @@
   tclTHENLIST [havetac id c; injectidl2rtac id (mkVar id, NoBindings); clear [id]]
 
 let is_injection_case c gl =
-  let mind, _ = pf_reduce_to_quantified_ind gl (pf_type_of gl c) in
-  mkInd mind = build_coq_eq ()
+  let gl, cty = pf_type_of gl c in
+  let (mind,_), _ = pf_reduce_to_quantified_ind gl cty in
+  eq_gr (IndRef mind) (build_coq_eq ())
 
 let perform_injection c gl =
-  let mind, t = pf_reduce_to_quantified_ind gl (pf_type_of gl c) in
+  let gl, cty = pf_type_of gl c in
+  let mind, t = pf_reduce_to_quantified_ind gl cty in
   let dc, eqt = decompose_prod t in
   if dc = [] then injectl2rtac c gl else
-  if not (closed0 eqt) then error "can't decompose a quantified equality" else
+  if not (closed0 eqt) then
+    Errors.error "can't decompose a quantified equality" else
   let cl = pf_concl gl in let n = List.length dc in
   let c_eq = mkEtaApp c n 2 in
   let cl1 = mkLambda (Anonymous, mkArrow eqt cl, mkApp (mkRel 1, [|c_eq|])) in
   let id = injecteq_id in
   let id_with_ebind = (mkVar id, NoBindings) in
   let injtac = tclTHEN (introid id) (injectidl2rtac id id_with_ebind) in 
-  tclTHENLAST (apply (compose_lam dc cl1)) injtac gl  
+  tclTHENLAST (Proofview.V82.of_tactic (apply (compose_lam dc cl1))) injtac gl  
 
 let simplest_newcase_ref = ref (fun t gl -> assert false)
 let simplest_newcase x gl = !simplest_newcase_ref x gl
@@ -2727,7 +2803,7 @@
 let rec intro_anon gl =
   try anontac (List.hd (fst (Term.decompose_prod_n_assum 1 (pf_concl gl)))) gl
   with err0 -> try tclTHEN red_in_concl intro_anon gl with _ -> raise err0
-  (* with _ -> error "No product even after reduction" *)
+  (* with _ -> Errors.error "No product even after reduction" *)
 
 let with_top tac =
   tclTHENLIST [introid top_id; tac (mkVar top_id); clear [top_id]]
@@ -2751,7 +2827,7 @@
     let vars = global_vars_set_of_decl (pf_env gl) nd in
     let occurs id' = Idset.mem id' vars in
     if List.exists occurs clr then id :: clr else clr in
-  clear (Sign.fold_named_context_reverse extend_clr ~init:clr0 (pf_hyps gl)) gl
+  clear (Context.fold_named_context_reverse extend_clr ~init:clr0 (pf_hyps gl)) gl
 
 let tclTHENS_nonstrict tac tacl taclname gl =
   let tacres = tac gl in
@@ -2761,7 +2837,7 @@
   if n_gls = 0 then tacres else
   let pr_only n1 n2 = if n1 < n2 then str "only " else mt () in
   let pr_nb n1 n2 name =
-    pr_only n1 n2 ++ int n1 ++ str (" " ^ plural n1 name) in
+    pr_only n1 n2 ++ int n1 ++ str (" " ^ String.plural n1 name) in
   errorstrm (pr_nb n_tac n_gls taclname ++ spc ()
              ++ str "for " ++ pr_nb n_gls n_tac "subgoal")
 
@@ -2783,30 +2859,33 @@
   if n = 0 then mkConstruct path_of_O
   else mkApp (mkConstruct path_of_S, [|nat_of_n (n-1)|])
 
-let ssr_abstract_id = ref 0
-let _ =
-  Summary.declare_summary "SSR:abstractid"
-    { Summary.freeze_function   = (fun _ -> !ssr_abstract_id);
-      Summary.unfreeze_function = (fun x -> ssr_abstract_id := x);
-      Summary.init_function     = (fun () -> ssr_abstract_id := 0) }
+let ssr_abstract_id = Summary.ref "~name:SSR:abstractid" 0
 
 let mk_abstract_id () = incr ssr_abstract_id; nat_of_n !ssr_abstract_id
 
 let ssrmkabs id gl =
   let env, concl = pf_env gl, pf_concl gl in
-  let sigma, abstract_proof, abstract_ty =
-    let sigma, ty = Evarutil.new_type_evar Evd.empty env in
-    let sigma,lock = Evarutil.new_evar sigma env (mkSsrConst "abstract_lock") in
-    let abstract_ty =
-      mkApp(mkSsrConst "abstract", [|ty;mk_abstract_id ();lock|]) in
-    let sigma, m = Evarutil.new_evar sigma env abstract_ty in
-    sigma, m, abstract_ty in
-  let sigma, kont =
-    let rd = Name id, None, abstract_ty in
-    Evarutil.new_evar sigma (Environ.push_rel rd env) concl in
-  pp(lazy(pr_constr concl));
-  let step = mkApp (mkLambda(Name id,abstract_ty,kont) ,[|abstract_proof|]) in
-  Refine.refine (sigma, step) gl
+  let step sigma =
+    let sigma, abstract_proof, abstract_ty =
+      let sigma, (ty, _) =
+        Evarutil.new_type_evar env sigma Evd.univ_flexible_alg in
+      let sigma, ablock = mkSsrConst "abstract_lock" env sigma in
+      let sigma, lock = Evarutil.new_evar env sigma ablock in
+      let sigma, abstract = mkSsrConst "abstract" env sigma in
+      let abstract_ty = mkApp(abstract, [|ty;mk_abstract_id ();lock|]) in
+      let sigma, m = Evarutil.new_evar env sigma abstract_ty in
+      sigma, m, abstract_ty in
+    let sigma, kont =
+      let rd = Name id, None, abstract_ty in
+      Evarutil.new_evar (Environ.push_rel rd env) sigma concl in
+    pp(lazy(pr_constr concl));
+    let term = mkApp (mkLambda(Name id,abstract_ty,kont) ,[|abstract_proof|]) in
+    let sigma, _ = Typing.type_of env sigma term in
+    sigma, term in
+  Proofview.V82.of_tactic
+    (Proofview.tclTHEN
+      (Tactics.New.refine step)
+      (Proofview.tclFOCUS 1 3 Proofview.shelve)) gl
 
 let ssrmkabstac ids =
   List.fold_right (fun id tac -> tclTHENFIRST (ssrmkabs id) tac) ids tclIDTAC
@@ -2836,7 +2915,7 @@
           let x' = mk_anon_id (string_of_id x) gl in
           SsrHyp (dummy_loc, x'), (x, x')) clr) in
       let () = to_clr := ren_clr in
-      rename_hyp ren gl 
+      Proofview.V82.of_tactic (rename_hyp ren) gl 
     else
       let () = to_clr := clr in
       tclIDTAC gl in
@@ -2894,17 +2973,14 @@
    | ipat :: ipats -> ipat :: eqpat :: ipats
 
 (* General case *)
-let tclINTROS tac (ipats, ctx) = 
-  let ist = get_ltacctx ctx in
+let tclINTROS ist tac ipats = 
   tclEQINTROS ~ist (tac ist) tclIDTAC ipats
 
 (** The "=>" tactical *)
 
 let ssrintros_sep =
   let atom_sep = function
-    | TacSplit (_,_, [NoBindings]) -> mt
-    | TacLeft (_, NoBindings) -> mt
-    | TacRight (_, NoBindings) -> mt
+    | TacSplit (_, [NoBindings]) -> mt
     (* | TacExtend (_, "ssrapply", []) -> mt *)
     | _ -> spc in
   function
@@ -2919,24 +2995,24 @@
 
 ARGUMENT EXTEND ssrintrosarg TYPED AS tactic * ssrintros
    PRINTED BY pr_ssrintrosarg
-| [ "Qed" ssrtacarg(arg) ssrintros_ne(ipats) ] -> [ arg, ipats ]
+| [ "YouShouldNotTypeThis" ssrtacarg(arg) ssrintros_ne(ipats) ] -> [ arg, ipats ]
 END
 
 TACTIC EXTEND ssrtclintros
-| [ "Qed" ssrintrosarg(arg) ] ->
+| [ "YouShouldNotTypeThis" ssrintrosarg(arg) ] ->
   [ let tac, intros = arg in
-    tclINTROS (fun ist -> ssrevaltac ist tac) intros ]
+    Proofview.V82.tactic (tclINTROS ist (fun ist -> ssrevaltac ist tac) intros) ]
 END
 set_pr_ssrtac "tclintros" 0 [ArgSsr "introsarg"]
 
 let tclintros_expr loc tac ipats =
-  let args = [in_gen rawwit_ssrintrosarg (tac, ipats)] in
+  let args = [in_gen (rawwit wit_ssrintrosarg) (tac, ipats)] in
   ssrtac_expr loc "tclintros" args
 
 GEXTEND Gram
   GLOBAL: tactic_expr;
   tactic_expr: LEVEL "1" [ RIGHTA
-    [ tac = tactic_expr; intros = ssrintros_ne -> tclintros_expr loc tac intros
+    [ tac = tactic_expr; intros = ssrintros_ne -> tclintros_expr !@loc tac intros
     ] ];
 END
 (* }}} *)
@@ -2949,8 +3025,8 @@
 
 let pr_mmod = function May -> str "?" | Must -> str "!" | Once -> mt ()
 
-let wit_ssrmmod, globwit_ssrmmod, rawwit_ssrmmod = add_genarg "ssrmmod" pr_mmod
-let ssrmmod = Gram.Entry.create "ssrmmod"
+let wit_ssrmmod = add_genarg "ssrmmod" pr_mmod
+let ssrmmod = Pcoq.create_generic_entry "ssrmmod" (Genarg.rawwit wit_ssrmmod)
 GEXTEND Gram
   GLOBAL: ssrmmod;
   ssrmmod: [[ "!" -> Must | LEFTQMARK -> May | "?" -> May]];
@@ -2972,9 +3048,12 @@
   let tac_err_at i gl =
     try tac gl
     with 
-    | UserError (l, s) -> raise (UserError (l, prefix i ++ s))
-    | Compat.Loc.Exc_located(loc, UserError (l, s))  -> 
-        raise (Compat.Loc.Exc_located(loc, UserError (l, prefix i ++ s))) in
+    | Errors.UserError (l, s) as e ->
+        let _, info = Errors.push e in
+        let e' = Errors.UserError (l, prefix i ++ s) in
+        Util.iraise (e', info)
+    | Compat.Exc_located(loc, Errors.UserError (l, s))  -> 
+        raise (Compat.Exc_located(loc, Errors.UserError (l, prefix i ++ s))) in
   let rec loop i gl =
     if i = n then tac_err_at i gl else
     (tclTHEN (tac_err_at i) (loop (i + 1))) gl in
@@ -2991,31 +3070,30 @@
 (** The "do" tactical. ********************************************************)
 
 (*
-type ssrdoarg = ((ssrindex * ssrmmod) * (ssrhint * ltacctx)) * ssrclauses
+type ssrdoarg = ((ssrindex * ssrmmod) * ssrhint) * ssrclauses
 *)
 
-let pr_ssrdoarg prc _ prt (((n, m), (tac, _)), clauses) =
+let pr_ssrdoarg prc _ prt (((n, m), tac), clauses) =
   pr_index n ++ pr_mmod m ++ pr_hintarg prt tac ++ pr_clauses clauses
 
 ARGUMENT EXTEND ssrdoarg
-  TYPED AS ((ssrindex * ssrmmod) * (ssrhintarg * ltacctx)) * ssrclauses
+  TYPED AS ((ssrindex * ssrmmod) * ssrhintarg) * ssrclauses
   PRINTED BY pr_ssrdoarg
-| [ "Qed" ] -> [ anomaly "Grammar placeholder match" ]
+| [ "YouShouldNotTypeThis" ] -> [ anomaly "Grammar placeholder match" ]
 END
 
-let ssrdotac (((n, m), (tac, ctx)), clauses) =
+let ssrdotac ist (((n, m), tac), clauses) =
   let mul = get_index n, m in
-  let ist = get_ltacctx ctx in
   tclCLAUSES ist (tclMULT mul (hinttac ist false tac)) clauses
 
 TACTIC EXTEND ssrtcldo
-| [ "Qed" "do" ssrdoarg(arg) ] -> [ ssrdotac arg ]
+| [ "YouShouldNotTypeThis" "do" ssrdoarg(arg) ] -> [ Proofview.V82.tactic (ssrdotac ist arg) ]
 END
 set_pr_ssrtac "tcldo" 3 [ArgSep "do "; ArgSsr "doarg"]
 
 let ssrdotac_expr loc n m tac clauses =
-  let arg = ((n, m), (tac, rawltacctx)), clauses in
-  ssrtac_expr loc "tcldo" [in_gen rawwit_ssrdoarg arg]
+  let arg = ((n, m), tac), clauses in
+  ssrtac_expr loc "tcldo" [in_gen (rawwit wit_ssrdoarg) arg]
 
 GEXTEND Gram
   GLOBAL: tactic_expr;
@@ -3025,12 +3103,12 @@
   ] ];
   tactic_expr: LEVEL "3" [ RIGHTA
     [ IDENT "do"; m = ssrmmod; tac = ssrdotac; clauses = ssrclauses ->
-      ssrdotac_expr loc noindex m tac clauses
+      ssrdotac_expr !@loc noindex m tac clauses
     | IDENT "do"; tac = ssrortacarg; clauses = ssrclauses ->
-      ssrdotac_expr loc noindex Once tac clauses
+      ssrdotac_expr !@loc noindex Once tac clauses
     | IDENT "do"; n = int_or_var; m = ssrmmod;
                   tac = ssrdotac; clauses = ssrclauses ->
-      ssrdotac_expr loc (mk_index loc n) m tac clauses
+      ssrdotac_expr !@loc (mk_index !@loc n) m tac clauses
     ] ];
 END
 (* }}} *)
@@ -3053,7 +3131,7 @@
 (* an unindexed tactic.                                            *)
 ARGUMENT EXTEND ssrseqarg TYPED AS ssrindex * (ssrhintarg * tactic option)
                           PRINTED BY pr_ssrseqarg
-| [ "Qed" ] -> [ anomaly "Grammar placeholder match" ]
+| [ "YouShouldNotTypeThis" ] -> [ anomaly "Grammar placeholder match" ]
 END
 
 let sq_brace_tacnames =
@@ -3067,7 +3145,7 @@
 
 let test_ssrseqvar = Gram.Entry.of_parser "test_ssrseqvar" accept_ssrseqvar
 
-let swaptacarg (loc, b) = (b, []), Some (TacAtom (loc, TacRevert []))
+let swaptacarg (loc, b) = (b, []), Some (TacId [])
 
 let check_seqtacarg dir arg = match snd arg, dir with
   | ((true, []), Some (TacAtom (loc, _))), L2R ->
@@ -3076,14 +3154,14 @@
     loc_error loc "expected \"first\""
   | _, _ -> arg
 
-let ssrorelse = Gram.Entry.create "ssrorelse"
+let ssrorelse = Gram.entry_create "ssrorelse"
 GEXTEND Gram
   GLOBAL: ssrorelse ssrseqarg;
   ssrseqidx: [
-    [ test_ssrseqvar; id = Prim.ident -> ArgVar (loc, id)
-    | n = Prim.natural -> ArgArg (check_index loc n)
+    [ test_ssrseqvar; id = Prim.ident -> ArgVar (!@loc, id)
+    | n = Prim.natural -> ArgArg (check_index !@loc n)
     ] ];
-  ssrswap: [[ IDENT "first" -> loc, true | IDENT "last" -> loc, false ]];
+  ssrswap: [[ IDENT "first" -> !@loc, true | IDENT "last" -> !@loc, false ]];
   ssrorelse: [[ "||"; tac = tactic_expr LEVEL "2" -> tac ]];
   ssrseqarg: [
     [ arg = ssrswap -> noindex, swaptacarg arg
@@ -3142,15 +3220,15 @@
 let rot_hyps dir i hyps =
   let n = List.length hyps in
   if i = 0 then List.rev hyps else
-  if i > n then error "Not enough subgoals" else
+  if i > n then Errors.error "Not enough subgoals" else
   let rec rot i l_hyps = function
     | hyp :: hyps' when i > 0 -> rot (i - 1) (hyp :: l_hyps) hyps'
     | hyps' -> hyps' @ (List.rev l_hyps) in
   rot (match dir with L2R -> i | R2L -> n - i) [] hyps
 
-let tclSEQAT (atac1, ctx) dir (ivar, ((_, atacs2), atac3)) =
+let tclSEQAT ist atac1 dir (ivar, ((_, atacs2), atac3)) =
   let i = get_index ivar in
-  let evtac = ssrevaltac (get_ltacctx ctx) in
+  let evtac = ssrevaltac ist in
   let tac1 = evtac atac1 in
   if atacs2 = [] && atac3 <> None then tclPERM (rot_hyps dir i) tac1  else
   let evotac = function Some atac -> evtac atac | _ -> tclIDTAC in
@@ -3169,25 +3247,25 @@
   | R2L -> str ";" ++ spc () ++ str "last "
 
 ARGUMENT EXTEND ssrseqdir TYPED AS ssrdir PRINTED BY pr_ssrseqdir
-| [ "Qed" ] -> [ anomaly "Grammar placeholder match" ]
+| [ "YouShouldNotTypeThis" ] -> [ anomaly "Grammar placeholder match" ]
 END
 
 TACTIC EXTEND ssrtclseq
-| [ "Qed" ssrtclarg(tac) ssrseqdir(dir) ssrseqarg(arg) ] ->
-  [ tclSEQAT tac dir arg ]
+| [ "YouShouldNotTypeThis" ssrtclarg(tac) ssrseqdir(dir) ssrseqarg(arg) ] ->
+  [ Proofview.V82.tactic (tclSEQAT ist tac dir arg) ]
 END
 set_pr_ssrtac "tclseq" 5 [ArgSsr "tclarg"; ArgSsr "seqdir"; ArgSsr "seqarg"]
 
 let tclseq_expr loc tac dir arg =
-  let arg1 = in_gen rawwit_ssrtclarg (tac, rawltacctx) in
-  let arg2 = in_gen rawwit_ssrseqdir dir in
-  let arg3 = in_gen rawwit_ssrseqarg (check_seqtacarg dir arg) in
+  let arg1 = in_gen (rawwit wit_ssrtclarg) tac in
+  let arg2 = in_gen (rawwit wit_ssrseqdir) dir in
+  let arg3 = in_gen (rawwit wit_ssrseqarg) (check_seqtacarg dir arg) in
   ssrtac_expr loc "tclseq" [arg1; arg2; arg3]
 
 GEXTEND Gram
   GLOBAL: tactic_expr;
   ssr_first: [
-    [ tac = ssr_first; ipats = ssrintros_ne -> tclintros_expr loc tac ipats
+    [ tac = ssr_first; ipats = ssrintros_ne -> tclintros_expr !@loc tac ipats
     | "["; tacl = LIST0 tactic_expr SEP "|"; "]" -> TacFirst tacl
     ] ];
   ssr_first_else: [
@@ -3195,11 +3273,11 @@
     | tac = ssr_first -> tac ]];
   tactic_expr: LEVEL "4" [ LEFTA
     [ tac1 = tactic_expr; ";"; IDENT "first"; tac2 = ssr_first_else ->
-      TacThen (tac1,[||], tac2,[||])
+      TacThen (tac1, tac2)
     | tac = tactic_expr; ";"; IDENT "first"; arg = ssrseqarg ->
-      tclseq_expr loc tac L2R arg
+      tclseq_expr !@loc tac L2R arg
     | tac = tactic_expr; ";"; IDENT "last"; arg = ssrseqarg ->
-      tclseq_expr loc tac R2L arg
+      tclseq_expr !@loc tac R2L arg
     ] ];
 END
 (* }}} *)
@@ -3217,8 +3295,8 @@
     else
        let sigma = Typeclasses.resolve_typeclasses ~fail:false env sigma in
        sigma, Evarutil.nf_evar sigma ct in
-  let n, c, abstracted_away = pf_abs_evars gl t in
-  List.fold_left Evd.remove sigma abstracted_away, pf_abs_cterm gl n c
+  let n, c, abstracted_away, ucst = pf_abs_evars gl t in
+  List.fold_left Evd.remove sigma abstracted_away, pf_abs_cterm gl n c, ucst, n
 
 let pf_interp_ty ?(resolve_typeclasses=false) ist gl ty =
    let n_binders = ref 0 in
@@ -3251,10 +3329,10 @@
      else
        let sigma = Typeclasses.resolve_typeclasses ~fail:false env sigma in
        sigma, Evarutil.nf_evar sigma cty in
-   let n, c, _ = pf_abs_evars gl ty in
+   let n, c, _, ucst = pf_abs_evars gl ty in
    let lam_c = pf_abs_cterm gl n c in
    let ctx, c = decompose_lam_n n lam_c in
-   n, compose_prod ctx c, lam_c
+   n, compose_prod ctx c, lam_c, ucst
 ;;
 
 let whd_app f args = Reductionops.whd_betaiota Evd.empty (mkApp (f, args))
@@ -3267,7 +3345,8 @@
 let pp_concat hd ?(sep=str", ") = function [] -> hd | x :: xs ->
   hd ++ List.fold_left (fun acc x -> acc ++ sep ++ x) x xs
 
-let fake_pmatcher_end () = mkProp, L2R, (Evd.empty, mkProp)
+let fake_pmatcher_end () =
+  mkProp, L2R, (Evd.empty, Evd.empty_evar_universe_context, mkProp)
 
 (* TASSI: given (c : ty), generates (c ??? : ty[???/...]) with m evars *)
 exception NotEnoughProducts
@@ -3282,7 +3361,7 @@
   else match kind_of_type ty with
   | ProdType (_, src, tgt) ->
       let sigma, x =
-        Evarutil.new_evar (create_evar_defs sigma) env
+        Evarutil.new_evar env (create_evar_defs sigma)
           (if bi_types then Reductionops.nf_betaiota sigma src else src) in
       loop (subst1 x tgt) ((m - n,x) :: args) sigma (n-1)
   | CastType (t, _) -> loop t args sigma n 
@@ -3294,7 +3373,7 @@
         (Reductionops.whd_betadeltaiota env sigma) ty in
       match kind_of_type ty with
       | ProdType _ -> loop ty args sigma n
-      | _ -> anomaly "saturate did not find enough products"
+      | _ -> raise NotEnoughProducts
   in
    loop ty [] sigma m
 
@@ -3333,22 +3412,24 @@
 let pf_interp_gen_aux ist gl to_ind ((oclr, occ), t) =
   let pat = interp_cpattern ist gl t None in (* UGLY API *)
   let cl, env, sigma = pf_concl gl, pf_env gl, project gl in
-  let c = redex_of_pattern env pat in
-  let c, cl = 
+  let (c, ucst), cl = 
     try fill_occ_pattern ~raise_NoMatch:true env sigma cl pat occ 1
-    with NoMatch -> c, cl in
+    with NoMatch -> redex_of_pattern env pat, cl in
   let clr = interp_clr (oclr, (tag_of_cpattern t, c)) in
   if not(occur_existential c) then
     if tag_of_cpattern t = '@' then 
-      if not (isVar c) then errorstrm (str "@ can be used with variables only")
+      if not (isVar c) then
+	errorstrm (str "@ can be used with variables only")
       else match pf_get_hyp gl (destVar c) with
       | _, None, _ -> errorstrm (str "@ can be used with let-ins only")
-      | name, Some bo, ty -> true, pat, mkLetIn (Name name, bo, ty, cl), c, clr
-    else false, pat, pf_mkprod gl c cl, c, clr
+      | name, Some bo, ty -> true, pat, mkLetIn (Name name,bo,ty,cl),c,clr,ucst,gl
+    else let gl, ccl =  pf_mkprod gl c cl in false, pat, ccl, c, clr,ucst,gl
   else if to_ind && occ = None then
-    let nv, p, _ = pf_abs_evars gl (fst pat, c) in
+    let nv, p, _, ucst' = pf_abs_evars gl (fst pat, c) in
+    let ucst = Evd.union_evar_universe_context ucst ucst' in
     if nv = 0 then anomaly "occur_existential but no evars" else
-    false, pat, mkProd (constr_name c, pf_type_of gl p, pf_concl gl), p, clr
+    let gl,pty = pf_type_of gl p in
+    false, pat, mkProd (constr_name c, pty, pf_concl gl), p, clr,ucst, gl
   else loc_error (loc_of_cpattern t) "generalized term didn't match"
 
 let genclrtac cl cs clr =
@@ -3359,23 +3440,28 @@
    * the one of clear.  You type "move: x" and you get
    * "x is used in hyp H" instead of
    * "The term H has type T x but is expected to have type T x0". *)
-  tclTHEN 
+  tclTHEN
     (tclmyORELSE
       (apply_type cl cs)
       (fun type_err gl ->
          tclTHEN
-           (tclTHEN (elim_type (build_coq_False ())) (cleartac clr))
+           (tclTHEN (Proofview.V82.of_tactic (elim_type (build_coq_False ()))) (cleartac clr))
            (fun gl -> raise type_err)
            gl))
     (cleartac clr)
 
 let gentac ist gen gl =
-  let conv, _, cl, c, clr = pf_interp_gen_aux ist gl false gen in
-  if conv then tclTHEN (convert_concl cl) (cleartac clr) gl
+(*   pp(lazy(str"sigma@gentac=" ++ pr_evar_map None (project gl))); *)
+  let conv, _, cl, c, clr, ucst,gl = pf_interp_gen_aux ist gl false gen in
+  pp(lazy(str"c@gentac=" ++ pr_constr c));
+  let gl = pf_merge_uc ucst gl in
+  if conv
+  then tclTHEN (Proofview.V82.of_tactic (convert_concl cl)) (cleartac clr) gl
   else genclrtac cl [c] clr gl
 
 let pf_interp_gen ist gl to_ind gen =
-  let _, _, a, b ,c = pf_interp_gen_aux ist gl to_ind gen in a, b ,c
+  let _, _, a, b, c, ucst,gl = pf_interp_gen_aux ist gl to_ind gen in
+  a, b ,c, pf_merge_uc ucst gl
 
 (** Generalization (discharge) sequence *)
 
@@ -3408,7 +3494,7 @@
 
 let cons_dep (gensl, clr) =
   if List.length gensl = 1 then ([] :: gensl, clr) else
-  error "multiple dependents switches '/'"
+  Errors.error "multiple dependents switches '/'"
 
 ARGUMENT EXTEND ssrdgens_tl TYPED AS ssrgen list list * ssrclear
                             PRINTED BY pr_ssrdgens
@@ -3451,6 +3537,11 @@
   | [gen :: gens] -> tclTHEN (genstac (gens, clr) ist) (maintac [] gen ist)
   | _ -> with_defective maintac [] clr ist
 
+let first_goal gls =
+  let gl = gls.Evd.it and sig_0 = gls.Evd.sigma in
+  if List.is_empty gl then Errors.error "first_goal";
+  { Evd.it = List.hd gl; Evd.sigma = sig_0; }
+
 let with_deps deps0 maintac cl0 cs0 clr0 ist gl0 =
   let rec loop gl cl cs clr args clrs = function
   | [] ->
@@ -3458,7 +3549,7 @@
     maintac (if n > 0 then applist (to_lambda n cl, args) else cl) clrs ist gl0
   | dep :: deps ->
     let gl' = first_goal (genclrtac cl cs clr gl) in
-    let cl', c', clr' = pf_interp_gen ist gl' false dep in
+    let cl', c', clr',gl' = pf_interp_gen ist gl' false dep in
     loop gl' cl' [c'] clr' (c' :: args) (clr' :: clrs) deps in
   loop gl0 cl0 cs0 clr0 cs0 [clr0] (List.rev deps0)
 
@@ -3474,7 +3565,7 @@
 (* We must use primitive parsing here to avoid conflicts with the  *)
 (* basic move, case, and elim tactics.                             *)
 ARGUMENT EXTEND ssreqid TYPED AS ssripatrep option PRINTED BY pr_ssreqid
-| [ "Qed" ] -> [ Util.anomaly "Grammar placeholder match" ]
+| [ "YouShouldNotTypeThis" ] -> [ anomaly "Grammar placeholder match" ]
 END
 
 let accept_ssreqid strm =
@@ -3495,10 +3586,10 @@
     | "?" -> IpatAnon
     | occ = ssrdocc; "->" -> (match occ with
       | None, occ -> IpatRw (occ, L2R)
-      | _ -> loc_error loc "Only occurrences are allowed here")
+      | _ -> loc_error !@loc "Only occurrences are allowed here")
     | occ = ssrdocc; "<-" -> (match occ with
       | None, occ ->  IpatRw (occ, R2L)
-      | _ -> loc_error loc "Only occurrences are allowed here")
+      | _ -> loc_error !@loc "Only occurrences are allowed here")
     | "->" -> IpatRw (allocc, L2R)
     | "<-" -> IpatRw (allocc, R2L)
     ]];
@@ -3510,30 +3601,37 @@
 
 (* creation *)
 
-let mkEq dir cl c t n =
+let mkEq dir cl c t n gl =
   let eqargs = [|t; c; c|] in eqargs.(dir_org dir) <- mkRel n;
-  mkArrow (mkApp (build_coq_eq(), eqargs)) (lift 1 cl), mkRefl t c
+  let eq, gl = pf_fresh_global (build_coq_eq()) gl in 
+  let refl, gl = mkRefl t c gl in
+  mkArrow (mkApp (eq, eqargs)) (lift 1 cl), refl, gl
 
-let pushmoveeqtac cl c =
+let pushmoveeqtac cl c gl =
   let x, t, cl1 = destProd cl in
-  let cl2, eqc = mkEq R2L cl1 c t 1 in
-  apply_type (mkProd (x, t, cl2)) [c; eqc]
+  let cl2, eqc, gl = mkEq R2L cl1 c t 1 gl in
+  apply_type (mkProd (x, t, cl2)) [c; eqc] gl
 
 let pushcaseeqtac cl gl =
   let cl1, args = destApplication cl in
   let n = Array.length args in
   let dc, cl2 = decompose_lam_n n cl1 in
   let _, t = List.nth dc (n - 1) in
-  let cl3, eqc = mkEq R2L cl2 args.(0) t n in
-  let cl4 = mkApp (compose_lam dc (mkProt (pf_type_of gl cl) cl3), args) in
-  tclTHEN (apply_type cl4 [eqc]) (convert_concl cl4) gl
+  let cl3, eqc, gl = mkEq R2L cl2 args.(0) t n gl in
+  let gl, clty = pf_type_of gl cl in
+  let prot, gl = mkProt clty cl3 gl in
+  let cl4 = mkApp (compose_lam dc prot, args) in
+  let gl, _ = pf_e_type_of gl cl4 in
+  tclTHEN (apply_type cl4 [eqc])
+    (Proofview.V82.of_tactic (convert_concl cl4)) gl
 
 let pushelimeqtac gl =
   let _, args = destApplication (pf_concl gl) in
   let x, t, _ = destLambda args.(1) in
   let cl1 = mkApp (args.(1), Array.sub args 2 (Array.length args - 2)) in
-  let cl2, eqc = mkEq L2R cl1 args.(2) t 1 in
-  tclTHEN (apply_type (mkProd (x, t, cl2)) [args.(2); eqc]) intro gl
+  let cl2, eqc, gl = mkEq L2R cl1 args.(2) t 1 gl in
+  tclTHEN (apply_type (mkProd (x, t, cl2)) [args.(2); eqc])
+    (Proofview.V82.of_tactic intro) gl
 
 (** Bookkeeping (discharge-intro) argument *)
 
@@ -3566,10 +3664,10 @@
 
 (* We just add a numeric version that clears the n top assumptions. *)
 
-let poptac ?ist n = introstac ?ist (list_tabulate (fun _ -> IpatWild) n)
+let poptac ist n = introstac ~ist (List.init n (fun _ -> IpatWild))
 
 TACTIC EXTEND ssrclear
-  | [ "clear" natural(n) ltacctx(ctx) ] -> [poptac ~ist:(get_ltacctx ctx) n]
+  | [ "clear" natural(n) ] -> [ Proofview.V82.tactic (poptac ist n) ]
 END
 
 (** The "move" tactic *)
@@ -3581,13 +3679,13 @@
 
 let check_movearg = function
   | view, (eqid, _) when view <> [] && eqid <> None ->
-    Util.error "incompatible view and equation in move tactic"
+    Errors.error "incompatible view and equation in move tactic"
   | view, (_, (([gen :: _], _), _)) when view <> [] && has_occ gen ->
-    Util.error "incompatible view and occurrence switch in move tactic"
+    Errors.error "incompatible view and occurrence switch in move tactic"
   | _, (_, ((dgens, _), _)) when List.length dgens > 1 ->
-    Util.error "dependents switch `/' in move tactic"
-  | _, (eqid, (_, (ipats, _))) when eqid <> None && improper_intros ipats ->
-    Util.error "no proper intro pattern for equation in move tactic"
+    Errors.error "dependents switch `/' in move tactic"
+  | _, (eqid, (_, ipats)) when eqid <> None && improper_intros ipats ->
+    Errors.error "no proper intro pattern for equation in move tactic"
   | arg -> arg
 
 ARGUMENT EXTEND ssrmovearg TYPED AS ssrarg PRINTED BY pr_ssrarg
@@ -3595,10 +3693,12 @@
 END
 
 let viewmovetac_aux clear name_ref (_, vl as v) _ gen ist gl =
-  let cl, c, clr = pf_interp_gen ist gl false gen in
-  let cl, c = if vl = [] then cl, c else pf_with_view ist gl v cl c in
+  let cl, c, clr, gl, gen_pat =
+    let _, gen_pat, a, b, c, ucst,gl = pf_interp_gen_aux ist gl false gen in
+    a, b ,c, pf_merge_uc ucst gl, gen_pat in
+  let cl, c, gl = if vl = [] then cl, c, gl else pf_with_view ist gl v cl c in
   let clr = if clear then clr else [] in
-  name_ref := (match id_of_cpattern (snd gen) with Some id -> id | _ -> top_id);
+  name_ref := (match id_of_pattern gen_pat with Some id -> id | _ -> top_id);
   genclrtac cl [c] clr gl
 
 let () = move_top_with_view := 
@@ -3608,36 +3708,32 @@
   viewmovetac_aux true (ref top_id) v deps gen ist gl
 
 let eqmovetac _ gen ist gl =
-  let cl, c, _ = pf_interp_gen ist gl false gen in pushmoveeqtac cl c gl
+  let cl, c, _, gl = pf_interp_gen ist gl false gen in pushmoveeqtac cl c gl
 
 let movehnftac gl = match kind_of_term (pf_concl gl) with
   | Prod _ | LetIn _ -> tclIDTAC gl
   | _ -> hnf_in_concl gl
 
 let ssrmovetac ist = function
-  | _::_ as view, (_, (dgens, (ipats, _))) ->
+  | _::_ as view, (_, (dgens, ipats)) ->
     let dgentac = with_dgens dgens (viewmovetac (true, view)) ist in
     tclTHEN dgentac (introstac ~ist ipats)
-  | _, (Some pat, (dgens, (ipats, _))) ->
+  | _, (Some pat, (dgens, ipats)) ->
     let dgentac = with_dgens dgens eqmovetac ist in
     tclTHEN dgentac (introstac ~ist (eqmoveipats pat ipats))
-  | _, (_, (([gens], clr), (ipats, _))) ->
+  | _, (_, (([gens], clr), ipats)) ->
     let gentac = genstac (gens, clr) ist in
     tclTHEN gentac (introstac ~ist ipats)
-  | _, (_, ((_, clr), (ipats, _))) ->
+  | _, (_, ((_, clr), ipats)) ->
     tclTHENLIST [movehnftac; cleartac clr; introstac ~ist ipats]
 
-let ist_of_arg  (_, (_, (_, (_, ctx)))) = get_ltacctx ctx
-
 TACTIC EXTEND ssrmove
 | [ "move" ssrmovearg(arg) ssrrpat(pat) ] ->
-  [ let ist = ist_of_arg arg in
-    tclTHEN (ssrmovetac ist arg) (introstac ~ist [pat]) ]
+  [ Proofview.V82.tactic (tclTHEN (ssrmovetac ist arg) (introstac ~ist [pat])) ]
 | [ "move" ssrmovearg(arg) ssrclauses(clauses) ] ->
-  [ let ist = ist_of_arg arg in tclCLAUSES ist (ssrmovetac ist arg) clauses ]
-| [ "move" ssrrpat(pat) ltacctx(ctx) ] ->
-  [ introstac ~ist:(get_ltacctx ctx) [pat] ]
-| [ "move" ] -> [ movehnftac ]
+  [ Proofview.V82.tactic (tclCLAUSES ist (ssrmovetac ist arg) clauses) ]
+| [ "move" ssrrpat(pat) ] -> [ Proofview.V82.tactic (introstac ~ist [pat]) ]
+| [ "move" ] -> [ Proofview.V82.tactic (movehnftac) ]
 END
 
 (* TASSI: given the type of an elimination principle, it finds the higher order
@@ -3653,7 +3749,7 @@
   | _ ->
     let env' = Environ.push_rel_context ctx env in
     let t' = Reductionops.whd_betadeltaiota env' sigma t in
-    if not (eq_constr t t') then loop ctx t' else
+    if not (Term.eq_constr t t') then loop ctx t' else
       errorstrm (str"The eliminator has the wrong shape."++spc()++
       str"A (applied) bound variable was expected as the conclusion of "++
       str"the eliminator's"++Pp.cut()++str"type:"++spc()++pr_constr elimty) in
@@ -3668,7 +3764,7 @@
        in
        occur_rec n term; !count in
      let occurr2 n t = count_occurn n t > 1 in
-     not (list_for_all_i 
+     not (List.for_all_i 
        (fun i (_,rd) -> pred_id <= i || not (occurr2 (pred_id - i) rd))
        1 (assums_of_rel_context ctx))
   in
@@ -3678,7 +3774,8 @@
  * since we don't want to wipe out let-ins, and it seems there is no flag
  * to change that behaviour in the standard unfold code *)
 let unprotecttac gl =
-  let prot = destConst (mkSsrConst "protect_term") in
+  let c, gl = pf_mkSsrConst "protect_term" gl in
+  let prot, _ = destConst c in
   onClause (fun idopt ->
     let hyploc = Option.map (fun id -> id, InHyp) idopt in
     reduct_option 
@@ -3690,7 +3787,7 @@
     allHypsAndConcl gl
 
 let dependent_apply_error =
-  try Util.error "Could not fill dependent hole in \"apply\"" with err -> err
+  try Errors.error "Could not fill dependent hole in \"apply\"" with err -> err
 
 (* TASSI: Sometimes Coq's apply fails. According to my experience it may be
  * related to goals that are products and with beta redexes. In that case it
@@ -3702,14 +3799,20 @@
  *
  * Refiner.refiner that does not handle metas with a non ground type but works
  * with dependently typed higher order metas. *)
-let applyn ~with_evars ?beta n t gl =
+let applyn ~with_evars ?beta ?(with_shelve=false) n t gl =
   if with_evars then
-    let t, ty, args, gl = pf_saturate ?beta ~bi_types:true gl t n in
-    let gl = pf_unify_HO gl ty (pf_concl gl) in
-    let gs = list_map_filter (fun (_, e) ->
-      if isEvar (pf_nf_evar gl e) then Some e else None)
-      args in
-    pf_partial_solution gl t gs
+    let refine gl =
+      let t, ty, args, gl = pf_saturate ?beta ~bi_types:true gl t n in
+(*       pp(lazy(str"sigma@saturate=" ++ pr_evar_map None (project gl))); *)
+      let gl = pf_unify_HO gl ty (pf_concl gl) in
+      let gs = CList.map_filter (fun (_, e) ->
+        if isEvar (pf_nf_evar gl e) then Some e else None)
+        args in
+      pf_partial_solution gl t gs
+    in
+    Proofview.(V82.of_tactic
+      (tclTHEN (V82.tactic refine)
+        (if with_shelve then shelve_unifiable else tclUNIT ()))) gl
   else
     let t, gl = if n = 0 then t, gl else
       let sigma, si = project gl, sig_it gl in
@@ -3723,19 +3826,26 @@
           | _ -> assert false
       in loop sigma t [] n in
     pp(lazy(str"Refiner.refiner " ++ pr_constr t));
-    Refiner.refiner (Proof_type.Prim (Proof_type.Refine t)) gl
+    Refiner.refiner (Proof_type.Refine t) gl
 
 let refine_with ?(first_goes_last=false) ?beta ?(with_evars=true) oc gl =
   let rec mkRels = function 1 -> [] | n -> mkRel n :: mkRels (n-1) in
+  let uct = Evd.evar_universe_context (fst oc) in
   let n, oc = pf_abs_evars_pirrel gl oc in
+  let gl = pf_unsafe_merge_uc uct gl in
   let oc = if not first_goes_last || n <= 1 then oc else
     let l, c = decompose_lam oc in
-    if not (list_for_all_i (fun i (_,t) -> closedn ~-i t) (1-n) l) then oc else
-    compose_lam (let xs,y = list_chop (n-1) l in y @ xs) 
+    if not (List.for_all_i (fun i (_,t) -> closedn ~-i t) (1-n) l) then oc else
+    compose_lam (let xs,y = List.chop (n-1) l in y @ xs) 
       (mkApp (compose_lam l c, Array.of_list (mkRel 1 :: mkRels n)))
   in
   pp(lazy(str"after: " ++ pr_constr oc));
-  try applyn ~with_evars ?beta n oc gl with _ -> raise dependent_apply_error
+  try applyn ~with_evars ~with_shelve:true ?beta n oc gl with _ -> raise dependent_apply_error
+
+let pf_fresh_inductive_instance ind gl =
+  let sigma, env, it = project gl, pf_env gl, sig_it gl in
+  let sigma, indu = Evd.fresh_inductive_instance env sigma ind in
+  indu, re_sig it sigma
 
 (** The "case" and "elim" tactic *)
 
@@ -3757,24 +3867,27 @@
  *    by eqid *)
 let ssrelim ?(is_case=false) ?ist deps what ?elim eqid ipats gl =
   (* some sanity checks *)
-  let oc, orig_clr, occ, c_gen = match what with
-  | `EConstr(_,_,t) when isEvar t -> anomaly "elim called on a constr evar"
-  | `EGen _ when ist = None -> anomaly "no ist and non simple elimination"
+  let oc, orig_clr, occ, c_gen, gl = match what with
+  | `EConstr(_,_,t) when isEvar t ->
+    anomaly "elim called on a constr evar"
+  | `EGen _ when ist = None ->
+    anomaly "no ist and non simple elimination"
   | `EGen (_, g) when elim = None && is_wildcard g ->
        errorstrm(str"Indeterminate pattern and no eliminator")
   | `EGen ((Some clr,occ), g) when is_wildcard g ->
-       None, clr, occ, None
-  | `EGen ((None, occ), g) when is_wildcard g -> None,[],occ,None
+       None, clr, occ, None, gl
+  | `EGen ((None, occ), g) when is_wildcard g -> None,[],occ,None,gl
   | `EGen ((_, occ), p as gen) ->
-       let _, c, clr = pf_interp_gen (Option.get ist) gl true gen in
-       Some c, clr, occ, Some p
-  | `EConstr (clr, occ, c) -> Some c, clr, occ, None in
+       let _, c, clr,gl = pf_interp_gen (Option.get ist) gl true gen in
+       Some c, clr, occ, Some p,gl
+  | `EConstr (clr, occ, c) -> Some c, clr, occ, None,gl in
   let orig_gl, concl, env = gl, pf_concl gl, pf_env gl in
   pp(lazy(str(if is_case then "==CASE==" else "==ELIM==")));
   (* Utils of local interest only *)
   let iD s ?t gl = let t = match t with None -> pf_concl gl | Some x -> x in
     pp(lazy(str s ++ pr_constr t)); tclIDTAC gl in
-  let eq, protectC = build_coq_eq (), mkSsrConst "protect_term" in
+  let eq, gl = pf_fresh_global (build_coq_eq ()) gl in
+  let protectC, gl = pf_mkSsrConst "protect_term" gl in
   let fire_subst gl t = Reductionops.nf_evar (project gl) t in
   let fire_sigma sigma t = Reductionops.nf_evar sigma t in
   let is_undef_pat = function
@@ -3783,40 +3896,59 @@
   | _ -> false in
   let match_pat env p occ h cl = 
     let sigma0 = project orig_gl in
-    pp(lazy(str"matching: " ++ pp_pattern p));
-    let c, cl = fill_occ_pattern ~raise_NoMatch:true env sigma0 cl p occ h in
+    pp(lazy(str"matching: " ++ pr_occ occ ++ pp_pattern p));
+    let (c,ucst), cl =
+      fill_occ_pattern ~raise_NoMatch:true env sigma0 cl p occ h in
     pp(lazy(str"     got: " ++ pr_constr c));
-    c, cl in
+    c, cl, ucst in
   let mkTpat gl t = (* takes a term, refreshes it and makes a T pattern *)
-    let n, t, _ = pf_abs_evars orig_gl (project gl, fire_subst gl t) in 
+    let n, t, _, ucst = pf_abs_evars orig_gl (project gl, fire_subst gl t) in 
     let t, _, _, sigma = saturate ~beta:true env (project gl) t n in
-    sigma, T t in
+    Evd.merge_universe_context sigma ucst, T t in
   let unif_redex gl (sigma, r as p) t = (* t is a hint for the redex of p *)
-    let n, t, _ = pf_abs_evars orig_gl (project gl, fire_subst gl t) in 
+    let n, t, _, ucst = pf_abs_evars orig_gl (project gl, fire_subst gl t) in 
     let t, _, _, sigma = saturate ~beta:true env sigma t n in
+    let sigma = Evd.merge_universe_context sigma ucst in
     match r with
     | X_In_T (e, p) -> sigma, E_As_X_In_T (t, e, p)
-    | _ -> try unify_HO env sigma t (redex_of_pattern env p), r with _ -> p in
+    | _ ->
+       try unify_HO env sigma t (fst (redex_of_pattern env p)), r
+       with e when Errors.noncritical e -> p in
   (* finds the eliminator applies it to evars and c saturated as needed  *)
   (* obtaining "elim ??? (c ???)". pred is the higher order evar         *)
+  (* cty is None when the user writes _ (hence we can't make a pattern *)
   let cty, elim, elimty, elim_args, n_elim_args, elim_is_dep, is_rec, pred, gl =
     match elim with
     | Some elim ->
-      let elimty = pf_type_of gl elim in
+      let gl, elimty = pf_e_type_of gl elim in
       let pred_id, n_elim_args, is_rec, elim_is_dep, n_pred_args =
         analyze_eliminator elimty env (project gl) in
       let elim, elimty, elim_args, gl =
         pf_saturate ~beta:is_case gl elim ~ty:elimty n_elim_args in
       let pred = List.assoc pred_id elim_args in
       let elimty = Reductionops.whd_betadeltaiota env (project gl) elimty in
-      None, elim, elimty, elim_args, n_elim_args, elim_is_dep, is_rec, pred, gl
+      let cty, gl =
+        if Option.is_empty oc then None, gl
+        else
+          let c = Option.get oc in let gl, c_ty = pf_type_of gl c in
+          let pc = match c_gen with
+            | Some p -> interp_cpattern (Option.get ist) orig_gl p None 
+            | _ -> mkTpat gl c in
+          Some(c, c_ty, pc), gl in
+      cty, elim, elimty, elim_args, n_elim_args, elim_is_dep, is_rec, pred, gl
     | None ->
-      let c = Option.get oc in let c_ty = pf_type_of gl c in
-      let (kn, i) as ind, unfolded_c_ty = pf_reduce_to_quantified_ind gl c_ty in
+      let c = Option.get oc in let gl, c_ty = pf_type_of gl c in
+      let ((kn, i) as ind, _ as indu), unfolded_c_ty =
+        pf_reduce_to_quantified_ind gl c_ty in
       let sort = elimination_sort_of_goal gl in
-      let elim = if not is_case then Indrec.lookup_eliminator ind sort
-        else pf_apply Indrec.build_case_analysis_scheme gl ind true sort in
-      let elimty = pf_type_of gl elim in
+      let gl, elim =
+        if not is_case then
+          let t, gl = pf_fresh_global (Indrec.lookup_eliminator ind sort) gl in
+          gl, t
+        else
+          pf_eapply (fun env sigma ->
+            Indrec.build_case_analysis_scheme env sigma indu true) gl sort in
+      let gl, elimty = pf_type_of gl elim in
       let pred_id,n_elim_args,is_rec,elim_is_dep,n_pred_args =
         analyze_eliminator elimty env (project gl) in
       let rctx = fst (decompose_prod_assum unfolded_c_ty) in
@@ -3833,7 +3965,7 @@
       cty, elim, elimty, elim_args, n_elim_args, elim_is_dep, is_rec, pred, gl
   in
   pp(lazy(str"elim= "++ pr_constr_pat elim));
-  pp(lazy(str"elimty= "++ pr_constr elimty));
+  pp(lazy(str"elimty= "++ pr_constr_pat elimty));
   let inf_deps_r = match kind_of_type elimty with
     | AtomicType (_, args) -> List.rev (Array.to_list args)
     | _ -> assert false in
@@ -3842,14 +3974,20 @@
       let c, c_ty, _, gl = pf_saturate gl c ~ty:c_ty n in
       let gl' = f c c_ty gl in
       Some (c, c_ty, gl, gl')
-    with NotEnoughProducts -> None | _ -> loop (n+1) in loop 0 in
-  let elim_is_dep, gl = match cty with
-    | None -> true, gl
+    with
+    | NotEnoughProducts -> None
+    | e when Errors.noncritical e -> loop (n+1) in loop 0 in
+  (* Here we try to understand if the main pattern/term the user gave is
+   * the first pattern to be matched (i.e. if elimty ends in P t1 .. tn,
+   * weather tn is the t the user wrote in 'elim: t' *)
+  let c_is_head_p, gl = match cty with
+    | None -> true, gl  (* The user wrote elim: _ *)
     | Some (c, c_ty, _) ->
     let res = 
+      (* we try to see if c unifies with the last arg of elim *)
       if elim_is_dep then None else
       let arg = List.assoc (n_elim_args - 1) elim_args in
-      let arg_ty = pf_type_of gl arg in
+      let gl, arg_ty = pf_type_of gl arg in
       match saturate_until gl c c_ty (fun c c_ty gl ->
         pf_unify_HO (pf_unify_HO gl c_ty arg_ty) arg c) with
       | Some (c, _, _, gl) -> Some (false, gl)
@@ -3857,20 +3995,22 @@
     match res with
     | Some x -> x
     | None ->
+      (* we try to see if c unifies with the last inferred pattern *)
       let inf_arg = List.hd inf_deps_r in
-      let inf_arg_ty = pf_type_of gl inf_arg in
+      let gl, inf_arg_ty = pf_type_of gl inf_arg in
       match saturate_until gl c c_ty (fun _ c_ty gl ->
               pf_unify_HO gl c_ty inf_arg_ty) with
       | Some (c, _, _,gl) -> true, gl
-      | None -> errorstrm (str"Unable to apply the eliminator to the term"++
-      spc()++pr_constr c++spc()++str"or to unify it's type with"++
-      pr_constr inf_arg_ty) in
-  pp(lazy(str"elim_is_dep= " ++ bool elim_is_dep));
-  let predty = pf_type_of gl pred in
+      | None ->
+        errorstrm (str"Unable to apply the eliminator to the term"++
+          spc()++pr_constr c++spc()++str"or to unify it's type with"++
+          pr_constr inf_arg_ty) in
+  pp(lazy(str"c_is_head_p= " ++ bool c_is_head_p));
+  let gl, predty = pf_type_of gl pred in
   (* Patterns for the inductive types indexes to be bound in pred are computed
    * looking at the ones provided by the user and the inferred ones looking at
    * the type of the elimination principle *)
-  let pp_pat (_,p,_,_) = pp_pattern p in
+  let pp_pat (_,p,_,occ) = pr_occ occ ++ pp_pattern p in
   let pp_inf_pat gl (_,_,t,_) = pr_constr_pat (fire_subst gl t) in
   let patterns, clr, gl =
     let rec loop patterns clr i = function
@@ -3879,19 +4019,19 @@
           let ist = match ist with Some x -> x | None -> assert false in
           let p = interp_cpattern ist orig_gl t None in
           let clr_t =
-            interp_clr (oclr,(tag_of_cpattern t,redex_of_pattern env p))in
+            interp_clr (oclr,(tag_of_cpattern t,fst (redex_of_pattern env p)))in
           (* if we are the index for the equation we do not clear *)
           let clr_t = if deps = [] && eqid <> None then [] else clr_t in
           let p = if is_undef_pat p then mkTpat gl inf_t else p in
           loop (patterns @ [i, p, inf_t, occ]) 
             (clr_t @ clr) (i+1) (deps, inf_deps)
       | [], c :: inf_deps -> 
-          pp(lazy(str"adding inferred pattern " ++ pr_constr_pat c));
+          pp(lazy(str"adding inf pattern " ++ pr_constr_pat c));
           loop (patterns @ [i, mkTpat gl c, c, allocc]) 
             clr (i+1) ([], inf_deps)
       | _::_, [] -> errorstrm (str "Too many dependent abstractions") in
-    let deps, head_p, inf_deps_r = match what, elim_is_dep, cty with
-    | `EConstr _, _, None -> anomaly "Simple welim with no term"
+    let deps, head_p, inf_deps_r = match what, c_is_head_p, cty with
+    | `EConstr _, _, None -> anomaly "Simple elim with no term"
     | _, false, _ -> deps, [], inf_deps_r
     | `EGen gen, true, None -> deps @ [gen], [], inf_deps_r
     | _, true, Some (c, _, pc) ->
@@ -3900,7 +4040,7 @@
          deps, [1, pc, inf_p, occ], inf_deps_r in
     let patterns, clr, gl = 
       loop [] orig_clr (List.length head_p+1) (List.rev deps, inf_deps_r) in
-    head_p @ patterns, Util.list_uniquize clr, gl
+    head_p @ patterns, Util.List.uniquize clr, gl
   in
   pp(lazy(pp_concat (str"patterns=") (List.map pp_pat patterns)));
   pp(lazy(pp_concat (str"inf. patterns=") (List.map (pp_inf_pat gl) patterns)));
@@ -3916,13 +4056,15 @@
         let () = pp(lazy(str"postponing " ++ pp_pattern p)) in
         cl, gl, post @ [h, p, inf_t, occ]
       else try
-        let c, cl =  match_pat env p occ h cl in
+        let c, cl, ucst = match_pat env p occ h cl in
+        let gl = pf_merge_uc ucst gl in
         let gl = try pf_unify_HO gl inf_t c with _ -> error gl c inf_t in
         cl, gl, post
       with 
       | NoMatch | NoProgress ->
-          let e = redex_of_pattern env p in
-          let n, e, _ =  pf_abs_evars gl (fst p, e) in
+          let e, ucst = redex_of_pattern env p in
+          let gl = pf_merge_uc ucst gl in
+          let n, e, _, _ucst =  pf_abs_evars gl (fst p, e) in
           let e, _, _, gl = pf_saturate ~beta:true gl e n in 
           let gl = try pf_unify_HO gl inf_t e with _ -> error gl e inf_t in
           cl, gl, post
@@ -3937,41 +4079,48 @@
       else match_all concl gl postponed in
     let concl, gl = match_all concl gl patterns in
     let pred_rctx, _ = decompose_prod_assum (fire_subst gl predty) in
-    let concl, gen_eq_tac, clr = match eqid with 
+    let concl, gen_eq_tac, clr, gl = match eqid with 
     | Some (IpatId _) when not is_rec -> 
         let k = List.length deps in
         let c = fire_subst gl (List.assoc (n_elim_args - k - 1) elim_args) in
-        let t = pf_type_of gl c in
-        let gen_eq_tac =
+        let gl, t = pf_type_of gl c in
+        let gen_eq_tac, gl =
           let refl = mkApp (eq, [|t; c; c|]) in
           let new_concl = mkArrow refl (lift 1 (pf_concl orig_gl)) in 
           let new_concl = fire_subst gl new_concl in
-          let erefl = fire_subst gl (mkRefl t c) in
-          apply_type new_concl [erefl] in
-        let rel = k + if elim_is_dep then 1 else 0 in
-        let src = mkProt mkProp (mkApp (eq,[|t; c; mkRel rel|])) in
+          let erefl, gl = mkRefl t c gl in
+          let erefl = fire_subst gl erefl in
+          apply_type new_concl [erefl], gl in
+        let rel = k + if c_is_head_p then 1 else 0 in
+        let src, gl = mkProt mkProp (mkApp (eq,[|t; c; mkRel rel|])) gl in
         let concl = mkArrow src (lift 1 concl) in
         let clr = if deps <> [] then clr else [] in
-        concl, gen_eq_tac, clr
-    | _ -> concl, tclIDTAC, clr in
+        concl, gen_eq_tac, clr, gl
+    | _ -> concl, tclIDTAC, clr, gl in
     let mk_lam t r = mkLambda_or_LetIn r t in
     let concl = List.fold_left mk_lam concl pred_rctx in
-    let concl = 
-      if eqid <> None && is_rec then mkProt (pf_type_of gl concl) concl 
-      else concl in
+    let gl, concl = 
+      if eqid <> None && is_rec then
+        let gl, concls = pf_type_of gl concl in
+        let concl, gl = mkProt concls concl gl in
+        let gl, _ = pf_e_type_of gl concl in
+        gl, concl
+      else gl, concl in
     concl, gen_eq_tac, clr, gl in
+  let gl, pty = pf_e_type_of gl elim_pred in
   pp(lazy(str"elim_pred=" ++ pp_term gl elim_pred));
-  let pty = Typing.type_of env (project gl) elim_pred in
   pp(lazy(str"elim_pred_ty=" ++ pp_term gl pty));
   let gl = pf_unify_HO gl pred elim_pred in
+  let elim = fire_subst gl elim in
+  let gl, _ = pf_e_type_of gl elim in
   (* check that the patterns do not contain non instantiated dependent metas *)
   let () = 
-    let evars_of_term = Evarutil.evars_of_term in
+    let evars_of_term = Evarutil.undefined_evars_of_term (project gl) in
     let patterns = List.map (fun (_,_,t,_) -> fire_subst gl t) patterns in
     let patterns_ev = List.map evars_of_term patterns in 
     let ev = List.fold_left Intset.union Intset.empty patterns_ev in
     let ty_ev = Intset.fold (fun i e ->
-         let ex = Evd.existential_of_int i in  
+         let ex = i in
          let i_ty = Evd.evar_concl (Evd.find (project gl) ex) in
          Intset.union e (evars_of_term i_ty))
       ev Intset.empty in
@@ -3985,7 +4134,7 @@
     end
   in
   (* the elim tactic, with the eliminator and the predicated we computed *)
-  let elim = project gl, fire_subst gl elim in 
+  let elim = project gl, elim in 
   let elim_tac gl = 
     tclTHENLIST [refine_with ~with_evars:false elim; cleartac clr] gl in
   (* handling of following intro patterns and equation introduction if any *)
@@ -3996,7 +4145,7 @@
           let rec intro_eq gl = match kind_of_type (pf_concl gl) with
           | ProdType (_, src, tgt) -> 
              (match kind_of_type src with
-             | AtomicType (hd, _) when eq_constr hd protectC -> 
+             | AtomicType (hd, _) when Term.eq_constr hd protectC -> 
                 tclTHENLIST [unprotecttac; introid ipat] gl
              | _ -> tclTHENLIST [ iD "IA"; introstac [IpatAnon]; intro_eq] gl)
           |_ -> errorstrm (str "Too many names in intro pattern") in
@@ -4015,16 +4164,17 @@
           let concl = pf_concl gl in
           let ctx, last = decompose_prod_assum concl in
           let args = match kind_of_type last with
-          | AtomicType (hd, args) -> assert(eq_constr hd protectC); args
+          | AtomicType (hd, args) -> assert(Term.eq_constr hd protectC); args
           | _ -> assert false in
           let case = args.(Array.length args-1) in
           if not(closed0 case) then tclTHEN (introstac [IpatAnon]) gen_eq_tac gl
           else
-          let case_ty = pf_type_of gl case in 
+          let gl, case_ty = pf_type_of gl case in 
           let refl = mkApp (eq, [|lift 1 case_ty; mkRel 1; lift 1 case|]) in
           let new_concl = fire_subst gl
             (mkProd (Name (name gl), case_ty, mkArrow refl (lift 2 concl))) in 
-          let erefl = fire_subst gl (mkRefl case_ty case) in
+          let erefl, gl = mkRefl case_ty case gl in
+          let erefl = fire_subst gl erefl in
           apply_type new_concl [case;erefl] gl in
         tclTHENLIST [gen_eq_tac; intro_lhs; introid ipat]
       | _ -> tclIDTAC in
@@ -4040,19 +4190,19 @@
 
 let check_casearg = function
 | view, (_, (([_; gen :: _], _), _)) when view <> [] && has_occ gen ->
-  Util.error "incompatible view and occurrence switch in dependent case tactic"
+  Errors.error "incompatible view and occurrence switch in dependent case tactic"
 | arg -> arg
 
 ARGUMENT EXTEND ssrcasearg TYPED AS ssrarg PRINTED BY pr_ssrarg
 | [ ssrarg(arg) ] -> [ check_casearg arg ]
 END
 
-let ssrcasetac ist (view, (eqid, (dgens, (ipats, _)))) =
+let ssrcasetac ist (view, (eqid, (dgens, ipats))) =
   let ndefectcasetac view eqid ipats deps ((_, occ), _ as gen) ist gl =
     let simple = (eqid = None && deps = [] && occ = None) in
-    let cl, c, clr = pf_interp_gen ist gl true gen in
-    let vc =
-      if view = [] then c else snd(pf_with_view ist gl (false, view) cl c) in
+    let cl, c, clr, gl = pf_interp_gen ist gl true gen in
+    let _, vc, gl =
+      if view = [] then c, c, gl else pf_with_view ist gl (false, view) cl c in
     if simple && is_injection_case vc gl then
       tclTHENLIST [perform_injection vc; cleartac clr; introstac ~ist ipats] gl
     else 
@@ -4066,10 +4216,8 @@
 
 TACTIC EXTEND ssrcase
 | [ "case" ssrcasearg(arg) ssrclauses(clauses) ] ->
-  [ let _, (_, (_, (_, ctx))) = arg in
-    let ist = get_ltacctx ctx in
-    tclCLAUSES ist (ssrcasetac ist arg) clauses ]
-| [ "case" ] -> [ with_top ssrscasetac ]
+  [ Proofview.V82.tactic (tclCLAUSES ist (ssrcasetac ist arg) clauses) ]
+| [ "case" ] -> [ Proofview.V82.tactic (with_top ssrscasetac) ]
 END
 
 (** The "elim" tactic *)
@@ -4079,7 +4227,7 @@
 (* goal, the "all occurrences" {+} switch is used, or the equation switch  *)
 (* is used and there are no dependents.                                    *)
 
-let ssrelimtac ist (view, (eqid, (dgens, (ipats, _)))) =
+let ssrelimtac ist (view, (eqid, (dgens, ipats))) =
   let ndefectelimtac view eqid ipats deps gen ist gl =
     let elim = match view with [v] -> Some (snd(force_term ist gl v)) | _ -> None in
     ssrelim ~ist deps (`EGen gen) ?elim eqid ipats gl
@@ -4088,10 +4236,8 @@
 
 TACTIC EXTEND ssrelim
 | [ "elim" ssrarg(arg) ssrclauses(clauses) ] ->
-  [ let _, (_, (_, (_, ctx))) = arg in
-    let ist = get_ltacctx ctx in
-    tclCLAUSES ist (ssrelimtac ist arg) clauses ]
-| [ "elim" ] -> [ with_top simplest_newelim ]
+  [ Proofview.V82.tactic (tclCLAUSES ist (ssrelimtac ist arg) clauses) ]
+| [ "elim" ] -> [ Proofview.V82.tactic (with_top simplest_newelim) ]
 END
 
 (** 6. Backward chaining tactics: apply, exact, congr. *)
@@ -4139,7 +4285,8 @@
 END
 
 let interp_agen ist gl ((goclr, _), (k, gc)) (clr, rcs) =
-  let rc = glob_constr ist (project gl) (pf_env gl) gc in
+(* pp(lazy(str"sigma@interp_agen=" ++ pr_evar_map None (project gl))); *)
+  let rc = glob_constr ist (pf_env gl) gc in
   let rcs' = rc :: rcs in
   match goclr with
   | None -> clr, rcs'
@@ -4148,7 +4295,7 @@
     if k <> ' ' then clr', rcs' else
     match rc with
     | GVar (loc, id) when not_section_id id -> SsrHyp (loc, id) :: clr', rcs'
-    | GRef (loc, VarRef id) when not_section_id id ->
+    | GRef (loc, VarRef id, _) when not_section_id id ->
         SsrHyp (loc, id) :: clr', rcs'
     | _ -> clr', rcs'
 
@@ -4166,15 +4313,17 @@
   | _ -> assert false
 
 let apply_rconstr ?ist t gl =
+(* pp(lazy(str"sigma@apply_rconstr=" ++ pr_evar_map None (project gl))); *)
   let n = match ist, t with
-    | None, (GVar (_, id) | GRef (_, VarRef id)) -> pf_nbargs gl (mkVar id)
+    | None, (GVar (_, id) | GRef (_, VarRef id,_)) -> pf_nbargs gl (mkVar id)
     | Some ist, _ -> interp_nbargs ist gl t
     | _ -> anomaly "apply_rconstr without ist and not RVar" in
   let mkRlemma i = mkRApp t (mkRHoles i) in
   let cl = pf_concl gl in
   let rec loop i =
-    if i > n then errorstrm (str"Cannot apply lemma "++pf_pr_glob_constr gl t)
-    else try pf_match gl (mkRlemma i) cl with _ -> loop (i + 1) in
+    if i > n then
+      errorstrm (str"Cannot apply lemma "++pf_pr_glob_constr gl t)
+    else try pf_match gl (mkRlemma i) (OfType cl) with _ -> loop (i + 1) in
   refine_with (loop 0) gl
 
 let mkRAppView ist gl rv gv =
@@ -4197,7 +4346,7 @@
 
 let apply_top_tac gl =
   tclTHENLIST [introid top_id; apply_rconstr (mkRVar top_id); clear [top_id]] gl
-
+    
 let inner_ssrapplytac gviews ggenl gclr ist gl =
  let _, clr = interp_hyps ist gl gclr in
  let vtac gv i gl' = refine_interp_apply_view i ist gl' gv in
@@ -4214,24 +4363,22 @@
       (List.fold_left (fun acc v -> tclTHENLAST acc (vtac v dbl)) (vtac v 1) tl)
       (cleartac clr) gl
   | [], [agens] ->
-    let clr', (_, lemma) = interp_agens ist gl agens in
+    let clr', (sigma, lemma) = interp_agens ist gl agens in
+    let gl = pf_merge_uc_of sigma gl in
     tclTHENLIST [cleartac clr; refine_with ~beta:true lemma; cleartac clr'] gl
   | _, _ -> tclTHEN apply_top_tac (cleartac clr) gl) gl
 
-let ssrapplytac (views, (_, ((gens, clr), intros))) =
-  tclINTROS (inner_ssrapplytac views gens clr) intros
-
-let prof_ssrapplytac = mk_profiler "ssrapplytac";;
-let ssrapplytac arg gl = prof_ssrapplytac.profile (ssrapplytac arg) gl;;
+let ssrapplytac ist (views, (_, ((gens, clr), intros))) =
+  tclINTROS ist (inner_ssrapplytac views gens clr) intros
 
 TACTIC EXTEND ssrapply
-| [ "apply" ssrapplyarg(arg) ] -> [ ssrapplytac arg ]
-| [ "apply" ] -> [ apply_top_tac ]
+| [ "apply" ssrapplyarg(arg) ] -> [ Proofview.V82.tactic (ssrapplytac ist arg) ]
+| [ "apply" ] -> [ Proofview.V82.tactic apply_top_tac ]
 END
 
 (** The "exact" tactic *)
 
-let mk_exactarg views dgens = mk_applyarg views dgens ([], rawltacctx)
+let mk_exactarg views dgens = mk_applyarg views dgens []
 
 ARGUMENT EXTEND ssrexactarg TYPED AS ssrapplyarg PRINTED BY pr_ssraarg
 | [ ":" ssragen(gen) ssragens(dgens) ] ->
@@ -4245,36 +4392,34 @@
 let vmexacttac pf gl = exact_no_check (mkCast (pf, VMcast, pf_concl gl)) gl
 
 TACTIC EXTEND ssrexact
-| [ "exact" ssrexactarg(arg) ] -> [ tclBY (ssrapplytac arg) ]
-| [ "exact" ] -> [ tclORELSE donetac (tclBY apply_top_tac) ]
-| [ "exact" "<:" lconstr(pf) ] -> [ vmexacttac pf ]
+| [ "exact" ssrexactarg(arg) ] -> [ Proofview.V82.tactic (tclBY (ssrapplytac ist arg)) ]
+| [ "exact" ] -> [ Proofview.V82.tactic (tclORELSE donetac (tclBY apply_top_tac)) ]
+| [ "exact" "<:" lconstr(pf) ] -> [ Proofview.V82.tactic (vmexacttac pf) ]
 END
 
 (** The "congr" tactic *)
 
-type ssrcongrarg = open_constr * (int * constr)
+(* type ssrcongrarg = open_constr * (int * constr) *)
 
-let pr_ssrcongrarg _ _ _ (_, ((n, f), dgens)) =
-  (if n <= 0 then mt () else str " " ++ pr_int n) ++
+let pr_ssrcongrarg _ _ _ ((n, f), dgens) =
+  (if n <= 0 then mt () else str " " ++ int n) ++
   str " " ++ pr_term f ++ pr_dgens pr_gen dgens
 
-ARGUMENT EXTEND ssrcongrarg TYPED AS ltacctx * ((int * ssrterm) * ssrdgens)
+ARGUMENT EXTEND ssrcongrarg TYPED AS (int * ssrterm) * ssrdgens
   PRINTED BY pr_ssrcongrarg
-| [ natural(n) constr(c) ssrdgens(dgens) ] ->
-  [ rawltacctx, ((n, mk_term ' ' c), dgens) ]
-| [ natural(n) constr(c) ] ->
-  [ rawltacctx, ((n, mk_term ' ' c),([[]],[])) ]
-| [ constr(c) ssrdgens(dgens) ] -> [ rawltacctx, ((0, mk_term ' ' c), dgens) ]
-| [ constr(c) ] -> [ rawltacctx, ((0, mk_term ' ' c), ([[]],[])) ]
+| [ natural(n) constr(c) ssrdgens(dgens) ] -> [ (n, mk_term ' ' c), dgens ]
+| [ natural(n) constr(c) ] -> [ (n, mk_term ' ' c),([[]],[]) ]
+| [ constr(c) ssrdgens(dgens) ] -> [ (0, mk_term ' ' c), dgens ]
+| [ constr(c) ] -> [ (0, mk_term ' ' c), ([[]],[]) ]
 END
 
 let rec mkRnat n =
-  if n <= 0 then GRef (dummy_loc, glob_O) else
-  mkRApp (GRef (dummy_loc, glob_S)) [mkRnat (n - 1)]
+  if n <= 0 then GRef (dummy_loc, glob_O, None) else
+  mkRApp (GRef (dummy_loc, glob_S, None)) [mkRnat (n - 1)]
 
 let interp_congrarg_at ist gl n rf ty m =
   pp(lazy(str"===interp_congrarg_at==="));
-  let congrn = mkSsrRRef "nary_congruence" in
+  let congrn, _ = mkSsrRRef "nary_congruence" in
   let args1 = mkRnat n :: mkRHoles n @ [ty] in
   let args2 = mkRHoles (3 * n) in
   let rec loop i =
@@ -4291,14 +4436,17 @@
 let congrtac ((n, t), ty) ist gl =
   pp(lazy(str"===congr==="));
   pp(lazy(str"concl=" ++ pr_constr (pf_concl gl)));
-  let _, f, _ = pf_abs_evars gl (interp_term ist gl t) in
-  let ist' = {ist with lfun = [pattern_id, VConstr ([],f)]} in
+  let sigma, _ as it = interp_term ist gl t in
+  let gl = pf_merge_uc_of sigma gl in
+  let _, f, _, _ucst = pf_abs_evars gl it in
+  let ist' = {ist with lfun =
+    Id.Map.add pattern_id (Value.of_constr f) Id.Map.empty } in
   let rf = mkRltacVar pattern_id in
   let m = pf_nbargs gl f in
   let _, cf = if n > 0 then
     match interp_congrarg_at ist' gl n rf ty m with
     | Some cf -> cf
-    | None -> errorstrm (str "No " ++ pr_int n ++ str "-congruence with "
+    | None -> errorstrm (str "No " ++ int n ++ str "-congruence with "
                          ++ pr_term t)
     else let rec loop i =
       if i > m then errorstrm (str "No congruence with " ++ pr_term t)
@@ -4306,7 +4454,7 @@
       | Some cf -> cf
       | None -> loop (i + 1) in
       loop 1 in
-  tclTHEN (refine_with cf) (tclTRY reflexivity) gl
+  tclTHEN (refine_with cf) (tclTRY (Proofview.V82.of_tactic reflexivity)) gl
 
 let newssrcongrtac arg ist gl =
   pp(lazy(str"===newcongr==="));
@@ -4315,33 +4463,39 @@
   let fs gl t = Reductionops.nf_evar (project gl) t in
   let tclMATCH_GOAL (c, gl_c) proj t_ok t_fail gl =
     match try Some (pf_unify_HO gl_c (pf_concl gl) c) with _ -> None with  
-    | Some gl_c -> tclTHEN (convert_concl (fs gl_c c)) (t_ok (proj gl_c)) gl
+    | Some gl_c ->
+        tclTHEN (Proofview.V82.of_tactic (convert_concl (fs gl_c c)))
+          (t_ok (proj gl_c)) gl
     | None -> t_fail () gl in 
   let mk_evar gl ty = 
     let env, sigma, si = pf_env gl, project gl, sig_it gl in
-    let sigma, x = Evarutil.new_evar (create_evar_defs sigma) env ty in
+    let sigma, x = Evarutil.new_evar env (create_evar_defs sigma) ty in
     x, re_sig si sigma in
-  let ssr_congr lr = mkApp (mkSsrConst "ssr_congr_arrow",lr) in
+  let arr, gl = pf_mkSsrConst "ssr_congr_arrow" gl in
+  let ssr_congr lr = mkApp (arr, lr) in
   (* here thw two cases: simple equality or arrow *)
-  let equality, _, eq_args, gl' = pf_saturate gl (build_coq_eq ()) 3 in
+  let equality, _, eq_args, gl' =
+    let eq, gl = pf_fresh_global (build_coq_eq ()) gl in
+    pf_saturate gl eq 3 in
   tclMATCH_GOAL (equality, gl') (fun gl' -> fs gl' (List.assoc 0 eq_args))
-  (fun ty -> congrtac (arg, Detyping.detype false [] [] ty) ist)
+  (fun ty -> congrtac (arg, Detyping.detype false [] (pf_env gl) (project gl) ty) ist)
   (fun () ->
     let lhs, gl' = mk_evar gl mkProp in let rhs, gl' = mk_evar gl' mkProp in
     let arrow = mkArrow lhs (lift 1 rhs) in
     tclMATCH_GOAL (arrow, gl') (fun gl' -> [|fs gl' lhs;fs gl' rhs|])
-    (fun lr -> tclTHEN (apply (ssr_congr lr)) (congrtac (arg, mkRType) ist))
+    (fun lr -> tclTHEN (Proofview.V82.of_tactic (apply (ssr_congr lr))) (congrtac (arg, mkRType) ist))
     (fun _ _ -> errorstrm (str"Conclusion is not an equality nor an arrow")))
     gl
 ;;
 
 TACTIC EXTEND ssrcongr
 | [ "congr" ssrcongrarg(arg) ] ->
-[ let ctx, (arg, dgens) = arg in
-  let ist = get_ltacctx ctx in
-  match dgens with
-  | [gens], clr -> tclTHEN (genstac (gens,clr) ist) (newssrcongrtac arg ist)
-  | _ -> errorstrm (str"Dependent family abstractions not allowed in congr")]
+[ let arg, dgens = arg in
+  Proofview.V82.tactic begin
+    match dgens with
+    | [gens], clr -> tclTHEN (genstac (gens,clr) ist) (newssrcongrtac arg ist)
+    | _ -> errorstrm (str"Dependent family abstractions not allowed in congr")
+  end]
 END
 
 (** 7. Rewriting tactics (rewrite, unlock) *)
@@ -4367,7 +4521,7 @@
 let nomult = 1, Once
 
 let pr_mult (n, m) =
-  if n > 0 && m <> Once then pr_int n ++ pr_mmod m else pr_mmod m
+  if n > 0 && m <> Once then int n ++ pr_mmod m else pr_mmod m
 
 let pr_ssrmult _ _ _ = pr_mult
 
@@ -4406,8 +4560,7 @@
   | RWdef -> str "/"
   | RWeq -> mt ()
 
-let wit_ssrrwkind, globwit_ssrrwkind, rawwit_ssrrwkind =
-  add_genarg "ssrrwkind" pr_rwkind
+let wit_ssrrwkind = add_genarg "ssrrwkind" pr_rwkind
 
 let pr_rule = function
   | RWred s, _ -> pr_simpl s
@@ -4447,11 +4600,11 @@
                      && (clr = None || clr = Some []) then
      anomaly "Improper rewrite clear switch";
    if d = R2L && rt <> RWdef then
-     error "Right-to-left switch on simplification";
+     Errors.error "Right-to-left switch on simplification";
    if n <> 1 && rt = RWred Cut then
-     error "Bad or useless multiplier";
+     Errors.error "Bad or useless multiplier";
    if occ <> None && rx = None && rt <> RWdef then
-     error "Missing redex for simplification occurrence"
+     Errors.error "Missing redex for simplification occurrence"
  end; (d, m), ((docc, rx), r)
 
 let norwmult = L2R, nomult
@@ -4504,8 +4657,10 @@
 let simplintac occ rdx sim gl = 
   let simptac gl = 
     let sigma0, concl0, env0 = project gl, pf_concl gl, pf_env gl in
-    let simp env c _ = red_safe Tacred.simpl env sigma0 c in
-    convert_concl_no_check (eval_pattern env0 sigma0 concl0 rdx occ simp) gl in
+    let simp env c _ _ = red_safe Tacred.simpl env sigma0 c in
+    Proofview.V82.of_tactic
+      (convert_concl_no_check (eval_pattern env0 sigma0 concl0 rdx occ simp))
+      gl in
   match sim with
   | Simpl -> simptac gl
   | SimplCut -> tclTHEN simptac (tclTRY donetac) gl
@@ -4513,14 +4668,14 @@
 
 let rec get_evalref c =  match kind_of_term c with
   | Var id -> EvalVarRef id
-  | Const k -> EvalConstRef k
+  | Const (k,_) -> EvalConstRef k
   | App (c', _) -> get_evalref c'
   | Cast (c', _, _) -> get_evalref c'
   | _ -> errorstrm (str "The term " ++ pr_constr c ++ str " is not unfoldable")
 
 (* Strip a pattern generated by a prenex implicit to its constant. *)
 let strip_unfold_term ((sigma, t) as p) kt = match kind_of_term t with
-  | App (f, a) when kt = ' ' && array_for_all isEvar a && isConst f -> 
+  | App (f, a) when kt = ' ' && Array.for_all isEvar a && isConst f -> 
     (sigma, f), true
   | Const _ | Var _ -> p, true
   | _ -> p, false
@@ -4529,7 +4684,8 @@
   let fs sigma x = Reductionops.nf_evar sigma x in
   let sigma0, concl0, env0 = project gl, pf_concl gl, pf_env gl in
   let (sigma, t), const = strip_unfold_term t kt in
-  let body env t c = Tacred.unfoldn [(true, [1]), get_evalref t] env sigma0 c in
+  let body env t c =
+    Tacred.unfoldn [OnlyOccurrences [1], get_evalref t] env sigma0 c in
   let easy = occ = None && rdx = None in
   let red_flags = if easy then Closure.betaiotazeta else Closure.betaiota in
   let beta env = Reductionops.clos_norm_flags red_flags env sigma0 in
@@ -4539,25 +4695,25 @@
     let ise, u = mk_tpattern env0 sigma0 (ise,t) all_ok L2R t in
     let find_T, end_T =
       mk_tpattern_matcher ~raise_NoMatch:true sigma0 occ (ise,[u]) in
-    (fun env c h -> 
-      try find_T env c h (fun env c _ -> body env t c)
-      with NoMatch when easy -> c 
+    (fun env c _ h -> 
+      try find_T env c h (fun env c _ _ -> body env t c)
+      with NoMatch when easy -> c
       | NoMatch | NoProgress -> errorstrm (str"No occurrence of "
         ++ pr_constr_pat t ++ spc() ++ str "in " ++ pr_constr c)),
     (fun () -> try end_T () with 
       | NoMatch when easy -> fake_pmatcher_end () 
       | NoMatch -> anomaly "unfoldintac")
   | _ -> 
-    (fun env (c as orig_c) h ->
+    (fun env (c as orig_c) _ h ->
       if const then
           let rec aux c = 
             match kind_of_term c with
-            | Const _ when eq_constr c t -> body env t t
-            | App (f,a) when eq_constr f t -> mkApp (body env f f,a)
+            | Const _ when Term.eq_constr c t -> body env t t
+            | App (f,a) when Term.eq_constr f t -> mkApp (body env f f,a)
             | _ -> let c = Reductionops.whd_betaiotazeta sigma0 c in
             match kind_of_term c with
-            | Const _ when eq_constr c t -> body env t t
-            | App (f,a) when eq_constr f t -> mkApp (body env f f,a)
+            | Const _ when Term.eq_constr c t -> body env t t
+            | App (f,a) when Term.eq_constr f t -> mkApp (body env f f,a)
             | Const f -> aux (body env c c)
             | App (f, a) -> aux (mkApp (body env f f, a))
             | _ -> errorstrm (str "The term "++pr_constr orig_c++
@@ -4572,7 +4728,7 @@
     try beta env0 (eval_pattern env0 sigma0 concl0 rdx occ unfold) 
     with Option.IsNone -> errorstrm (str"Failed to unfold " ++ pr_constr_pat t) in
   let _ = conclude () in
-  convert_concl concl gl
+  Proofview.V82.of_tactic (convert_concl concl) gl
 ;;
 
 let foldtac occ rdx ft gl = 
@@ -4586,21 +4742,21 @@
     let ise, ut = mk_tpattern env0 sigma0 (ise,t) all_ok L2R ut in
     let find_T, end_T =
       mk_tpattern_matcher ~raise_NoMatch:true sigma0 occ (ise,[ut]) in
-    (fun env c h -> try find_T env c h (fun env t _ -> t) with NoMatch -> c),
+    (fun env c _ h -> try find_T env c h (fun env t _ _ -> t) with NoMatch ->c),
     (fun () -> try end_T () with NoMatch -> fake_pmatcher_end ())
   | _ -> 
-    (fun env c h -> try let sigma = unify_HO env sigma c t in fs sigma t
+    (fun env c _ h -> try let sigma = unify_HO env sigma c t in fs sigma t
     with _ -> errorstrm (str "fold pattern " ++ pr_constr_pat t ++ spc ()
       ++ str "does not match redex " ++ pr_constr_pat c)), 
     fake_pmatcher_end in
   let concl = eval_pattern env0 sigma0 concl0 rdx occ fold in
   let _ = conclude () in
-  convert_concl concl gl
+  Proofview.V82.of_tactic (convert_concl concl) gl
 ;;
 
 let converse_dir = function L2R -> R2L | R2L -> L2R
 
-let rw_progress rhs lhs ise = not (eq_constr lhs (Evarutil.nf_evar ise rhs))
+let rw_progress rhs lhs ise = not (Term.eq_constr lhs (Evarutil.nf_evar ise rhs))
 
 (* Coq has a more general form of "equation" (any type with a single *)
 (* constructor with no arguments with_rect_r elimination lemmas).    *)
@@ -4620,25 +4776,26 @@
 exception PRindetermined_rhs of constr
 
 let pirrel_rewrite pred rdx rdx_ty new_rdx dir (sigma, c) c_ty gl =
+(*   pp(lazy(str"sigma@pirrel_rewrite=" ++ pr_evar_map None sigma)); *)
   let env = pf_env gl in
   let beta = Reductionops.clos_norm_flags Closure.beta env sigma in
   let sigma, p = 
     let sigma = create_evar_defs sigma in
-    Evarutil.new_evar sigma env (beta (subst1 new_rdx pred)) in
+    Evarutil.new_evar env sigma (beta (subst1 new_rdx pred)) in
   let pred = mkNamedLambda pattern_id rdx_ty pred in
-  let elim = 
-    let (kn, i) as ind, unfolded_c_ty = pf_reduce_to_quantified_ind gl c_ty in
+  let elim, gl = 
+    let ((kn, i) as ind, _), unfolded_c_ty = pf_reduce_to_quantified_ind gl c_ty in
     let sort = elimination_sort_of_goal gl in
-    let elim = Indrec.lookup_eliminator ind sort in
-    if dir = R2L then elim else (* taken from Coq's rewrite *)
-    let elim = destConst elim in          
+    let elim, gl = pf_fresh_global (Indrec.lookup_eliminator ind sort) gl in
+    if dir = R2L then elim, gl else (* taken from Coq's rewrite *)
+    let elim, _ = destConst elim in          
     let mp,dp,l = repr_con (constant_of_kn (canonical_con elim)) in
     let l' = label_of_id (Nameops.add_suffix (id_of_label l) "_r")  in 
     let c1' = Global.constant_of_delta_kn (canonical_con (make_con mp dp l')) in
-    mkConst c1' in
+    mkConst c1', gl in
   let proof = mkApp (elim, [| rdx_ty; new_rdx; pred; p; rdx; c |]) in
   (* We check the proof is well typed *)
-  let proof_ty =
+  let sigma, proof_ty =
     try Typing.type_of env sigma proof with _ -> raise PRtype_error in
   pp(lazy(str"pirrel_rewrite proof term of type: " ++ pr_constr proof_ty));
   try refine_with 
@@ -4654,8 +4811,8 @@
           match kind_of_type t with
           | ProdType (name, _, t) -> name :: aux t (n-1)
           | _ -> assert false in aux hd_ty (Array.length args) in
-        hd_ty, Util.list_map_filter (fun (t, name) ->
-          let evs = Util.Intset.elements (Evarutil.evars_of_term t) in
+        hd_ty, Util.List.map_filter (fun (t, name) ->
+          let evs = Intset.elements (Evarutil.undefined_evars_of_term sigma t) in
           let open_evs = List.filter (fun k ->
             InProp <> Retyping.get_sort_family_of
               env sigma (Evd.evar_concl (Evd.find sigma k)))
@@ -4663,26 +4820,37 @@
           if open_evs <> [] then Some name else None)
           (List.combine (Array.to_list args) names)
     | _ -> anomaly "rewrite rule not an application" in
-    errorstrm (Himsg.explain_refiner_error (Logic.UnresolvedBindings miss) ++
+    errorstrm (Himsg.explain_refiner_error (Logic.UnresolvedBindings miss)++
       (Pp.fnl()++str"Rule's type:" ++ spc() ++ pr_constr hd_ty))
 ;;
 
+let is_const_ref c r = isConst c && eq_gr (ConstRef (fst(destConst c))) r
+let is_construct_ref c r =
+  isConstruct c && eq_gr (ConstructRef (fst(destConstruct c))) r
+let is_ind_ref c r = isInd c && eq_gr (IndRef (fst(destInd c))) r
+
 let rwcltac cl rdx dir sr gl =
-  let n, r_n,_ = pf_abs_evars gl sr in
+  let n, r_n,_, ucst = pf_abs_evars gl sr in
   let r_n' = pf_abs_cterm gl n r_n in
   let r' = subst_var pattern_id r_n' in
+  let gl = pf_unsafe_merge_uc ucst gl in
   let rdxt = Retyping.get_type_of (pf_env gl) (fst sr) rdx in
-  let cvtac, rwtac =
+(*         pp(lazy(str"sigma@rwcltac=" ++ pr_evar_map None (fst sr))); *)
+        pp(lazy(str"r@rwcltac=" ++ pr_constr (snd sr)));
+  let cvtac, rwtac, gl =
     if closed0 r' then 
       let env, sigma, c, c_eq = pf_env gl, fst sr, snd sr, build_coq_eq () in
-      let c_ty = Typing.type_of env sigma c in
+      let sigma, c_ty = Typing.type_of env sigma c in
+        pp(lazy(str"c_ty@rwcltac=" ++ pr_constr c_ty));
       match kind_of_type (Reductionops.whd_betadeltaiota env sigma c_ty) with
-      | AtomicType(e, a) when eq_constr e c_eq -> 
+      | AtomicType(e, a) when is_ind_ref e c_eq ->
           let new_rdx = if dir = L2R then a.(2) else a.(1) in
-          pirrel_rewrite cl rdx rdxt new_rdx dir sr c_ty, tclIDTAC
+          pirrel_rewrite cl rdx rdxt new_rdx dir (sigma,c) c_ty, tclIDTAC, gl
       | _ -> 
           let cl' = mkApp (mkNamedLambda pattern_id rdxt cl, [|rdx|]) in
-          convert_concl cl', rewritetac dir r'
+          let sigma, _ = Typing.type_of env sigma cl' in
+          let gl = pf_merge_uc_of sigma gl in
+          Proofview.V82.of_tactic (convert_concl cl'), rewritetac dir r', gl
     else
       let dc, r2 = decompose_lam_n n r' in
       let r3, _, r3t  = 
@@ -4694,7 +4862,7 @@
       let itacs = [introid pattern_id; introid rule_id] in
       let cltac = clear [pattern_id; rule_id] in
       let rwtacs = [rewritetac dir (mkVar rule_id); cltac] in
-      (apply_type cl'' [rdx; compose_lam dc r3], tclTHENLIST (itacs @ rwtacs))
+      apply_type cl'' [rdx; compose_lam dc r3], tclTHENLIST (itacs @ rwtacs), gl
   in
   let cvtac' _ =
     try cvtac gl with
@@ -4702,8 +4870,8 @@
       if occur_existential (pf_concl gl)
       then errorstrm (str "Rewriting impacts evars")
       else errorstrm (str "Dependent type error in rewrite of "
-        ++ pf_pr_constr gl (mkNamedLambda pattern_id rdxt cl))
-    | Util.UserError _ as e -> raise e
+        ++ pf_pr_constr gl (project gl) (mkNamedLambda pattern_id rdxt cl))
+    | Errors.UserError _ as e -> raise e
     | e -> anomaly ("cvtac's exception: " ^ Printexc.to_string e);
   in
   tclTHEN cvtac' rwtac gl
@@ -4739,9 +4907,10 @@
 let prof_rwxrtac_find_rule = mk_profiler "rwrxtac.find_rule";;
 
 let closed0_check cl p gl =
-  if closed0 cl then errorstrm (str"No occurrence of redex "++pf_pr_constr gl p)
+  if closed0 cl then
+    errorstrm (str"No occurrence of redex "++pf_pr_constr gl (project gl) p)
 
-let rwrxtac occ rdx_pat dir rule gl =
+let rwprocess_rule dir rule gl =
   let env = pf_env gl in
   let coq_prod = lz_coq_prod () in
   let is_setoid = ssr_is_setoid env in
@@ -4750,25 +4919,34 @@
       let t =
         if red = 1 then Tacred.hnf_constr env sigma t0
         else Reductionops.whd_betaiotazeta sigma t0 in
+      pp(lazy(str"rewrule="++pr_constr t));
       match kind_of_term t with
       | Prod (_, xt, at) ->
-        let ise, x = Evarutil.new_evar (create_evar_defs sigma) env xt in
+        let ise, x = Evarutil.new_evar env (create_evar_defs sigma) xt in
         loop d ise (mkApp (r, [|x|])) (subst1 x at) rs 0
-      | App (pr, a) when pr = coq_prod.Coqlib.typ ->
-        let sr = match kind_of_term (Tacred.hnf_constr env sigma r) with
-        | App (c, ra) when c = coq_prod.Coqlib.intro -> fun i -> ra.(i + 1)
+      | App (pr, a) when is_ind_ref pr coq_prod.Coqlib.typ ->
+        let sr sigma = match kind_of_term (Tacred.hnf_constr env sigma r) with
+        | App (c, ra) when is_construct_ref c coq_prod.Coqlib.intro ->
+          fun i -> ra.(i + 1), sigma
         | _ -> let ra = Array.append a [|r|] in
-          function 1 -> mkApp (coq_prod.Coqlib.proj1, ra)
-                | _ ->  mkApp (coq_prod.Coqlib.proj2, ra) in
-        if a.(0) = build_coq_True () then
-         loop (converse_dir d) sigma (sr 2) a.(1) rs 0
+          function 1 ->
+            let sigma, pi1 = Evd.fresh_global env sigma coq_prod.Coqlib.proj1 in
+            mkApp (pi1, ra), sigma
+          | _ ->
+            let sigma, pi2 = Evd.fresh_global env sigma coq_prod.Coqlib.proj2 in
+            mkApp (pi2, ra), sigma in
+        if Term.eq_constr a.(0) (build_coq_True ()) then
+         let s, sigma = sr sigma 2 in
+         loop (converse_dir d) sigma s a.(1) rs 0
         else
-         let sigma2, rs2 = loop d sigma (sr 2) a.(1) rs 0 in
-         loop d sigma2 (sr 1) a.(0) rs2 0
+         let s, sigma = sr sigma 2 in
+         let sigma, rs2 = loop d sigma s a.(1) rs 0 in
+         let s, sigma = sr sigma 1 in
+         loop d sigma s a.(0) rs2 0
       | App (r_eq, a) when Hipattern.match_with_equality_type t != None ->
-        let ind = destInd r_eq and rhs = array_last a in
-        let np, ndep = Inductiveops.inductive_nargs env ind in
-        let ind_ct = Inductiveops.type_of_constructors env ind in
+        let indu = destInd r_eq and rhs = Array.last a in
+        let np = Inductiveops.inductive_nparamdecls (fst indu) in
+        let ind_ct = Inductiveops.type_of_constructors env indu in
         let lhs0 = last_arg (strip_prod_assum ind_ct.(0)) in
         let rdesc = match kind_of_term lhs0 with
         | Rel i ->
@@ -4803,7 +4981,13 @@
         in
     let sigma, r = rule in
     let t = Retyping.get_type_of env sigma r in
-    loop dir sigma r t [] 0 in
+    loop dir sigma r t [] 0
+  in
+    r_sigma, rules
+
+let rwrxtac occ rdx_pat dir rule gl =
+  let env = pf_env gl in
+  let r_sigma, rules = rwprocess_rule dir rule gl in
   let find_rule rdx =
     let rec rwtac = function
       | [] ->
@@ -4814,7 +4998,7 @@
         try
           let ise = unify_HO env (create_evar_defs r_sigma) lhs rdx in
           if not (rw_progress rhs rdx ise) then raise NoMatch else
-          d, (ise, Reductionops.nf_evar ise r)
+          d, (ise, Evd.evar_universe_context ise, Reductionops.nf_evar ise r)
         with _ -> rwtac rs in
      rwtac rules in
   let find_rule rdx = prof_rwxrtac_find_rule.profile find_rule rdx in
@@ -4828,14 +5012,15 @@
         sigma, pats @ [pat] in
       let rpats = List.fold_left (rpat env0 sigma0) (r_sigma,[]) rules in
       let find_R, end_R = mk_tpattern_matcher sigma0 occ ~upats_origin rpats in
-      find_R ~k:(fun _ _ h -> mkRel h), 
+      (fun e c _ i -> find_R ~k:(fun _ _ _ h -> mkRel h) e c i), 
       fun cl -> let rdx,d,r = end_R () in closed0_check cl rdx gl; (d,r),rdx
   | Some(_, (T e | X_In_T (_,e) | E_As_X_In_T (e,_,_) | E_In_X_In_T (e,_,_))) ->
       let r = ref None in
-      (fun env c h -> do_once r (fun () -> find_rule c, c); mkRel h),
+      (fun env c _ h -> do_once r (fun () -> find_rule c, c); mkRel h),
       (fun concl -> closed0_check concl e gl; assert_done r) in
   let concl = eval_pattern env0 sigma0 concl0 rdx_pat occ find_R in
   let (d, r), rdx = conclude concl in
+  let r = Evd.merge_universe_context (pi1 r) (pi2 r), pi3 r in
   rwcltac concl rdx d r gl
 ;;
 
@@ -4844,6 +5029,32 @@
   prof_rwxrtac.profile (rwrxtac occ rdx_pat dir rule) gl
 ;;
 
+let ssrinstancesofrule ist dir arg gl =
+  let sigma0, env0, concl0 = project gl, pf_env gl, pf_concl gl in
+  let rule = interp_term ist gl arg in
+  let r_sigma, rules = rwprocess_rule dir rule gl in
+  let find, conclude =
+    let upats_origin = dir, snd rule in
+    let rpat env sigma0 (sigma, pats) (d, r, lhs, rhs) =
+      let sigma, pat =
+        mk_tpattern env sigma0 (sigma,r) (rw_progress rhs) d lhs in
+      sigma, pats @ [pat] in
+    let rpats = List.fold_left (rpat env0 sigma0) (r_sigma,[]) rules in
+    mk_tpattern_matcher ~all_instances:true ~raise_NoMatch:true sigma0 None ~upats_origin rpats in
+  let print env p c _ = ppnl (hov 1 (str"instance:" ++ spc() ++ pr_constr p ++ spc() ++ str "matches:" ++ spc() ++ pr_constr c)); c in
+  ppnl (str"BEGIN INSTANCES");
+  try
+    while true do
+      ignore(find env0 concl0 1 ~k:print)
+    done; raise NoMatch
+  with NoMatch -> ppnl (str"END INSTANCES"); tclIDTAC gl
+
+TACTIC EXTEND ssrinstofruleL2R
+| [ "ssrinstancesofruleL2R" ssrterm(arg) ] -> [ Proofview.V82.tactic (ssrinstancesofrule ist L2R arg) ]
+END
+TACTIC EXTEND ssrinstofruleR2L
+| [ "ssrinstancesofruleR2L" ssrterm(arg) ] -> [ Proofview.V82.tactic (ssrinstancesofrule ist R2L arg) ]
+END
 
 (* Resolve forward reference *)
 let _ = 
@@ -4869,16 +5080,15 @@
 
 (** Rewrite argument sequence *)
 
-(* type ssrrwargs = ssrrwarg list * ltacctx *)
+(* type ssrrwargs = ssrrwarg list *)
 
-let pr_ssrrwargs _ _ _ (rwargs, _) = pr_list spc pr_rwarg rwargs
+let pr_ssrrwargs _ _ _ rwargs = pr_list spc pr_rwarg rwargs
 
-ARGUMENT EXTEND ssrrwargs TYPED AS ssrrwarg list * ltacctx
-                          PRINTED BY pr_ssrrwargs
-  | [ "Qed" ] -> [ anomaly "Grammar placeholder match" ]
+ARGUMENT EXTEND ssrrwargs TYPED AS ssrrwarg list PRINTED BY pr_ssrrwargs
+  | [ "YouShouldNotTypeThis" ] -> [ anomaly "Grammar placeholder match" ]
 END
 
-let ssr_rw_syntax = ref true
+let ssr_rw_syntax = Summary.ref ~name:"SSR:rewrite" true
 
 let _ =
   Goptions.declare_bool_option
@@ -4892,7 +5102,7 @@
 let test_ssr_rw_syntax =
   let test strm  =
     if not !ssr_rw_syntax then raise Stream.Failure else
-    if ssr_loaded () then () else
+    if is_ssr_loaded () then () else
     match Compat.get_tok (Util.stream_nth 0 strm) with
     | Tok.KEYWORD key when List.mem key.[0] ['{'; '['; '/'] -> ()
     | _ -> raise Stream.Failure in
@@ -4900,17 +5110,17 @@
 
 GEXTEND Gram
   GLOBAL: ssrrwargs;
-  ssrrwargs: [[ test_ssr_rw_syntax; a = LIST1 ssrrwarg -> a, rawltacctx ]];
+  ssrrwargs: [[ test_ssr_rw_syntax; a = LIST1 ssrrwarg -> a ]];
 END
 
 (** The "rewrite" tactic *)
 
-let ssrrewritetac ist rwargs = tclTHENLIST (List.map (rwargtac ist) rwargs)
+let ssrrewritetac ist rwargs =
+  tclTHENLIST (List.map (rwargtac ist) rwargs)
 
 TACTIC EXTEND ssrrewrite
   | [ "rewrite" ssrrwargs(args) ssrclauses(clauses) ] ->
-    [ let ist = get_ltacctx (snd args) in
-      tclCLAUSES ist (ssrrewritetac ist (fst args)) clauses ]
+    [ Proofview.V82.tactic (tclCLAUSES ist (ssrrewritetac ist args) clauses) ]
 END
 
 (** The "unlock" tactic *)
@@ -4924,33 +5134,33 @@
   | [  ssrterm(t) ] -> [ None, t ]
 END
 
-let pr_ssrunlockargs _ _ _ (args, _) = pr_list spc pr_unlockarg args
+let pr_ssrunlockargs _ _ _ args = pr_list spc pr_unlockarg args
 
-ARGUMENT EXTEND ssrunlockargs TYPED AS ssrunlockarg list * ltacctx
+ARGUMENT EXTEND ssrunlockargs TYPED AS ssrunlockarg list
   PRINTED BY pr_ssrunlockargs
-  | [  ssrunlockarg_list(args) ] -> [ args, rawltacctx ]
+  | [  ssrunlockarg_list(args) ] -> [ args ]
 END
 
 let unfoldtac occ ko t kt gl =
   let cl, c = pf_fill_occ_term gl occ (fst (strip_unfold_term t kt)) in
-  let cl' = subst1 (pf_unfoldn [(true, [1]), get_evalref c] gl c) cl in
+  let cl' = subst1 (pf_unfoldn [OnlyOccurrences [1], get_evalref c] gl c) cl in
   let f = if ko = None then Closure.betaiotazeta else Closure.betaiota in
-  convert_concl (pf_reduce (Reductionops.clos_norm_flags f) gl cl') gl
+  Proofview.V82.of_tactic
+    (convert_concl (pf_reduce (Reductionops.clos_norm_flags f) gl cl')) gl
 
-let unlocktac ist args =
+let unlocktac ist args gl =
   let utac (occ, gt) gl =
     unfoldtac occ occ (interp_term ist gl gt) (fst gt) gl in
-  let locked = mkSsrConst "locked" in
-  let key = mkSsrConst "master_key" in
+  let locked, gl = pf_mkSsrConst "locked" gl in
+  let key, gl = pf_mkSsrConst "master_key" gl in
   let ktacs = [
     (fun gl -> unfoldtac None None (project gl,locked) '(' gl); 
     simplest_newcase key ] in
-  tclTHENLIST (List.map utac args @ ktacs)
+  tclTHENLIST (List.map utac args @ ktacs) gl
 
 TACTIC EXTEND ssrunlock
   | [ "unlock" ssrunlockargs(args) ssrclauses(clauses) ] ->
-    [ let ist = get_ltacctx (snd args) in
-      tclCLAUSES ist (unlocktac ist (fst args)) clauses ]
+[  Proofview.V82.tactic (tclCLAUSES ist (unlocktac ist args) clauses) ]
 END
 
 (** 8. Forward chaining tactics (pose, set, have, suffice, wlog) *)
@@ -4964,7 +5174,7 @@
 (* We use a primitive parser for the head identifier of forward *)
 (* tactis to avoid syntactic conflicts with basic Coq tactics. *)
 ARGUMENT EXTEND ssrfwdid TYPED AS ident PRINTED BY pr_ssrfwdid
-  | [ "Qed" ] -> [ Util.anomaly "Grammar placeholder match" ]
+  | [ "YouShouldNotTypeThis" ] -> [ anomaly "Grammar placeholder match" ]
 END
 
 let accept_ssrfwdid strm =
@@ -5037,7 +5247,7 @@
   | BFdef false :: h, LocalRawDef ((_, x), v) :: bl ->
     Bdef (x, None, v) :: format_local_binders h bl
   | BFdef true :: h,
-      LocalRawDef ((_, x), CCast (_, v, CastConv (_, t))) :: bl ->
+      LocalRawDef ((_, x), CCast (_, v, CastConv t)) :: bl ->
     Bdef (x, Some t, v) :: format_local_binders h bl
   | _ -> []
   
@@ -5051,10 +5261,10 @@
   | BFdef false :: h, CLetIn(_, (_, x), v, c) ->
     let bs, c' = format_constr_expr h c in
     Bdef (x, None, v) :: bs, c'
-  | BFdef true :: h, CLetIn(_, (_, x), CCast (_, v, CastConv (_, t)), c) ->
+  | BFdef true :: h, CLetIn(_, (_, x), CCast (_, v, CastConv t), c) ->
     let bs, c' = format_constr_expr h c in
     Bdef (x, Some t, v) :: bs, c'
-  | [BFcast], CCast (_, c, CastConv (_, t)) ->
+  | [BFcast], CCast (_, c, CastConv t) ->
     [Bcast t], c
   | BFrec (has_str, has_cast) :: h, 
     CFix (_, _, [_, (Some locn, CStructRec), bl, t, c]) ->
@@ -5078,7 +5288,7 @@
     end
   | BFdef false :: h, (x, _, Some v, _)  :: d ->
     Bdef (x, None, v) :: format_glob_decl h d
-  | BFdef true:: h, (x, _, Some (GCast (_, v, CastConv (_, t))), _) :: d ->
+  | BFdef true:: h, (x, _, Some (GCast (_, v, CastConv t)), _) :: d ->
     Bdef (x, Some t, v) :: format_glob_decl h d
   | _, (x, _, None, t) :: d ->
     Bdecl ([x], t) :: format_glob_decl [] d
@@ -5101,10 +5311,10 @@
   | BFdef false :: h, GLetIn(_, x, v, c) ->
     let bs, c' = format_glob_constr h c in
     Bdef (x, None, v) :: bs, c'
-  | BFdef true :: h, GLetIn(_, x, GCast (_, v, CastConv (_, t)), c) ->
+  | BFdef true :: h, GLetIn(_, x, GCast (_, v, CastConv t), c) ->
     let bs, c' = format_glob_constr h c in
     Bdef (x, Some t, v) :: bs, c'
-  | [BFcast], GCast (_, c, CastConv(_, t)) ->
+  | [BFcast], GCast (_, c, CastConv t) ->
     [Bcast t], c
   | BFrec (has_str, has_cast) :: h, GRec (_, f, _, bl, t, c)
       when Array.length c = 1 ->
@@ -5131,24 +5341,22 @@
   | FwdHint (s,_) -> str (s ^ " ") | _ -> str " :=" ++ spc ()
 let pr_fwdfmt (fk, _ : ssrfwdfmt) = pr_fwdkind fk
 
-let wit_ssrfwdfmt, globwit_ssrfwdfmt, rawwit_ssrfwdfmt =
-  add_genarg "ssrfwdfmt" pr_fwdfmt
+let wit_ssrfwdfmt = add_genarg "ssrfwdfmt" pr_fwdfmt
 
 (* type ssrfwd = ssrfwdfmt * ssrterm *)
 
-let mkFwdVal fk c = ((fk, []), mk_term ' ' c), rawltacctx
-let mkssrFwdVal fk c = ((fk, []), (c,None)), rawltacctx
+let mkFwdVal fk c = ((fk, []), mk_term ' ' c)
+let mkssrFwdVal fk c = ((fk, []), (c,None))
 
-let mkFwdCast fk loc t c =
-  ((fk, [BFcast]), mk_term ' ' (CCast (loc, c, dC t))), rawltacctx
-let mkssrFwdCast fk loc t c = ((fk, [BFcast]), (c, Some t)), rawltacctx
+let mkFwdCast fk loc t c = ((fk, [BFcast]), mk_term ' ' (CCast (loc, c, dC t)))
+let mkssrFwdCast fk loc t c = ((fk, [BFcast]), (c, Some t))
 
 let mkFwdHint s t =
   let loc = constr_loc t in
-  mkFwdCast (FwdHint (s,false)) loc t (CHole (loc, None))
+  mkFwdCast (FwdHint (s,false)) loc t (mkCHole loc)
 let mkFwdHintNoTC s t =
   let loc = constr_loc t in
-  mkFwdCast (FwdHint (s,true)) loc t (CHole (loc, None))
+  mkFwdCast (FwdHint (s,true)) loc t (mkCHole loc)
 
 let pr_gen_fwd prval prc prlc fk (bs, c) =
   let prc s = str s ++ spc () ++ prval prc prlc c in
@@ -5160,9 +5368,9 @@
   | _, _ -> spc () ++ pr_list spc (pr_binder prlc) bs ++ prc " :="
 
 let pr_fwd_guarded prval prval' = function
-| ((fk, h), (_, (_, Some c))), _ ->
+| (fk, h), (_, (_, Some c)) ->
   pr_gen_fwd prval pr_constr_expr prl_constr_expr fk (format_constr_expr h c)
-| ((fk, h), (_, (c, None))), _ ->
+| (fk, h), (_, (c, None)) ->
   pr_gen_fwd prval' pr_glob_constr prl_glob_constr fk (format_glob_constr h c)
 
 let pr_unguarded prc prlc = prlc
@@ -5170,8 +5378,7 @@
 let pr_fwd = pr_fwd_guarded pr_unguarded pr_unguarded
 let pr_ssrfwd _ _ _ = pr_fwd
  
-ARGUMENT EXTEND ssrfwd TYPED AS (ssrfwdfmt * ssrterm) * ltacctx
-                       PRINTED BY pr_ssrfwd
+ARGUMENT EXTEND ssrfwd TYPED AS (ssrfwdfmt * ssrterm) PRINTED BY pr_ssrfwd
   | [ ":=" lconstr(c) ] -> [ mkFwdVal FwdPose c ]
   | [ ":" lconstr (t) ":=" lconstr(c) ] -> [ mkFwdCast FwdPose loc t c ]
 END
@@ -5185,11 +5392,11 @@
 
 ARGUMENT EXTEND ssrbvar TYPED AS constr PRINTED BY pr_ssrbvar
 | [ ident(id) ] -> [ mkCVar loc id ]
-| [ "_" ] -> [ CHole (loc, None) ]
+| [ "_" ] -> [ mkCHole loc ]
 END
 
 let bvar_lname = function
-  | CRef (Ident (loc, id)) -> loc, Name id
+  | CRef (Ident (loc, id), _) -> loc, Name id
   | c -> constr_loc c, Anonymous
 
 let pr_ssrbinder prc _ _ (_, c) = prc c
@@ -5198,34 +5405,35 @@
  | [ ssrbvar(bv) ] ->
    [ let xloc, _ as x = bvar_lname bv in
      (FwdPose, [BFvar]),
-     CLambdaN (loc,[[x],Default Explicit,CHole (xloc,None)],CHole (loc,None)) ]
+     CLambdaN (loc,[[x],Default Explicit,mkCHole xloc],mkCHole loc) ]
  | [ "(" ssrbvar(bv) ")" ] ->
    [ let xloc, _ as x = bvar_lname bv in
      (FwdPose, [BFvar]),
-     CLambdaN (loc,[[x],Default Explicit,CHole (xloc,None)],CHole (loc,None)) ]
+     CLambdaN (loc,[[x],Default Explicit,mkCHole xloc],mkCHole loc) ]
  | [ "(" ssrbvar(bv) ":" lconstr(t) ")" ] ->
    [ let x = bvar_lname bv in
      (FwdPose, [BFdecl 1]),
-     CLambdaN (loc, [[x], Default Explicit, t], CHole (loc, None)) ]
+     CLambdaN (loc, [[x], Default Explicit, t], mkCHole loc) ]
  | [ "(" ssrbvar(bv) ne_ssrbvar_list(bvs) ":" lconstr(t) ")" ] ->
    [ let xs = List.map bvar_lname (bv :: bvs) in
      let n = List.length xs in
      (FwdPose, [BFdecl n]),
-     CLambdaN (loc, [xs, Default Explicit, t], CHole (loc, None)) ]
+     CLambdaN (loc, [xs, Default Explicit, t], mkCHole loc) ]
  | [ "(" ssrbvar(id) ":" lconstr(t) ":=" lconstr(v) ")" ] ->
-   [ let loc' = Util.join_loc (constr_loc t) (constr_loc v) in
+   [ let loc' = Loc.join_loc (constr_loc t) (constr_loc v) in
      let v' = CCast (loc', v, dC t) in
-     (FwdPose,[BFdef true]), CLetIn (loc,bvar_lname id, v',CHole (loc,None)) ]
+     (FwdPose,[BFdef true]), CLetIn (loc,bvar_lname id, v',mkCHole loc) ]
  | [ "(" ssrbvar(id) ":=" lconstr(v) ")" ] ->
-   [ (FwdPose,[BFdef false]), CLetIn (loc,bvar_lname id, v,CHole (loc,None)) ]
+   [ (FwdPose,[BFdef false]), CLetIn (loc,bvar_lname id, v,mkCHole loc) ]
 END
 
 GEXTEND Gram
   GLOBAL: ssrbinder;
   ssrbinder: [
   [  ["of" | "&"]; c = operconstr LEVEL "99" ->
+     let loc = !@loc in
      (FwdPose, [BFvar]),
-     CLambdaN (loc,[[loc,Anonymous],Default Explicit,c],CHole (loc,None)) ]
+     CLambdaN (loc,[[loc,Anonymous],Default Explicit,c],mkCHole loc) ]
   ];
 END
 
@@ -5234,7 +5442,7 @@
   | _ -> []
 
 let push_binders c2 bs =
-  let loc2 = constr_loc c2 in let mkloc loc1 = Util.join_loc loc1 loc2 in
+  let loc2 = constr_loc c2 in let mkloc loc1 = Loc.join_loc loc1 loc2 in
   let rec loop ty c = function
   | (_, CLambdaN (loc1, b, _)) :: bs when ty ->
       CProdN (mkloc loc1, b, loop ty c bs)
@@ -5245,8 +5453,8 @@
   | [] -> c
   | _ -> anomaly "binder not a lambda nor a let in" in
   match c2 with
-  | CCast (x, ct, CastConv (y, cty)) ->
-      (CCast (x, loop false ct bs, CastConv (y, loop true cty bs)))
+  | CCast (x, ct, CastConv cty) ->
+      (CCast (x, loop false ct bs, CastConv (loop true cty bs)))
   | ct -> loop false ct bs
 
 let rec fix_binders = function
@@ -5270,8 +5478,8 @@
 (* The plain pose form. *)
 
 let bind_fwd bs = function
-  | ((fk, h), (ck, (rc, Some c))), ctx ->
-    ((fk,binders_fmts bs @ h), (ck,(rc,Some (push_binders c bs)))), ctx
+  | (fk, h), (ck, (rc, Some c)) ->
+    (fk,binders_fmts bs @ h), (ck,(rc,Some (push_binders c bs)))
   | fwd -> fwd
 
 ARGUMENT EXTEND ssrposefwd TYPED AS ssrfwd PRINTED BY pr_ssrfwd
@@ -5283,29 +5491,29 @@
 let pr_ssrfixfwd _ _ _ (id, fwd) = str " fix " ++ pr_id id ++ pr_fwd fwd
 
 let bvar_locid = function
-  | CRef (Ident (loc, id)) -> loc, id
-  | _ -> Util.error "Missing identifier after \"(co)fix\""
+  | CRef (Ident (loc, id), _) -> loc, id
+  | _ -> Errors.error "Missing identifier after \"(co)fix\""
 
 
 ARGUMENT EXTEND ssrfixfwd TYPED AS ident * ssrfwd PRINTED BY pr_ssrfixfwd
   | [ "fix" ssrbvar(bv) ssrbinder_list(bs) ssrstruct(sid) ssrfwd(fwd) ] ->
     [ let (_, id) as lid = bvar_locid bv in
-      let ((fk, h), (ck, (rc, oc))), ctx = fwd in
+      let (fk, h), (ck, (rc, oc)) = fwd in
       let c = Option.get oc in
       let has_cast, t', c' = match format_constr_expr h c with
       | [Bcast t'], c' -> true, t', c'
-      | _ -> false, CHole (constr_loc c, None), c in
+      | _ -> false, mkCHole (constr_loc c), c in
       let lb = fix_binders bs in
       let has_struct, i =
         let rec loop = function
-          (l', Name id') :: _ when sid = Some id' -> true, (l', id')
+          (l', Name id') :: _ when Option.equal Id.equal sid (Some id') -> true, (l', id')
           | [l', Name id'] when sid = None -> false, (l', id')
           | _ :: bn -> loop bn
-          | [] -> Util.error "Bad structural argument" in
+          | [] -> Errors.error "Bad structural argument" in
         loop (names_of_local_assums lb) in
       let h' = BFrec (has_struct, has_cast) :: binders_fmts bs in
       let fix = CFix (loc, lid, [lid, (Some i, CStructRec), lb, t', c']) in
-      id, (((fk, h'), (ck, (rc, Some fix))), ctx) ]
+      id, ((fk, h'), (ck, (rc, Some fix))) ]
 END
 
 
@@ -5316,28 +5524,29 @@
 ARGUMENT EXTEND ssrcofixfwd TYPED AS ssrfixfwd PRINTED BY pr_ssrcofixfwd
   | [ "cofix" ssrbvar(bv) ssrbinder_list(bs) ssrfwd(fwd) ] ->
     [ let _, id as lid = bvar_locid bv in
-      let ((fk, h), (ck, (rc, oc))), ctx = fwd in
+      let (fk, h), (ck, (rc, oc)) = fwd in
       let c = Option.get oc in
       let has_cast, t', c' = match format_constr_expr h c with
       | [Bcast t'], c' -> true, t', c'
-      | _ -> false, CHole (constr_loc c, None), c in
+      | _ -> false, mkCHole (constr_loc c), c in
       let h' = BFrec (false, has_cast) :: binders_fmts bs in
       let cofix = CCoFix (loc, lid, [lid, fix_binders bs, t', c']) in
-      id, (((fk, h'), (ck, (rc, Some cofix))), ctx)
+      id, ((fk, h'), (ck, (rc, Some cofix)))
     ]
 END
 
-let ssrposetac (id, ((_, t), ctx)) gl =
-  posetac id (snd(pf_abs_ssrterm (get_ltacctx ctx) gl t)) gl
+let ssrposetac ist (id, (_, t)) gl =
+  let sigma, t, ucst, _ = pf_abs_ssrterm ist gl t in
+  posetac id t (pf_merge_uc ucst gl)
 
 
 let prof_ssrposetac = mk_profiler "ssrposetac";;
 let ssrposetac arg gl = prof_ssrposetac.profile (ssrposetac arg) gl;;
   
 TACTIC EXTEND ssrpose
-| [ "pose" ssrfixfwd(ffwd) ] -> [ ssrposetac ffwd ]
-| [ "pose" ssrcofixfwd(ffwd) ] -> [ ssrposetac ffwd ]
-| [ "pose" ssrfwdid(id) ssrposefwd(fwd) ] -> [ ssrposetac (id, fwd) ]
+| [ "pose" ssrfixfwd(ffwd) ] -> [ Proofview.V82.tactic (ssrposetac ist ffwd) ]
+| [ "pose" ssrcofixfwd(ffwd) ] -> [ Proofview.V82.tactic (ssrposetac ist ffwd) ]
+| [ "pose" ssrfwdid(id) ssrposefwd(fwd) ] -> [ Proofview.V82.tactic (ssrposetac ist (id, fwd)) ]
 END
 
 (** The "set" tactic *)
@@ -5350,18 +5559,18 @@
   if occ = nodocc then pr_guarded guard_setrhs prlc c else pr_docc occ ++ prc c
 
 let pr_fwd_guarded prval prval' = function
-| ((fk, h), (_, (_, Some c))), _ ->
+| (fk, h), (_, (_, Some c)) ->
   pr_gen_fwd prval pr_constr_expr prl_constr_expr fk (format_constr_expr h c)
-| ((fk, h), (_, (c, None))), _ ->
+| (fk, h), (_, (c, None)) ->
   pr_gen_fwd prval' pr_glob_constr prl_glob_constr fk (format_glob_constr h c)
 
 (* This does not print the type, it should be fixed... *)
-let pr_ssrsetfwd _ _ _ ((((fk,_),(t,_)),ctx), docc) =
+let pr_ssrsetfwd _ _ _ (((fk,_),(t,_)), docc) =
   pr_gen_fwd (fun _ _ -> pr_cpattern)
     (fun _ -> mt()) (fun _ -> mt()) fk ([Bcast ()],t)
 
 ARGUMENT EXTEND ssrsetfwd
-TYPED AS ((ssrfwdfmt * (lcpattern * ssrterm option)) * ltacctx) * ssrdocc
+TYPED AS (ssrfwdfmt * (lcpattern * ssrterm option)) * ssrdocc
 PRINTED BY pr_ssrsetfwd
 | [ ":" lconstr(t) ":=" "{" ssrocc(occ) "}" cpattern(c) ] ->
   [ mkssrFwdCast FwdPose loc (mk_lterm t) c, mkocc occ ]
@@ -5372,26 +5581,25 @@
 | [ ":=" lcpattern(c) ] -> [ mkssrFwdVal FwdPose c, nodocc ]
 END
 
-let ssrsettac ist id (((_, (pat, pty)), _), (_, occ)) gl =
+let ssrsettac ist id ((_, (pat, pty)), (_, occ)) gl =
   let pat = interp_cpattern ist gl pat (Option.map snd pty) in
   let cl, sigma, env = pf_concl gl, project gl, pf_env gl in
-  let c, cl = 
+  let (c, ucst), cl = 
     try fill_occ_pattern ~raise_NoMatch:true env sigma cl pat occ 1
     with NoMatch -> redex_of_pattern ~resolve_typeclasses:true env pat, cl in
   if occur_existential c then errorstrm(str"The pattern"++spc()++
     pr_constr_pat c++spc()++str"did not match and has holes."++spc()++
     str"Did you mean pose?") else
-  let c, cty =  match kind_of_term c with
-  | Cast(t, DEFAULTcast, ty) -> t, ty
+  let c, (gl, cty) =  match kind_of_term c with
+  | Cast(t, DEFAULTcast, ty) -> t, (gl, ty)
   | _ -> c, pf_type_of gl c in
   let cl' = mkLetIn (Name id, c, cty, cl) in
-  tclTHEN (convert_concl cl') (introid id) gl
+  let gl = pf_merge_uc ucst gl in
+  tclTHEN (Proofview.V82.of_tactic (convert_concl cl')) (introid id) gl
 
 TACTIC EXTEND ssrset
 | [ "set" ssrfwdid(id) ssrsetfwd(fwd) ssrclauses(clauses) ] ->
-  [ let (_, ctx), _ = fwd in
-    let ist = get_ltacctx ctx in
-    tclCLAUSES ist (ssrsettac ist id fwd) clauses ]
+  [ Proofview.V82.tactic (tclCLAUSES ist (ssrsettac ist id fwd) clauses) ]
 END
 
 (** The "have" tactic *)
@@ -5411,8 +5619,8 @@
   | IpatId id ->
       let xloc, _ as x = bvar_lname (mkCVar dummy_loc id) in
       (FwdPose, [BFvar]),
-        CLambdaN (dummy_loc, [[x], Default Explicit, CHole (xloc, None)],
-          CHole (dummy_loc, None))
+        CLambdaN (dummy_loc, [[x], Default Explicit, mkCHole xloc],
+          mkCHole dummy_loc)
   | _ -> anomaly "non-id accepted as binder")
 
 let binder_to_intro_id = List.map (function
@@ -5423,7 +5631,7 @@
   | (FwdPose, [BFdef _]), CLetIn (_,(_,Anonymous),_,_) -> [IpatAnon]
   | _ -> anomaly "ssrbinder is not a binder")
 
-let pr_ssrhavefwdwbinders _ _ prt (tr,(hpats, (fwd, hint))) =
+let pr_ssrhavefwdwbinders _ _ prt (tr,((hpats, (fwd, hint)))) =
   pr_hpats hpats ++ pr_fwd fwd ++ pr_hint prt hint
 
 ARGUMENT EXTEND ssrhavefwdwbinders
@@ -5440,28 +5648,39 @@
 
 (* Tactic. *)
 
+let is_Evar_or_CastedMeta x =
+  isEvar_or_Meta x ||
+  (isCast x && isEvar_or_Meta (pi1 (destCast x)))
+
+let occur_existential_or_casted_meta c =
+  let rec occrec c = match kind_of_term c with
+    | Evar _ -> raise Not_found
+    | Cast (m,_,_) when isMeta m -> raise Not_found
+    | _ -> iter_constr occrec c
+  in try occrec c; false with Not_found -> true
+
 let examine_abstract id gl =
-  let tid = pf_type_of gl id in
-  let abstract = mkSsrConst "abstract" in
-  if not (isApp tid) || not (eq_constr (fst(destApp tid)) abstract) then
+  let gl, tid = pf_type_of gl id in
+  let abstract, gl = pf_mkSsrConst "abstract" gl in
+  if not (isApp tid) || not (Term.eq_constr (fst(destApp tid)) abstract) then
     errorstrm(strbrk"not an abstract constant: "++pr_constr id);
   let _, args_id = destApp tid in
   if Array.length args_id <> 3 then
     errorstrm(strbrk"not a proper abstract constant: "++pr_constr id);
-  if not (isEvar args_id.(2)) then
+  if not (is_Evar_or_CastedMeta args_id.(2)) then
     errorstrm(strbrk"abstract constant "++pr_constr id++str" already used");
-  args_id
+  tid, args_id
 
 let pf_find_abstract_proof check_lock gl abstract_n = 
   let fire gl t = Reductionops.nf_evar (project gl) t in
-  let abstract = mkSsrConst "abstract" in
+  let abstract, gl = pf_mkSsrConst "abstract" gl in
   let l = Evd.fold_undefined (fun e ei l ->
     match kind_of_term ei.Evd.evar_concl with
     | App(hd, [|ty; n; lock|])
       when (not check_lock || 
-                 (occur_existential (fire gl ty) &&
-                  isEvar (fire gl lock))) &&
-      eq_constr hd abstract && eq_constr n abstract_n -> e::l
+                 (occur_existential_or_casted_meta (fire gl ty) &&
+                  is_Evar_or_CastedMeta (fire gl lock))) &&
+      Term.eq_constr hd abstract && Term.eq_constr n abstract_n -> e::l
     | _ -> l) (project gl) [] in
   match l with
   | [e] -> e
@@ -5472,17 +5691,19 @@
 let unfold cl =
   let module R = Reductionops in let module F = Closure.RedFlags in
   reduct_in_concl (R.clos_norm_flags (F.mkflags
-    (List.map (fun c -> F.fCONST (destConst c)) cl @ [F.fBETA; F.fIOTA])))
+    (List.map (fun c -> F.fCONST (fst (destConst c))) cl @ [F.fBETA; F.fIOTA])))
 
 let havegentac ist t gl =
-  let _, c = pf_abs_ssrterm ist gl t in
-  apply_type (mkArrow (pf_type_of gl c) (pf_concl gl)) [c] gl
+  let sigma, c, ucst, _ = pf_abs_ssrterm ist gl t in
+  let gl = pf_merge_uc ucst gl in
+  let gl, cty = pf_type_of gl c in
+  apply_type (mkArrow cty (pf_concl gl)) [c] gl
 
-let havetac
-  (transp,((((clr, pats), binders), simpl), ((((fk, _), t), ctx), hint)))
+let havetac ist
+  (transp,((((clr, pats), binders), simpl), (((fk, _), t), hint)))
   suff namefst gl 
 =
- let ist, concl = get_ltacctx ctx, pf_concl gl in
+ let concl = pf_concl gl in
  let skols, pats =
    List.partition (function IpatNewHidden _ -> true | _ -> false) pats in
  let itac_mkabs = introstac ~ist skols in
@@ -5499,30 +5720,28 @@
  let hint = hinttac ist true hint in
  let cuttac t gl =
    if transp then
-     (* The v8.4 refiner is too stupid to deal with a let-in, apparently.
-      * Let's do things by hand... *)
-     let concl = pf_concl gl in
-     let gl, extra = pf_new_evar gl t in
-     let gl, kont = pf_new_evar gl (mkLetIn (Anonymous, extra, t, concl)) in
-     let step = mkApp (mkSsrConst "ssr_have_let", [|concl; t; extra; kont|]) in
-     pf_partial_solution gl step [extra; kont]
-   else
-     basecuttac "ssr_have" t gl in
+     let have_let, gl = pf_mkSsrConst "ssr_have_let" gl in
+     let step = mkApp (have_let, [|concl;t|]) in
+     let gl, _ = pf_e_type_of gl step in
+     applyn ~with_evars:true ~with_shelve:false 2 step gl
+   else basecuttac "ssr_have" t gl in
  (* Introduce now abstract constants, so that everything sees them *)
- let abstract_key = mkSsrConst "abstract_key" in
- let unlock_abs args_id gl = pf_unify_HO gl args_id.(2) abstract_key in
+ let abstract_key, gl = pf_mkSsrConst "abstract_key" gl in
+ let unlock_abs (idty,args_id) gl =
+    let gl, _ = pf_e_type_of gl idty in
+    pf_unify_HO gl args_id.(2) abstract_key in
  tclTHENFIRST itac_mkabs (fun gl ->
   let mkt t = mk_term ' ' t in
   let mkl t = (' ', (t, None)) in
   let interp gl rtc t = pf_abs_ssrterm ~resolve_typeclasses:rtc ist gl t in
   let interp_ty gl rtc t =
-    let a,b,_ = pf_interp_ty ~resolve_typeclasses:rtc ist gl t in a, b in
+    let a,b,_,u = pf_interp_ty ~resolve_typeclasses:rtc ist gl t in a,b,u in
   let ct, cty, hole, loc = match t with
-    | _, (_, Some (CCast (loc, ct, CastConv (_, cty)))) ->
+    | _, (_, Some (CCast (loc, ct, CastConv cty))) ->
       mkt ct, mkt cty, mkt (mkCHole dummy_loc), loc
     | _, (_, Some ct) ->
       mkt ct, mkt (mkCHole dummy_loc), mkt (mkCHole dummy_loc), dummy_loc
-    | _, (GCast (loc, ct, CastConv (_, cty)), None) ->
+    | _, (GCast (loc, ct, CastConv cty), None) ->
       mkl ct, mkl cty, mkl mkRHole, loc
     | _, (t, None) -> mkl t, mkl mkRHole, mkl mkRHole, dummy_loc in
   let gl, cut, sol, itac1, itac2 =
@@ -5531,14 +5750,15 @@
      errorstrm (str"Suff have does not accept a proof term")
    | FwdHave, false, true ->
      let cty = combineCG cty hole (mkCArrow loc) mkRArrow in
-     let _, t = interp gl false (combineCG ct cty (mkCCast loc) mkRCast) in
-     let ty = pf_type_of gl t in
+     let _,t,uc,_ = interp gl false (combineCG ct cty (mkCCast loc) mkRCast) in
+     let gl = pf_merge_uc uc gl in
+     let gl, ty = pf_type_of gl t in
      let ctx, _ = decompose_prod_n 1 ty in
      let assert_is_conv gl =
-       try convert_concl (compose_prod ctx concl) gl
+       try Proofview.V82.of_tactic (convert_concl (compose_prod ctx concl)) gl
        with _ -> errorstrm (str "Given proof term is not of type " ++
          pr_constr (mkArrow (mkVar (id_of_string "_")) concl)) in
-     gl, ty, tclTHEN assert_is_conv (apply t), id, itac_c
+     gl, ty, tclTHEN assert_is_conv (Proofview.V82.of_tactic (apply t)), id, itac_c
    | FwdHave, false, false ->
      let skols = List.flatten (List.map (function
        | IpatNewHidden ids -> ids
@@ -5546,22 +5766,33 @@
      let skols_args =
        List.map (fun id -> examine_abstract (mkVar id) gl) skols in
      let gl = List.fold_right unlock_abs skols_args gl in
-     let sigma, t = interp gl false (combineCG ct cty (mkCCast loc) mkRCast) in
-     let gl = re_sig (sig_it gl) sigma in
+     let sigma, t, uc, n_evars =
+       interp gl false (combineCG ct cty (mkCCast loc) mkRCast) in
+     if skols <> [] && n_evars <> 0 then
+       Errors.error ("Automatic generalization of unresolved implicit "^
+                     "arguments together with abstract variables is "^
+                     "not supported");
+     let gl = re_sig (sig_it gl) (Evd.merge_universe_context sigma uc) in
      let gs =
-       List.map (fun a -> pf_find_abstract_proof false gl a.(1)) skols_args in
+       List.map (fun (_,a) ->
+         pf_find_abstract_proof false gl a.(1)) skols_args in
      let tacopen_skols gl =
         let stuff, g = Refiner.unpackage gl in
-        Refiner.repackage stuff ((List.map Goal.build gs) @ [g]) in
-     gl, pf_type_of gl t, apply t, id,
+        Refiner.repackage stuff (gs @ [g]) in
+     let gl, ty = pf_e_type_of gl t in
+     gl, ty, Proofview.V82.of_tactic (apply t), id,
        tclTHEN (tclTHEN itac_c simpltac)
-         (tclTHEN tacopen_skols (unfold [mkSsrConst "abstract";abstract_key]))
-   | _,true,true ->
-     gl, mkArrow (snd (interp_ty gl fixtc cty)) concl, hint, itac, clr
+         (tclTHEN tacopen_skols (fun gl ->
+            let abstract, gl = pf_mkSsrConst "abstract" gl in
+            unfold [abstract; abstract_key] gl))
+   | _,true,true  ->
+     let _, ty, uc = interp_ty gl fixtc cty in let gl = pf_merge_uc uc gl in
+     gl, mkArrow ty concl, hint, itac, clr
    | _,false,true ->
-     gl, mkArrow (snd (interp_ty gl fixtc cty)) concl, hint, id, itac_c
+     let _, ty, uc = interp_ty gl fixtc cty in let gl = pf_merge_uc uc gl in
+     gl, mkArrow ty concl, hint, id, itac_c
    | _, false, false -> 
-     let n, cty = interp_ty gl fixtc cty in
+     let n, cty, uc = interp_ty gl fixtc cty in let gl = pf_merge_uc uc gl in
      gl, cty, tclTHEN (binderstac n) hint, id, tclTHEN itac_c simpltac
    | _, true, false -> assert false in
   tclTHENS (cuttac cut) [ tclTHEN sol itac1; itac2 ] gl)
@@ -5573,8 +5804,7 @@
   Lemma use_abstract T n l (x : abstract T n l) : T.
   Proof. by case: l x. Qed.
 *)
-let ssrabstract ctx gens (*last*) gl =
-  let ist = get_ltacctx ctx in
+let ssrabstract ist gens (*last*) gl =
   let main _ (_,cid) ist gl =
 (*
     let proj1, proj2, prod =
@@ -5583,10 +5813,11 @@
 *)
     let concl, env = pf_concl gl, pf_env gl in
     let fire gl t = Reductionops.nf_evar (project gl) t in
-    let abstract = mkSsrConst "abstract" in
-    let abstract_key = mkSsrConst "abstract_key" in
-    let id = mkVar (Option.get (id_of_cpattern cid)) in
-    let args_id = examine_abstract id gl in
+    let abstract, gl = pf_mkSsrConst "abstract" gl in
+    let abstract_key, gl = pf_mkSsrConst "abstract_key" gl in
+    let cid_interpreted = interp_cpattern ist gl cid None in
+    let id = mkVar (Option.get (id_of_pattern cid_interpreted)) in
+    let idty, args_id = examine_abstract id gl in
     let abstract_n = args_id.(1) in
     let abstract_proof = pf_find_abstract_proof true gl abstract_n in 
     let gl, proof =
@@ -5597,6 +5828,8 @@
       let rec find_hole p t =
         match kind_of_term t with
         | Evar _ (*when last*) -> pf_unify_HO gl concl t, p
+        | Meta _ (*when last*) -> pf_unify_HO gl concl t, p
+        | Cast(m,_,_) when isEvar_or_Meta m (*when last*) -> pf_unify_HO gl concl t, p
 (*
         | Evar _ ->
             let sigma, it = project gl, sig_it gl in
@@ -5605,7 +5838,7 @@
             let p = mkApp (proj2,[|ty;concl;p|]) in
             let concl = mkApp(prod,[|ty; concl|]) in
             pf_unify_HO gl concl t, p
-        | App(hd, [|left; right|]) when eq_constr hd prod ->
+        | App(hd, [|left; right|]) when Term.eq_constr hd prod ->
             find_hole (mkApp (proj1,[|left;right;p|])) left
 *)
         | _ -> errorstrm(strbrk"abstract constant "++pr_constr abstract_n++
@@ -5616,17 +5849,18 @@
           (*else mkApp(mkSsrConst "use_abstract",Array.append args_id [|id|])*))
           (fire gl args_id.(0)) in
     let gl = (*if last then*) pf_unify_HO gl abstract_key args_id.(2) (*else gl*) in
+    let gl, _ = pf_e_type_of gl idty in
     let proof = fire gl proof in
 (*     if last then *)
       let tacopen gl =
         let stuff, g = Refiner.unpackage gl in
-        Refiner.repackage stuff [ g; Goal.build abstract_proof ] in
-      tclTHENS tacopen [tclSOLVE [apply proof];unfold[abstract;abstract_key]] gl
+        Refiner.repackage stuff [ g; abstract_proof ] in
+      tclTHENS tacopen [tclSOLVE [Proofview.V82.of_tactic (apply proof)];unfold[abstract;abstract_key]] gl
 (* else apply proof gl *)
   in
   let introback ist (gens, _) =
     introstac ~ist
-      (List.map (fun (_,cp) -> match id_of_cpattern cp with
+      (List.map (fun (_,cp) -> match id_of_pattern (interp_cpattern ist gl cp None) with
         | None -> IpatAnon
         | Some id -> IpatId id)
         (List.tl (List.hd gens))) in
@@ -5636,16 +5870,15 @@
 GEXTEND Gram
   GLOBAL: tactic_expr;
   tactic_expr: LEVEL "3"
-    [ RIGHTA [ IDENT "abstract"; gens = ssrdgens; ctx = ltacctx ->
-               Tacexpr.TacAtom(loc,Tacexpr.TacExtend (loc, "ssrabstract",
-                [Genarg.in_gen rawwit_ssrdgens gens;
-                 Genarg.in_gen rawwit_ltacctx ctx])) ]];
+    [ RIGHTA [ IDENT "abstract"; gens = ssrdgens ->
+               Tacexpr.TacML (!@loc, ssrtac_name "abstract",
+                [Genarg.in_gen (Genarg.rawwit wit_ssrdgens) gens]) ]];
 END
 TACTIC EXTEND ssrabstract
-| [ "abstract" ssrdgens(gens) ltacctx(ctx) ] -> [
+| [ "abstract" ssrdgens(gens) ] -> [
     if List.length (fst gens) <> 1 then
       errorstrm (str"dependents switches '/' not allowed here");
-    ssrabstract ctx gens ]
+    Proofview.V82.tactic (ssrabstract ist gens) ]
 END
 
 let prof_havetac = mk_profiler "havetac";;
@@ -5653,27 +5886,27 @@
 
 TACTIC EXTEND ssrhave
 | [ "have" ssrhavefwdwbinders(fwd) ] ->
-  [ havetac fwd false false ]
+  [ Proofview.V82.tactic (havetac ist fwd false false) ]
 END
 
 TACTIC EXTEND ssrhavesuff
 | [ "have" "suff" ssrhpats_nobs(pats) ssrhavefwd(fwd) ] ->
-  [ havetac (false,(pats,fwd)) true false ]
+  [ Proofview.V82.tactic (havetac ist (false,(pats,fwd)) true false) ]
 END
 
 TACTIC EXTEND ssrhavesuffices
 | [ "have" "suffices" ssrhpats_nobs(pats) ssrhavefwd(fwd) ] ->
-  [ havetac (false,(pats,fwd)) true false ]
+  [ Proofview.V82.tactic (havetac ist (false,(pats,fwd)) true false) ]
 END
 
 TACTIC EXTEND ssrsuffhave
 | [ "suff" "have" ssrhpats_nobs(pats) ssrhavefwd(fwd) ] ->
-  [ havetac (false,(pats,fwd)) true true ]
+  [ Proofview.V82.tactic (havetac ist (false,(pats,fwd)) true true) ]
 END
 
 TACTIC EXTEND ssrsufficeshave
 | [ "suffices" "have" ssrhpats_nobs(pats) ssrhavefwd(fwd) ] ->
-  [ havetac (false,(pats,fwd)) true true ]
+  [ Proofview.V82.tactic (havetac ist (false,(pats,fwd)) true true) ]
 END
 
 (** The "suffice" tactic *)
@@ -5691,22 +5924,23 @@
     (((clr, pats), allbinders), simpl), (bind_fwd allbs fwd, hint) ]
 END
 
-let sufftac ((((clr, pats),binders),simpl), (((_, c), ctx), hint)) =
-  let ist = get_ltacctx ctx in
+let sufftac ist ((((clr, pats),binders),simpl), ((_, c), hint)) =
   let htac = tclTHEN (introstac ~ist pats) (hinttac ist true hint) in
   let c = match c with
-  | (a, (b, Some (CCast (_, _, CastConv (_, cty))))) -> a, (b, Some cty)
-  | (a, (GCast (_, _, CastConv (_, cty)), None)) -> a, (cty, None)
+  | (a, (b, Some (CCast (_, _, CastConv cty)))) -> a, (b, Some cty)
+  | (a, (GCast (_, _, CastConv cty), None)) -> a, (cty, None)
   | _ -> anomaly "suff: ssr cast hole deleted by typecheck" in
-  let ctac gl = basecuttac "ssr_suff" (pi2 (pf_interp_ty ist gl c)) gl in
+  let ctac gl =
+    let _,ty,_,uc = pf_interp_ty ist gl c in let gl = pf_merge_uc uc gl in
+    basecuttac "ssr_suff" ty gl in
   tclTHENS ctac [htac; tclTHEN (cleartac clr) (introstac ~ist (binders@simpl))]
 
 TACTIC EXTEND ssrsuff
-| [ "suff" ssrsufffwd(fwd) ] -> [ sufftac fwd ]
+| [ "suff" ssrsufffwd(fwd) ] -> [ Proofview.V82.tactic (sufftac ist fwd) ]
 END
 
 TACTIC EXTEND ssrsuffices
-| [ "suffices" ssrsufffwd(fwd) ] -> [ sufftac fwd ]
+| [ "suffices" ssrsufffwd(fwd) ] -> [ Proofview.V82.tactic (sufftac ist fwd) ]
 END
 
 (** The "wlog" (Without Loss Of Generality) tactic *)
@@ -5725,41 +5959,47 @@
   match kind_of_term c with
   | Prod (n,ty,c) -> (n,None,ty), c
   | LetIn (n,bo,ty,c) -> (n,Some bo,ty), c
-  | _ -> raise (Invalid_argument "destProd_or_LetIn")
-
-let wlogtac (((clr0, pats),_),_) (gens, ((_, ct), ctx)) hint suff ghave gl =
-  let ist = get_ltacctx ctx in
-  let mkabs gen = abs_wgen false ist gl (fun x -> x) gen in
+  | _ -> raise DestKO
+        
+let wlogtac ist (((clr0, pats),_),_) (gens, ((_, ct))) hint suff ghave gl =
+  let mkabs gen = abs_wgen false ist (fun x -> x) gen in
   let mkclr gen clrs = clr_of_wgen gen clrs in
   let mkpats = function
-  | _, Some ((SsrHyp (_,x), _), _) -> fun pats -> IpatId x :: pats
+  | _, Some ((x, _), _) -> fun pats -> IpatId (hoi_id x) :: pats
   | _ -> fun x -> x in
   let ct = match ct with
-  | (a, (b, Some (CCast (_, _, CastConv (_, cty))))) -> a, (b, Some cty)
-  | (a, (GCast (_, _, CastConv (_, cty)), None)) -> a, (cty, None)
+  | (a, (b, Some (CCast (_, _, CastConv cty)))) -> a, (b, Some cty)
+  | (a, (GCast (_, _, CastConv cty), None)) -> a, (cty, None)
   | _ -> anomaly "wlog: ssr cast hole deleted by typecheck" in
   let cut_implies_goal = not (suff || ghave <> `NoGen) in
-  let c, args, ct =
+  let c, args, ct, gl =
     let gens = List.filter (function _, Some _ -> true | _ -> false) gens in
     let concl = pf_concl gl in
     let c = mkProp in
     let c = if cut_implies_goal then mkArrow c concl else c in
-    let args, c = List.fold_right mkabs gens ([],c) in
+    let gl, args, c = List.fold_right mkabs gens (gl,[],c) in
     let env, _ =
       List.fold_left (fun (env, c) _ ->
         let rd, c = destProd_or_LetIn c in
         Environ.push_rel rd env, c) (pf_env gl, c) gens in
-    let sigma, ev = Evarutil.new_evar (project gl) env Term.mkProp in
+    let sigma, ev = Evarutil.new_evar env (project gl) Term.mkProp in
     let k, _ = Term.destEvar ev in
-    let fake_gl = { Evd.it = Goal.build k; Evd.sigma = sigma } in
-    let _, ct, _ = pf_interp_ty ist fake_gl ct in
-    let rec subst c g s = match kind_of_term c, g with
-      | Prod(Anonymous,_,c), [] -> mkProd(Anonymous, subst_vars s ct, c)
-      | Sort _, [] -> subst_vars s ct
-      | LetIn(Name id as n,b,ty,c), _::g -> mkLetIn (n,b,ty,subst c g (id::s))
-      | Prod(Name id as n,ty,c), _::g -> mkProd (n,ty,subst c g (id::s))
-      | _ -> anomaly "SSR: wlog: subst" in
-    subst c gens [], args, ct in
+    let fake_gl = {Evd.it = k; Evd.sigma = sigma} in
+    let _, ct, _, uc = pf_interp_ty ist fake_gl ct in
+    let rec var2rel c g s = match kind_of_term c, g with
+      | Prod(Anonymous,_,c), [] -> mkProd(Anonymous, Vars.subst_vars s ct, c)
+      | Sort _, [] -> Vars.subst_vars s ct
+      | LetIn(Name id as n,b,ty,c), _::g -> mkLetIn (n,b,ty,var2rel c g (id::s))
+      | Prod(Name id as n,ty,c), _::g -> mkProd (n,ty,var2rel c g (id::s))
+      | _ -> Errors.anomaly(str"SSR: wlog: var2rel: " ++ pr_constr c) in
+    let c = var2rel c gens [] in
+    let rec pired c = function
+      | [] -> c
+      | t::ts as args -> match kind_of_term c with
+         | Prod(_,_,c) -> pired (subst1 t c) ts
+         | LetIn(id,b,ty,c) -> mkLetIn (id,b,ty,pired c args)
+         | _ -> Errors.anomaly(str"SSR: wlog: pired: " ++ pr_constr c) in
+    c, args, pired c args, pf_merge_uc uc gl in
   let tacipat pats = introstac ~ist pats in
   let tacigens = 
     tclTHEN
@@ -5773,20 +6013,23 @@
     | true, `Gen _ -> assert false
     | false, `Gen id ->
       if gens = [] then errorstrm(str"gen have requires some generalizations");
+      let clear0 = cleartac clr0 in
       let id, name_general_hyp, cleanup, pats = match id, pats with
-      | None, (IpatId id as ip)::pats -> Some id, tacipat [ip], tclIDTAC, pats
-      | None, _ -> None, tclIDTAC, tclIDTAC, pats
-      | Some (Some id),_ -> Some id, introid id, tclIDTAC, pats
+      | None, (IpatId id as ip)::pats -> Some id, tacipat [ip], clear0, pats
+      | None, _ -> None, tclIDTAC, clear0, pats
+      | Some (Some id),_ -> Some id, introid id, clear0, pats
       | Some _,_ ->
           let id = mk_anon_id "tmp" gl in
-          Some id, introid id, clear [id], pats in
+          Some id, introid id, tclTHEN clear0 (clear [id]), pats in
       let tac_specialize = match id with
       | None -> tclIDTAC
       | Some id ->
         if pats = [] then tclIDTAC else
         let args = Array.of_list args in
+        pp(lazy(str"specialized="++pr_constr (mkApp (mkVar id,args))));
+        pp(lazy(str"specialized_ty="++pr_constr ct));
         tclTHENS (basecuttac "ssr_have" ct)
-          [apply (mkApp (mkVar id,args)); tclIDTAC] in
+          [Proofview.V82.of_tactic (apply (mkApp (mkVar id,args))); tclIDTAC] in
       "ssr_have",
       (if hint = nohint then tacigens else hinttac),
       tclTHENLIST [name_general_hyp; tac_specialize; tacipat pats; cleanup]
@@ -5795,34 +6038,34 @@
 
 TACTIC EXTEND ssrwlog
 | [ "wlog" ssrhpats_nobs(pats) ssrwlogfwd(fwd) ssrhint(hint) ] ->
-  [ wlogtac pats fwd hint false `NoGen ]
+  [ Proofview.V82.tactic (wlogtac ist pats fwd hint false `NoGen) ]
 END
 
 TACTIC EXTEND ssrwlogs
 | [ "wlog" "suff" ssrhpats_nobs(pats) ssrwlogfwd(fwd) ssrhint(hint) ] ->
-  [ wlogtac pats fwd hint true `NoGen ]
+  [ Proofview.V82.tactic (wlogtac ist pats fwd hint true `NoGen) ]
 END
 
 TACTIC EXTEND ssrwlogss
 | [ "wlog" "suffices" ssrhpats_nobs(pats) ssrwlogfwd(fwd) ssrhint(hint) ]->
-  [ wlogtac pats fwd hint true `NoGen ]
+  [ Proofview.V82.tactic (wlogtac ist pats fwd hint true `NoGen) ]
 END
 
 TACTIC EXTEND ssrwithoutloss
 | [ "without" "loss" ssrhpats_nobs(pats) ssrwlogfwd(fwd) ssrhint(hint) ] ->
-  [ wlogtac pats fwd hint false `NoGen ]
+  [ Proofview.V82.tactic (wlogtac ist pats fwd hint false `NoGen) ]
 END
 
 TACTIC EXTEND ssrwithoutlosss
 | [ "without" "loss" "suff" 
     ssrhpats_nobs(pats) ssrwlogfwd(fwd) ssrhint(hint) ] ->
-  [ wlogtac pats fwd hint true `NoGen ]
+  [ Proofview.V82.tactic (wlogtac ist pats fwd hint true `NoGen) ]
 END
 
 TACTIC EXTEND ssrwithoutlossss
 | [ "without" "loss" "suffices" 
     ssrhpats_nobs(pats) ssrwlogfwd(fwd) ssrhint(hint) ]->
-  [ wlogtac pats fwd hint true `NoGen ]
+  [ Proofview.V82.tactic (wlogtac ist pats fwd hint true `NoGen) ]
 END
 
 (* Generally have *)
@@ -5850,23 +6093,24 @@
   ] ];
 END
 
+let augment_preclr clr1 (((clr0, x),y),z) = (((clr1 @ clr0, x),y),z)
+
 TACTIC EXTEND ssrgenhave
-| [ "gen" "have"
+| [ "gen" "have" ssrclear(clr)
     ssr_idcomma(id) ssrhpats_nobs(pats) ssrwlogfwd(fwd) ssrhint(hint) ] ->
-  [ wlogtac pats fwd hint false (`Gen id) ]
+  [ let pats = augment_preclr clr pats in
+    Proofview.V82.tactic (wlogtac ist pats fwd hint false (`Gen id)) ]
 END
 
 TACTIC EXTEND ssrgenhave2
-| [ "generally" "have"
+| [ "generally" "have" ssrclear(clr)
     ssr_idcomma(id) ssrhpats_nobs(pats) ssrwlogfwd(fwd) ssrhint(hint) ] ->
-  [ wlogtac pats fwd hint false (`Gen id) ]
+  [ let pats = augment_preclr clr pats in
+    Proofview.V82.tactic (wlogtac ist pats fwd hint false (`Gen id)) ]
 END
 
 (** Canonical Structure alias *)
 
-let def_body : Vernacexpr.definition_expr Gram.Entry.e = Obj.magic
-   (Grammar.Entry.find (Obj.magic gallina_ext) "vernac:def_body") in
-
 GEXTEND Gram
   GLOBAL: gallina_ext;
 
@@ -5877,12 +6121,11 @@
       | IDENT "Canonical"; ntn = Prim.by_notation ->
 	  Vernacexpr.VernacCanonical (ByNotation ntn)
       | IDENT "Canonical"; qid = Constr.global;
-          d = def_body ->
+          d = G_vernac.def_body ->
           let s = coerce_reference_to_id qid in
 	  Vernacexpr.VernacDefinition
-	    ((Decl_kinds.Global,Decl_kinds.CanonicalStructure),
-             (dummy_loc,s),(d  ),
-             (fun _ -> Recordops.declare_canonical_structure))
+	    ((Some Decl_kinds.Global,Decl_kinds.CanonicalStructure),
+             ((dummy_loc,s),None),(d  ))
   ]];
 END
 
@@ -5900,18 +6143,11 @@
 (* Coq v8.3 defines "by" as a keyword, some hacks are not needed any   *)
 (* longer and thus comment out. Such comments are marked with v8.3     *)
 
-let tac_ent = List.fold_left Grammar.Entry.find (Obj.magic simple_tactic) in
-let hypident_ent =
-  tac_ent ["clause_dft_all"; "in_clause"; "hypident_occ"; "hypident"] in
-let id_or_meta : Obj.t Gram.Entry.e = Obj.magic
-   (Grammar.Entry.find hypident_ent "id_or_meta") in
-let hypident : (Obj.t * hyp_location_flag) Gram.Entry.e =
-   Obj.magic hypident_ent in
 GEXTEND Gram
-  GLOBAL: hypident;
-hypident: [
-  [ "("; IDENT "type"; "of"; id = id_or_meta; ")" -> id, InHypTypeOnly
-  | "("; IDENT "value"; "of"; id = id_or_meta; ")" -> id, InHypValueOnly
+  GLOBAL: Tactic.hypident;
+  Tactic.hypident: [
+  [ "("; IDENT "type"; "of"; id = Prim.identref; ")" -> id, InHypTypeOnly
+  | "("; IDENT "value"; "of"; id = Prim.identref; ")" -> id, InHypValueOnly
   ] ];
 END
 
@@ -5919,20 +6155,16 @@
   GLOBAL: hloc;
 hloc: [
   [ "in"; "("; "Type"; "of"; id = ident; ")" -> 
-    HypLocation ((Util.dummy_loc,id), InHypTypeOnly)
+    HypLocation ((dummy_loc,id), InHypTypeOnly)
   | "in"; "("; IDENT "Value"; "of"; id = ident; ")" -> 
-    HypLocation ((Util.dummy_loc,id), InHypValueOnly)
+    HypLocation ((dummy_loc,id), InHypValueOnly)
   ] ];
 END
 
-let constr_eval
- : (Topconstr.constr_expr,Obj.t,Obj.t) Glob_term.may_eval Gram.Entry.e
- = Obj.magic (Grammar.Entry.find (Obj.magic constr_may_eval) "constr_eval")
-
 GEXTEND Gram
-  GLOBAL: constr_eval;
-  constr_eval: [
-    [ IDENT "type"; "of"; c = Constr.constr -> ConstrTypeOf c ]
+  GLOBAL: Tactic.constr_eval;
+  Tactic.constr_eval: [
+    [ IDENT "type"; "of"; c = Constr.constr -> Genredexpr.ConstrTypeOf c ]
   ];
 END
 
diff -ur a/src/ssrmatching.ml4 b/src/ssrmatching.ml4
--- a/src/ssrmatching.ml4	2014-03-11 17:39:43.000000000 +0100
+++ b/src/ssrmatching.ml4	2016-01-24 17:01:50.663675080 +0100
@@ -1,5 +1,5 @@
-(* (c) Copyright Microsoft Corporation and Inria.                       *)
-(* You may distribute this file under the terms of the CeCILL-B license *)
+(* (c) Copyright 2006-2015 Microsoft Corporation and Inria.                  *)
+(* Distributed under the terms of CeCILL-B.                                  *)
 
 (* Defining grammar rules with "xx" in it automatically declares keywords too,
  * we thus save the lexer to restore it at the end of the file *)
@@ -12,7 +12,9 @@
 open Pp
 open Pcoq
 open Genarg
+open Constrarg
 open Term
+open Vars
 open Topconstr
 open Libnames
 open Tactics
@@ -36,9 +38,23 @@
 open Ppconstr
 open Printer
 
-type loc = Util.loc
-let errorstrm = errorlabstrm "ssreflect"
-let loc_error loc msg = user_err_loc (loc, msg, str msg)
+open Globnames
+open Misctypes
+open Decl_kinds
+open Evar_kinds
+open Constrexpr
+open Constrexpr_ops
+open Notation_term
+open Notation_ops
+open Locus
+open Locusops
+
+DECLARE PLUGIN "ssreflect"
+
+type loc = Loc.t
+let dummy_loc = Loc.ghost
+let errorstrm = Errors.errorlabstrm "ssreflect"
+let loc_error loc msg = Errors.user_err_loc (loc, msg, str msg)
 
 (* 0 cost pp function. Active only if env variable SSRDEBUG is set *)
 (* or if SsrDebug is Set                                                  *)
@@ -62,12 +78,13 @@
 let safeDestApp c =
   match kind_of_term c with App (f, a) -> f, a | _ -> c, [| |]
 let get_index = function ArgArg i -> i | _ ->
-  anomaly "Uninterpreted index"
+  Errors.anomaly (str"Uninterpreted index")
 (* Toplevel constr must be globalized twice ! *)
-let glob_constr ist gsigma genv = function
+let glob_constr ist genv = function
   | _, Some ce ->
-    let ltacvars = List.map fst ist.lfun, [] in
-    Constrintern.intern_gen false ~ltacvars:ltacvars gsigma genv ce
+    let vars = Id.Map.fold (fun x _ accu -> Id.Set.add x accu) ist.lfun Id.Set.empty in
+    let ltacvars = { Constrintern.empty_ltac_sign with Constrintern.ltac_vars = vars } in
+    Constrintern.intern_gen WithoutTypeConstraint ~ltacvars:ltacvars genv ce
   | rc, None -> rc
 
 (* Term printing utilities functions for deciding bracketing.  *)
@@ -104,30 +121,31 @@
 
 (** Adding a new uninterpreted generic argument type *)
 let add_genarg tag pr =
-  let wit, globwit, rawwit as wits = create_arg None tag in
-  let glob _ rarg = in_gen globwit (out_gen rawwit rarg) in
-  let interp _ gl garg = Tacmach.project gl,in_gen wit (out_gen globwit garg) in
-  let subst _ garg = garg in
-  add_interp_genarg tag (glob, interp, subst);
+  let wit = Genarg.make0 None tag in
+  let glob ist x = (ist, x) in
+  let subst _ x = x in
+  let interp ist gl x = (gl.Evd.sigma, x) in
   let gen_pr _ _ _ = pr in
-  Pptactic.declare_extra_genarg_pprule
-    (rawwit, gen_pr) (globwit, gen_pr) (wit, gen_pr);
-  wits
+  let () = Genintern.register_intern0 wit glob in
+  let () = Genintern.register_subst0 wit subst in
+  let () = Geninterp.register_interp0 wit interp in
+  Pptactic.declare_extra_genarg_pprule wit gen_pr gen_pr gen_pr;
+  wit
 
 (** Constructors for cast type *)
-let dC t = CastConv (DEFAULTcast, t)
+let dC t = CastConv t
 (** Constructors for constr_expr *)
-let isCVar = function CRef (Ident _) -> true | _ -> false
-let destCVar = function CRef (Ident (_, id)) -> id | _ ->
-  anomaly "not a CRef"
-let mkCHole loc = CHole (loc, None)
+let isCVar = function CRef (Ident _, _) -> true | _ -> false
+let destCVar = function CRef (Ident (_, id), _) -> id | _ ->
+  Errors.anomaly (str"not a CRef")
+let mkCHole loc = CHole (loc, None, IntroAnonymous, None)
 let mkCLambda loc name ty t = 
    CLambdaN (loc, [[loc, name], Default Explicit, ty], t)
 let mkCLetIn loc name bo t = 
    CLetIn (loc, (loc, name), bo, t)
 let mkCCast loc t ty = CCast (loc,t, dC ty)
 (** Constructors for rawconstr *)
-let mkRHole = GHole (dummy_loc, InternalHole)
+let mkRHole = GHole (dummy_loc, InternalHole, IntroAnonymous, None)
 let mkRApp f args = if args = [] then f else GApp (dummy_loc, f, args)
 let mkRCast rc rt =  GCast (dummy_loc, rc, dC rt)
 let mkRLambda n s t = GLambda (dummy_loc, n, Explicit, s, t)
@@ -136,15 +154,17 @@
 let combineCG t1 t2 f g = match t1, t2 with
  | (x, (t1, None)), (_, (t2, None)) -> x, (g t1 t2, None)
  | (x, (_, Some t1)), (_, (_, Some t2)) -> x, (mkRHole, Some (f t1 t2))
- | _, (_, (_, None)) -> anomaly "have: mixed C-G constr"
- | _ -> anomaly "have: mixed G-C constr"
+ | _, (_, (_, None)) -> Errors.anomaly (str"have: mixed C-G constr")
+ | _ -> Errors.anomaly (str"have: mixed G-C constr")
 let loc_ofCG = function
- | (_, (s, None)) -> loc_of_glob_constr s
- | (_, (_, Some s)) -> constr_loc s
+ | (_, (s, None)) -> Glob_ops.loc_of_glob_constr s
+ | (_, (_, Some s)) -> Constrexpr_ops.constr_loc s
 
 let mk_term k c = k, (mkRHole, Some c)
 let mk_lterm = mk_term ' '
 
+let pf_type_of gl t = let sigma, ty = pf_type_of gl t in re_sig (sig_it gl)  sigma, ty
+
 (* }}} *)
 
 (** Profiling {{{ *************************************************************)
@@ -282,12 +302,22 @@
 (* evars into metas, since 8.2 does not TC metas. This means some lossage *)
 (* for HO evars, though hopefully Miller patterns can pick up some of     *)
 (* those cases, and HO matching will mop up the rest.                     *)
-let flags_FO = {Unification.default_no_delta_unify_flags with 
-                Unification.modulo_conv_on_closed_terms = None;
-                Unification.modulo_eta = true;
-                Unification.modulo_betaiota = true;
-                Unification.modulo_delta_types = full_transparent_state;
-                Unification.allow_K_in_toplevel_higher_order_unification=false} 
+let flags_FO =
+  let flags =
+    { (Unification.default_no_delta_unify_flags ()).Unification.core_unify_flags
+      with
+        Unification.modulo_conv_on_closed_terms = None;
+        Unification.modulo_eta = true;
+        Unification.modulo_betaiota = true;
+        Unification.modulo_delta_types = full_transparent_state}
+  in
+  { Unification.core_unify_flags = flags;
+    Unification.merge_unify_flags = flags;
+    Unification.subterm_unify_flags = flags;
+    Unification.allow_K_in_toplevel_higher_order_unification = false;
+    Unification.resolve_evars =
+      (Unification.default_no_delta_unify_flags ()).Unification.resolve_evars
+  }
 let unif_FO env ise p c =
   Unification.w_unify env ise Reduction.CONV ~flags:flags_FO p c
 
@@ -308,15 +338,19 @@
     match Evd.evar_body (Evd.find s k) with
     | Evar_defined c' -> s' := Evd.define k (nf c') !s'
     | _ -> () in
-  let c' = nf c in let _ = Evd.fold copy_def sigma0 () in !s', c'
+  let c' = nf c in let _ = Evd.fold copy_def sigma0 () in
+  !s', Evd.evar_universe_context s, c'
 
 let unif_end env sigma0 ise0 pt ok =
   let ise = Evarconv.consider_remaining_unif_problems env ise0 in
-  let s, t = nf_open_term sigma0 ise pt in
+  let s, uc, t = nf_open_term sigma0 ise pt in
   let ise1 = create_evar_defs s in
   let ise2 = Typeclasses.resolve_typeclasses ~fail:true env ise1 in
   if not (ok ise) then raise NoProgress else
-  if ise2 == ise1 then (s, t) else nf_open_term sigma0 ise2 t
+  if ise2 == ise1 then (s, uc, t)
+  else
+    let s, uc', t = nf_open_term sigma0 ise2 t in
+    s, Evd.union_evar_universe_context uc uc', t
 
 let pf_unif_HO gl sigma pt p c =
   let env = pf_env gl in
@@ -325,8 +359,8 @@
 
 let unify_HO env sigma0 t1 t2 =
   let sigma = unif_HO env sigma0 t1 t2 in
-  let sigma, _ = unif_end env sigma0 sigma t2 (fun _ -> true) in
-  sigma
+  let sigma, uc, _ = unif_end env sigma0 sigma t2 (fun _ -> true) in
+  Evd.set_universe_context sigma uc
 
 let pf_unify_HO gl t1 t2 =
   let env, sigma0, si = pf_env gl, project gl, sig_it gl in
@@ -413,12 +447,12 @@
     with NotInstantiatedEvar ->
     if Evd.mem sigma0 k then map_constr put c else
     let evi = Evd.find !sigma k in
-    let dc = list_firstn (max 0 (Array.length a - nenv)) (evar_filtered_context evi) in
+    let dc = List.firstn (max 0 (Array.length a - nenv)) (evar_filtered_context evi) in
     let abs_dc (d, c) = function
     | x, Some b, t -> d, mkNamedLetIn x (put b) (put t) c
     | x, None, t -> mkVar x :: d, mkNamedProd x (put t) c in
     let a, t =
-      Sign.fold_named_context_reverse abs_dc ~init:([], (put evi.evar_concl)) dc in
+      Context.fold_named_context_reverse abs_dc ~init:([], (put evi.evar_concl)) dc in
     let m = Evarutil.new_meta () in
     ise := meta_declare m t !ise;
     sigma := Evd.define k (applist (mkMeta m, a)) !sigma;
@@ -433,15 +467,15 @@
   let k, f, a =
     let f, a = Reductionops.whd_betaiota_stack ise p in
     match kind_of_term f with
-    | Const p ->
+    | Const (p,_) ->
       let np = proj_nparams p in
       if np = 0 || np > List.length a then KpatConst, f, a else
-      let a1, a2 = list_chop np a in KpatProj p, applist(f, a1), a2
+      let a1, a2 = List.chop np a in KpatProj p, applist(f, a1), a2
     | Var _ | Ind _ | Construct _ -> KpatFixed, f, a
     | Evar (k, _) ->
       if Evd.mem sigma0 k then KpatEvar k, f, a else
       if a <> [] then KpatFlex, f, a else 
-      (match p_origin with None -> error "indeterminate pattern"
+      (match p_origin with None -> Errors.error "indeterminate pattern"
       | Some (dir, rule) ->
 	errorstrm (str "indeterminate " ++ pr_dir_side dir
           ++ str " in " ++ pr_constr_pat rule))
@@ -457,7 +491,7 @@
 
 (* Specialize a pattern after a successful match: assign a precise head *)
 (* kind and arity for Proj and Flex patterns.                           *)
-let ungen_upat lhs (sigma, t) u =
+let ungen_upat lhs (sigma, uc, t) u =
   let f, a = safeDestApp lhs in
   let k = match kind_of_term f with
   | Var _ | Ind _ | Construct _ -> KpatFixed
@@ -466,15 +500,15 @@
   | LetIn _ -> KpatLet
   | Lambda _ -> KpatLam
   | _ -> KpatRigid in
-  sigma, {u with up_k = k; up_FO = lhs; up_f = f; up_a = a; up_t = t}
+  sigma, uc, {u with up_k = k; up_FO = lhs; up_f = f; up_a = a; up_t = t}
 
 let nb_cs_proj_args pc f u =
   let na k =
-    List.length (lookup_canonical_conversion (ConstRef pc, k)).o_TCOMPS in
+    List.length (snd (lookup_canonical_conversion (ConstRef pc, k))).o_TCOMPS in
   try match kind_of_term f with
   | Prod _ -> na Prod_cs
   | Sort s -> na (Sort_cs (family_of_sort s))
-  | Const c' when c' = pc -> Array.length (snd (destApp u.up_f))
+  | Const (c',_) when Constant.equal c' pc -> Array.length (snd (destApp u.up_f))
   | Var _ | Ind _ | Construct _ | Const _ -> na (Const_cs (global_of_constr f))
   | _ -> -1
   with Not_found -> -1
@@ -504,8 +538,8 @@
   let na = Array.length u.up_a in
   if n < na then fpats else
   let np = match u.up_k with
-  | KpatConst when eq_constr u.up_f f -> na
-  | KpatFixed when u.up_f = f -> na 
+  | KpatConst when Term.eq_constr_nounivs u.up_f f -> na
+  | KpatFixed when Term.eq_constr_nounivs u.up_f f -> na
   | KpatEvar k when isEvar_k k f -> na
   | KpatLet when isLetIn f -> na
   | KpatLam when isLambda f -> na
@@ -521,17 +555,17 @@
   let np = nb_args u.up_FO in
   if n < np then fpats else
   let ok = match u.up_k with
-  | KpatConst -> eq_constr u.up_f f 
-  | KpatFixed -> u.up_f = f 
+  | KpatConst -> Term.eq_constr_nounivs u.up_f f
+  | KpatFixed -> Term.eq_constr_nounivs u.up_f f
   | KpatEvar k -> isEvar_k k f
   | KpatLet -> isLetIn f
   | KpatLam -> isLambda f
   | KpatRigid -> isRigid f
-  | KpatProj pc -> f = mkConst pc
+  | KpatProj pc -> Term.eq_constr f (mkConst pc)
   | KpatFlex -> i0 := n; true in
   if ok then begin if !i0 < np then i0 := np; (u, np) :: fpats end else fpats
 
-exception FoundUnif of (evar_map * tpattern)
+exception FoundUnif of (evar_map * evar_universe_context * tpattern)
 (* Note: we don't update env as we descend into the term, as the primitive *)
 (* unification procedure always rejects subterms with bound variables.     *)
 
@@ -565,7 +599,7 @@
              let kludge vla =
                let vl, a = safeDestApp vla in
                let x, v, t, b = destLetIn vl in
-               mkApp (mkLambda (x, t, b), array_cons v a) in
+               mkApp (mkLambda (x, t, b), Array.cons v a) in
              unif_FO env ise (kludge u.up_FO) (kludge c')
            | _ -> unif_FO env ise u.up_FO c' in
            let ise' = (* Unify again using HO to assign evars *)
@@ -575,12 +609,12 @@
            let pt' = unif_end env sigma0 ise' u.up_t (u.up_ok lhs) in
            raise (FoundUnif (ungen_upat lhs pt' u))
        with FoundUnif _ as sigma_u -> raise sigma_u 
-       | Not_found -> anomaly "incomplete ise in match_upats_FO"
+       | Not_found -> Errors.anomaly (str"incomplete ise in match_upats_FO")
        | _ -> () in
     List.iter one_match fpats
   done;
   iter_constr_LR loop f; Array.iter loop a in
-  fun c -> try loop c with Invalid_argument _ -> anomaly "IN FO"
+  fun c -> try loop c with Invalid_argument _ -> Errors.anomaly (str"IN FO")
 
 let prof_FO = mk_profiler "match_upats_FO";;
 let match_upats_FO upats env sigma0 ise c =
@@ -588,7 +622,7 @@
 ;;
 
 
-let match_upats_HO upats env sigma0 ise c =
+let match_upats_HO ~on_instance upats env sigma0 ise c =
  let it_did_match = ref false in
  let rec aux upats env sigma0 ise c =
   let f, a = splay_app ise c in let i0 = ref (-1) in
@@ -617,7 +651,7 @@
         let ise'' = unif_HO_args env ise' u.up_a (i - Array.length u.up_a) a in
         let lhs = mkSubApp f i a in
         let pt' = unif_end env sigma0 ise'' u.up_t (u.up_ok lhs) in
-        raise (FoundUnif (ungen_upat lhs pt' u))
+        on_instance (ungen_upat lhs pt' u)
       with FoundUnif _ as sigma_u -> raise sigma_u 
       | NoProgress -> it_did_match := true
       | _ -> () in
@@ -630,8 +664,8 @@
  if !it_did_match then raise NoProgress
 
 let prof_HO = mk_profiler "match_upats_HO";;
-let match_upats_HO upats env sigma0 ise c =
-  prof_HO.profile (match_upats_HO upats env sigma0) ise c
+let match_upats_HO ~on_instance upats env sigma0 ise c =
+  prof_HO.profile (match_upats_HO ~on_instance upats env sigma0) ise c
 ;;
 
 
@@ -642,17 +676,25 @@
 let do_once r f = match !r with Some _ -> () | None -> r := Some (f ())
 
 let assert_done r = 
-  match !r with Some x -> x | None -> anomaly "do_once never called"
+  match !r with Some x -> x | None -> Errors.anomaly (str"do_once never called")
+
+let assert_done_multires r = 
+  match !r with
+  | None -> Errors.anomaly (str"do_once never called")
+  | Some (n, xs) ->
+      r := Some (n+1,xs);
+      try List.nth xs n with Failure _ -> raise NoMatch
 
-type subst = Environ.env -> Term.constr -> int -> Term.constr
+type subst = Environ.env -> Term.constr -> Term.constr -> int -> Term.constr
 type find_P = 
   Environ.env -> Term.constr -> int ->
   k:subst ->
      Term.constr
-type conclude = unit -> Term.constr * ssrdir * (Evd.evar_map * Term.constr)
+type conclude = unit ->
+  Term.constr * ssrdir * (Evd.evar_map * Evd.evar_universe_context * Term.constr)
 
 (* upats_origin makes a better error message only            *)
-let mk_tpattern_matcher
+let mk_tpattern_matcher ?(all_instances=false)
   ?(raise_NoMatch=false) ?upats_origin sigma0 occ (ise, upats)
 =
   let nocc = ref 0 and skip_occ = ref false in
@@ -677,8 +719,8 @@
       let match_let f = match kind_of_term f with
       | LetIn (_, v, _, b) -> unif_EQ env sigma pv v && unif_EQ env' sigma pb b
       | _ -> false in match_let
-    | KpatFixed -> (=) u.up_f
-    | KpatConst -> eq_constr u.up_f
+    | KpatFixed -> Term.eq_constr u.up_f
+    | KpatConst -> Term.eq_constr u.up_f
     | KpatLam -> fun c ->
        (match kind_of_term c with
        | Lambda _ -> unif_EQ env sigma u.up_f c
@@ -694,49 +736,74 @@
   | Some (dir,rule), _ -> str"The " ++ pr_dir_side dir ++ str" of " ++ 
       pr_constr_pat rule ++ spc()
   | _, [] | None, _::_::_ ->
-      anomaly "mk_tpattern_matcher with no upats_origin" in
+      Errors.anomaly (str"mk_tpattern_matcher with no upats_origin") in
+let on_instance, instances =
+  let instances = ref [] in
+  (fun x ->
+    if all_instances then instances := !instances @ [x]
+    else raise (FoundUnif x)),
+  (fun () -> !instances) in
+let rec uniquize = function
+  | [] -> []
+  | (sigma,_,{ up_f = f; up_a = a; up_t = t } as x) :: xs ->
+    let t = Reductionops.nf_evar sigma t in
+    let f = Reductionops.nf_evar sigma f in
+    let a = Array.map (Reductionops.nf_evar sigma) a in
+    let neq (sigma1,_,{ up_f = f1; up_a = a1; up_t = t1 }) =
+      let t1 = Reductionops.nf_evar sigma1 t1 in
+      let f1 = Reductionops.nf_evar sigma1 f1 in
+      let a1 = Array.map (Reductionops.nf_evar sigma1) a1 in
+      not (Term.eq_constr t t1 &&
+           Term.eq_constr f f1 && CArray.for_all2 Term.eq_constr a a1) in
+    x :: uniquize (List.filter neq xs) in
+
 ((fun env c h ~k -> 
   do_once upat_that_matched (fun () -> 
     try
-      match_upats_FO upats env sigma0 ise c;
-      match_upats_HO upats env sigma0 ise c;
+      if not all_instances then match_upats_FO upats env sigma0 ise c;
+      match_upats_HO ~on_instance upats env sigma0 ise c;
       raise NoMatch
-    with FoundUnif sigma_u -> sigma_u
+    with FoundUnif sigma_u -> 0,[sigma_u]
+    | (NoMatch|NoProgress) when all_instances && instances () <> [] ->
+      0, uniquize (instances ())
     | NoMatch when (not raise_NoMatch) ->
       errorstrm (source () ++ str "does not match any subterm of the goal")
     | NoProgress when (not raise_NoMatch) ->
         let dir = match upats_origin with Some (d,_) -> d | _ ->
-          anomaly "mk_tpattern_matcher with no upats_origin" in      
+          Errors.anomaly (str"mk_tpattern_matcher with no upats_origin") in
         errorstrm (str"all matches of "++source()++
           str"are equal to the " ++ pr_dir_side (inv_dir dir))
     | NoProgress -> raise NoMatch);
-  let sigma, ({up_f = pf; up_a = pa} as u) = assert_done upat_that_matched in
-  if !skip_occ then (ignore(k env u.up_t 0); c) else
+  let sigma, _, ({up_f = pf; up_a = pa} as u) =
+    if all_instances then assert_done_multires upat_that_matched
+    else List.hd (snd(assert_done upat_that_matched)) in
+(*   pp(lazy(str"sigma@tmatch=" ++ pr_evar_map None sigma)); *)
+  if !skip_occ then ((*ignore(k env u.up_t 0);*) c) else
   let match_EQ = match_EQ env sigma u in
   let pn = Array.length pa in
   let rec subst_loop (env,h as acc) c' =
     if !skip_occ then c' else
     let f, a = splay_app sigma c' in
     if Array.length a >= pn && match_EQ f && unif_EQ_args env sigma pa a then
-      let a1, a2 = array_chop (Array.length pa) a in
+      let a1, a2 = Array.chop (Array.length pa) a in
       let fa1 = mkApp (f, a1) in
-      let f' = if subst_occ () then k env u.up_t h else fa1 in
-      mkApp (f', array_map_left (subst_loop acc) a2)
+      let f' = if subst_occ () then k env u.up_t fa1 h else fa1 in
+      mkApp (f', Array.map_left (subst_loop acc) a2)
     else
       (* TASSI: clear letin values to avoid unfolding *)
       let inc_h (n,_,ty) (env,h') = Environ.push_rel (n,None,ty) env, h' + 1 in
       let f' = map_constr_with_binders_left_to_right inc_h subst_loop acc f in
-      mkApp (f', array_map_left (subst_loop acc) a) in
+      mkApp (f', Array.map_left (subst_loop acc) a) in
   subst_loop (env,h) c) : find_P),
 ((fun () ->
-  let sigma, ({up_f = pf; up_a = pa} as u) =
+  let sigma, uc, ({up_f = pf; up_a = pa} as u) =
     match !upat_that_matched with
-    | Some x -> x | None when raise_NoMatch -> raise NoMatch
-    | None -> anomaly "companion function never called" in
+    | Some (_,x) -> List.hd x | None when raise_NoMatch -> raise NoMatch
+    | None -> Errors.anomaly (str"companion function never called") in
   let p' = mkApp (pf, pa) in
-  if max_occ <= !nocc then p', u.up_dir, (sigma, u.up_t)
+  if max_occ <= !nocc then p', u.up_dir, (sigma, uc, u.up_t)
   else errorstrm (str"Only " ++ int !nocc ++ str" < " ++ int max_occ ++
-        str(plural !nocc " occurence") ++ match upats_origin with
+        str(String.plural !nocc " occurence") ++ match upats_origin with
         | None -> str" of" ++ spc() ++ pr_constr_pat p'
         | Some (dir,rule) -> str" of the " ++ pr_dir_side dir ++ fnl() ++
             ws 4 ++ pr_constr_pat p' ++ fnl () ++ 
@@ -780,7 +847,7 @@
   | E_As_X_In_T (e,x,t) ->
       pr_constr e ++ str " as " ++ pr_constr x ++ str " in " ++ pr_constr t
 let pp_pattern (sigma, p) =
-  pr_pattern_aux (fun t -> pr_constr (snd (nf_open_term sigma sigma t))) p
+  pr_pattern_aux (fun t -> pr_constr_pat (pi3 (nf_open_term sigma sigma t))) p
 let pr_cpattern = pr_term
 let pr_rpattern _ _ _ = pr_pattern
 
@@ -791,8 +858,7 @@
 let pr_pattern_roundp = pr_option (fun r -> str "(" ++ pr_pattern r ++ str ")")
 let pr_ssrpattern_roundp  _ _ _ = pr_pattern_roundp
 
-let wit_rpatternty, globwit_rpatternty, rawwit_rpatternty =
-  add_genarg "rpatternty" pr_pattern
+let wit_rpatternty = add_genarg "rpatternty" pr_pattern
 
 ARGUMENT EXTEND rpattern TYPED AS rpatternty PRINTED BY pr_rpattern
   | [ lconstr(c) ] -> [ T (mk_lterm c) ]
@@ -820,27 +886,27 @@
 
 
 let id_of_cpattern = function
-  | _,(_,Some (CRef (Ident (_, x)))) -> Some x
-  | _,(_,Some (CAppExpl (_, (_, Ident (_, x)), []))) -> Some x
-  | _,(GRef (_, VarRef x) ,None) -> Some x
+  | _,(_,Some (CRef (Ident (_, x), _))) -> Some x
+  | _,(_,Some (CAppExpl (_, (_, Ident (_, x), _), []))) -> Some x
+  | _,(GRef (_, VarRef x, _) ,None) -> Some x
   | _ -> None
 let id_of_Cterm t = match id_of_cpattern t with
   | Some x -> x
   | None -> loc_error (loc_of_cpattern t) "Only identifiers are allowed here"
 
-let interp_wit globwit wit ist gl x = 
-  let globarg = in_gen globwit x in
-  let sigma, arg = interp_genarg ist gl globarg in
-  sigma, out_gen wit arg
-let interp_constr = interp_wit globwit_constr wit_constr
+let interp_wit wit ist gl x = 
+  let globarg = in_gen (glbwit wit) x in
+  let sigma, arg = interp_genarg ist (pf_env gl) (project gl) (pf_concl gl) gl.Evd.it globarg in
+  sigma, out_gen (topwit wit) arg
+let interp_constr = interp_wit wit_constr
 let interp_open_constr ist gl gc =
-  interp_wit globwit_open_constr wit_open_constr ist gl ((), gc)
-let pf_intern_term ist gl (_, c) = glob_constr ist (project gl) (pf_env gl) c
+  interp_wit wit_open_constr ist gl ((), gc)
+let pf_intern_term ist gl (_, c) = glob_constr ist (pf_env gl) c
 let interp_term ist gl (_, c) = snd (interp_open_constr ist gl c)
 let glob_ssrterm gs = function
-  | k, (_, Some c) -> k, Tacinterp.intern_constr gs c
+  | k, (_, Some c) -> k, Tacintern.intern_constr gs c
   | ct -> ct
-let subst_ssrterm s (k, c) = k, Tacinterp.subst_glob_constr_and_expr s c
+let subst_ssrterm s (k, c) = k, Tacsubst.subst_glob_constr_and_expr s c
 let pr_ssrterm _ _ _ = pr_term
 let input_ssrtermkind strm = match Compat.get_tok (stream_nth 0 strm) with
   | Tok.KEYWORD "(" -> '('
@@ -875,7 +941,7 @@
          | (r1, Some _), (r2, Some _) when isCVar t1 ->
              encode k "In" [r1; r2; bind_in t1 t2]
          | (r1, Some _), (r2, Some _) -> encode k "In" [r1; r2]
-         | _ -> anomaly "where are we?"
+         | _ -> Errors.anomaly (str"where are we?")
          with _ when isCVar t1 -> encode k "In" [bind_in t1 t2])
      | CNotation(_, "( _ in _ in _ )", ([t1; t2; t3], [], [])) ->
          check_var t2; encode k "In" [fst (glob t1); bind_in t2 t3]
@@ -897,11 +963,13 @@
 | [ "Qed" constr(c) ] -> [ mk_lterm c ]
 END
 
+let (!@) = Compat.to_coqloc
+
 GEXTEND Gram
   GLOBAL: cpattern;
   cpattern: [[ k = ssrtermkind; c = constr ->
     let pattern = mk_term k c in
-    if loc_ofCG pattern <> loc && k = '(' then mk_term 'x' c else pattern ]];
+    if loc_ofCG pattern <> !@loc && k = '(' then mk_term 'x' c else pattern ]];
 END
 
 ARGUMENT EXTEND lcpattern
@@ -917,7 +985,7 @@
   GLOBAL: lcpattern;
   lcpattern: [[ k = ssrtermkind; c = lconstr ->
     let pattern = mk_term k c in
-    if loc_ofCG pattern <> loc && k = '(' then mk_term 'x' c else pattern ]];
+    if loc_ofCG pattern <> !@loc && k = '(' then mk_term 'x' c else pattern ]];
 END
 
 let interp_pattern ist gl red redty =
@@ -928,20 +996,20 @@
   let mkG ?(k=' ') x = k,(x,None) in
   let decode t f g =
     try match (pf_intern_term ist gl t) with
-    | GCast(_,GHole _,CastConv(_,GLambda(_,Name x,_,_,c))) -> f x (' ',(c,None))
+    | GCast(_,GHole _,CastConv(GLambda(_,Name x,_,_,c))) -> f x (' ',(c,None))
     | it -> g t with _ -> g t in
   let decodeG t f g = decode (mkG t) f g in
-  let bad_enc id _ = anomaly ("bad encoding for pattern " ^ id) in
+  let bad_enc id _ = Errors.anomaly (str"bad encoding for pattern "++str id) in
   let cleanup_XinE h x rp sigma =
     let h_k = match kind_of_term h with Evar (k,_) -> k | _ -> assert false in
     let to_clean, update = (* handle rename if x is already used *)
       let ctx = pf_hyps gl in
-      let len = Sign.named_context_length ctx in
+      let len = Context.named_context_length ctx in
       let name = ref None in
-      try ignore(Sign.lookup_named x ctx); (name, fun k ->
+      try ignore(Context.lookup_named x ctx); (name, fun k ->
         if !name = None then
         let nctx = Evd.evar_context (Evd.find sigma k) in
-        let nlen = Sign.named_context_length nctx in
+        let nlen = Context.named_context_length nctx in
         if nlen > len then begin
           name := Some (pi1 (List.nth nctx (nlen - len - 1)))
         end)
@@ -956,16 +1024,16 @@
       aux [] (Evarutil.nf_evar sigma rp) in
     let sigma = 
       List.fold_left (fun sigma e ->
-        if Evd.is_defined sigma e then sigma else (* clear may be recursiv *)
+        if Evd.is_defined sigma e then sigma else (* clear may be recursive *)
+        if Option.is_empty !to_clean then sigma else
         let name = Option.get !to_clean in
-        let g = Goal.build e in
         pp(lazy(pr_id name));
-        try snd(Logic.prim_refiner (Proof_type.Thin [name]) sigma g)
+        try snd(Logic.prim_refiner (Proof_type.Thin [name]) sigma e)
         with Evarutil.ClearDependencyError _ -> sigma)
       sigma new_evars in
     sigma in
   let red = match red with
-    | T(k,(GCast (_,GHole _,(CastConv(_,GLambda (_,Name id,_,_,t)))),None))
+    | T(k,(GCast (_,GHole _,(CastConv(GLambda (_,Name id,_,_,t)))),None))
         when let id = string_of_id id in let len = String.length id in
         (len > 8 && String.sub id 0 8 = "_ssrpat_") ->
         let id = string_of_id id in let len = String.length id in
@@ -999,8 +1067,8 @@
   | red -> red in
   pp(lazy(str"typed as: " ++ pr_pattern_w_ids red));
   let mkXLetIn loc x (a,(g,c)) = match c with
-  | Some b -> a,(g,Some (mkCLetIn loc x (CHole(loc,None)) b))
-  | None -> a,(GLetIn (loc,x,(GHole (loc, BinderType x)), g), None) in
+  | Some b -> a,(g,Some (mkCLetIn loc x (mkCHole loc) b))
+  | None -> a,(GLetIn (loc,x,(GHole (loc, BinderType x, IntroAnonymous, None)), g), None) in
   match red with
   | T t -> let sigma, t = interp_term ist gl t in sigma, T t
   | In_T t -> let sigma, t = interp_term ist gl t in sigma, In_T t
@@ -1026,6 +1094,10 @@
 let interp_cpattern ist gl red redty = interp_pattern ist gl (T red) redty;;
 let interp_rpattern ist gl red = interp_pattern ist gl red None;;
 
+let id_of_pattern = function
+  | _, T t -> (match kind_of_term t with Var id -> Some id | _ -> None)
+  | _ -> None
+
 (* The full occurrence set *)
 let noindex = Some(false,[])
 
@@ -1036,7 +1108,7 @@
     let { Evd.evar_body = e_body } as e_def = Evd.find sigma e in
     let e_body = match e_body with Evar_defined c -> c
     | _ -> errorstrm (str "Matching the pattern " ++ pr_constr p ++
-          str " did not instantiate ?" ++ int e ++ spc () ++
+          str " did not instantiate ?" ++ int (Evar.repr e) ++ spc () ++
           str "Does the variable bound by the \"in\" construct occur "++
           str "in the pattern?") in
     let sigma = 
@@ -1048,7 +1120,7 @@
     let sigma,pat= mk_tpattern ?hack env sigma0 (sigma,p) ok L2R (fs sigma t) in
     sigma, [pat] in
   match pattern with
-  | None -> do_subst env0 concl0 1
+  | None -> do_subst env0 concl0 concl0 1
   | Some (sigma, (T rp | In_T rp)) -> 
     let rp = fs sigma rp in
     let ise = create_evar_defs sigma in
@@ -1067,7 +1139,7 @@
     (* we start from sigma, so hole is considered a rigid head *)
     let holep = mk_upat_for env0 sigma (sigma, hole) all_ok in
     let find_X, end_X = mk_tpattern_matcher ?raise_NoMatch sigma occ holep in
-    let concl = find_T env0 concl0 1 (fun env c h ->
+    let concl = find_T env0 concl0 1 (fun env c _ h ->
       let p_sigma = unify_HO env (create_evar_defs sigma) c p in
       let sigma, e_body = pop_evar p_sigma ex p in
       fs p_sigma (find_X env (fs sigma p) h 
@@ -1083,10 +1155,10 @@
     let find_X, end_X = mk_tpattern_matcher sigma noindex holep in
     let re = mk_upat_for env0 sigma0 (sigma, e) all_ok in
     let find_E, end_E = mk_tpattern_matcher ?raise_NoMatch sigma0 occ re in
-    let concl = find_T env0 concl0 1 (fun env c h ->
+    let concl = find_T env0 concl0 1 (fun env c _ h ->
       let p_sigma = unify_HO env (create_evar_defs sigma) c p in
       let sigma, e_body = pop_evar p_sigma ex p in
-      fs p_sigma (find_X env (fs sigma p) h (fun env c h ->
+      fs p_sigma (find_X env (fs sigma p) h (fun env c _ h ->
         find_E env e_body h do_subst))) in
     let _ = end_E () in let _ = end_X () in let _ = end_T () in
     concl
@@ -1100,29 +1172,34 @@
     let find_TE, end_TE = mk_tpattern_matcher sigma0 noindex rp in
     let holep = mk_upat_for env0 sigma (sigma, hole) all_ok in
     let find_X, end_X = mk_tpattern_matcher sigma occ holep in
-    let concl = find_TE env0 concl0 1 (fun env c h ->
+    let concl = find_TE env0 concl0 1 (fun env c _ h ->
       let p_sigma = unify_HO env (create_evar_defs sigma) c p in
       let sigma, e_body = pop_evar p_sigma ex p in
-      fs p_sigma (find_X env (fs sigma p) h (fun env c h ->
+      fs p_sigma (find_X env (fs sigma p) h (fun env c _ h ->
         let e_sigma = unify_HO env sigma e_body e in
         let e_body = fs e_sigma e in
-        do_subst env e_body h))) in
+        do_subst env e_body e_body h))) in
     let _ = end_X () in let _ = end_TE () in
     concl
 ;;
 
 let redex_of_pattern ?(resolve_typeclasses=false) env (sigma, p) =
   let e = match p with
-  | In_T _ | In_X_In_T _ -> anomaly "pattern without redex"
+  | In_T _ | In_X_In_T _ -> Errors.anomaly (str"pattern without redex")
   | T e | X_In_T (e, _) | E_As_X_In_T (e, _, _) | E_In_X_In_T (e, _, _) -> e in
   let sigma =
     if not resolve_typeclasses then sigma
     else Typeclasses.resolve_typeclasses ~fail:false env sigma in
-  Reductionops.nf_evar sigma e
+  Reductionops.nf_evar sigma e, Evd.evar_universe_context sigma
 
 let fill_occ_pattern ?raise_NoMatch env sigma cl pat occ h =
-  let find_R, conclude = let r = ref None in
-    (fun env c h' -> do_once r (fun () -> c); mkRel (h'+h-1)),
+  let do_make_rel, occ =
+    if occ = Some(true,[]) then false, Some(false,[1]) else true, occ in
+  let find_R, conclude =
+    let r = ref None in
+    (fun env c _ h' ->
+       do_once r (fun () -> c, Evd.empty_evar_universe_context);
+       if do_make_rel then mkRel (h'+h-1) else c),
     (fun _ -> if !r = None then redex_of_pattern env pat else assert_done r) in
   let cl = eval_pattern ?raise_NoMatch env sigma cl (Some pat) occ find_R in
   let e = conclude cl in
@@ -1139,17 +1216,20 @@
  let ise, u = mk_tpattern env sigma0 (ise,t) ok L2R p in
  let find_U, end_U =
    mk_tpattern_matcher ~raise_NoMatch:true sigma0 occ (ise,[u]) in
- let concl = find_U env concl h (fun _ _ -> mkRel) in
- let rdx, _, (sigma, p) = end_U () in
- sigma, p, concl, rdx
+ let concl = find_U env concl h (fun _ _ _ -> mkRel) in
+ let rdx, _, (sigma, uc, p) = end_U () in
+ sigma, uc, p, concl, rdx
 
 let fill_occ_term env cl occ sigma0 (sigma, t) =
   try
-    let sigma',t',cl,_ = pf_fill_occ env cl occ sigma0 t (sigma, t) all_ok 1 in
-    if sigma' != sigma0 then error "matching impacts evars" else cl, (sigma',t') with NoMatch -> try
-    let sigma', t' =
+    let sigma',uc,t',cl,_= pf_fill_occ env cl occ sigma0 t (sigma, t) all_ok 1 in
+    if sigma' != sigma0 then Errors.error "matching impacts evars"
+    else cl, (Evd.merge_universe_context sigma' uc, t')
+  with NoMatch -> try
+    let sigma', uc, t' =
       unif_end env sigma0 (create_evar_defs sigma) t (fun _ -> true) in
-    if sigma' != sigma0 then raise NoMatch else cl, (sigma', t')
+    if sigma' != sigma0 then raise NoMatch
+    else cl, (Evd.merge_universe_context sigma' uc, t')
   with _ ->
     errorstrm (str "partial term " ++ pr_constr_pat t
             ++ str " does not match any subterm of the goal")
@@ -1159,38 +1239,12 @@
   let cl,(_,t) = fill_occ_term env concl occ sigma0 t in
   cl, t
 
-let cpattern_of_id id = ' ', (GRef (dummy_loc, VarRef  id), None)
+let cpattern_of_id id = ' ', (GRef (dummy_loc, VarRef  id, None), None)
 
 let is_wildcard = function
   | _,(_,Some (CHole _)|GHole _,None) -> true
   | _ -> false
 
-type ltacctx = int
-
-let pr_ltacctx _ _ _ _ = mt ()
-
-let ltacctxs = ref (1, [])
-
-let interp_ltacctx ist gl n0 =
-  Tacmach.project gl,
-  if n0 = 0 then 0 else
-  let n, s = !ltacctxs in
-  let n' = if n >= max_int then 1 else n + 1 in
-  ltacctxs := (n', (n, ist) :: s); n
-
-let noltacctx = 0
-let rawltacctx = 1
-
-ARGUMENT EXTEND ltacctx TYPED AS int PRINTED BY pr_ltacctx
-  INTERPRETED BY interp_ltacctx
-| [ ] -> [ rawltacctx ]
-END
-
-let get_ltacctx i = match !ltacctxs with
-| _ when i = noltacctx -> anomaly "Missing Ltac context"
-| n, (i', ist) :: s when i' = i -> ltacctxs := (n, s); ist
-| _ -> anomaly "Bad scope in SSR tactical"
-
 (* "ssrpattern" *)
 let pr_ssrpatternarg _ _ _ cpat = pr_rpattern cpat
 
@@ -1199,21 +1253,48 @@
   PRINTED BY pr_ssrpatternarg
 | [ "[" rpattern(pat) "]" ] -> [ pat ]
 END
+  
+let pf_merge_uc uc gl =
+  re_sig (sig_it gl) (Evd.merge_universe_context (project gl) uc)
 
-let ssrpatterntac ctx arg gl =
-  let ist = get_ltacctx ctx in
+let pf_unsafe_merge_uc uc gl =
+  re_sig (sig_it gl) (Evd.set_universe_context (project gl) uc)
+
+let ssrpatterntac ist arg gl =
   let pat = interp_rpattern ist gl arg in
   let sigma0 = project gl in
   let concl0 = pf_concl gl in
-  let t, concl_x = fill_occ_pattern (Global.env()) sigma0 concl0 pat noindex 1 in
-  let tty = pf_type_of gl t in
+  let (t, uc), concl_x =
+    fill_occ_pattern (Global.env()) sigma0 concl0 pat noindex 1 in
+  let gl, tty = pf_type_of gl t in
   let concl = mkLetIn (Name (id_of_string "toto"), t, tty, concl_x) in
-  convert_concl concl DEFAULTcast gl
+  Proofview.V82.of_tactic (convert_concl concl DEFAULTcast) gl
 
 TACTIC EXTEND ssrat
-| [ "ssrpattern" ssrpatternarg(arg) ltacctx(ctx) ] -> [ ssrpatterntac ctx arg ]
+| [ "ssrpattern" ssrpatternarg(arg) ] -> [ Proofview.V82.tactic (ssrpatterntac ist arg) ]
 END
 
+let ssrinstancesof ist arg gl =
+  let ok rhs lhs ise = true in
+(*   not (Term.eq_constr lhs (Evarutil.nf_evar ise rhs)) in *)
+  let env, sigma, concl = pf_env gl, project gl, pf_concl gl in
+  let sigma0, cpat = interp_cpattern ist gl arg None in
+  let pat = match cpat with T x -> x | _ -> errorstrm (str"Not supported") in
+  let etpat, tpat = mk_tpattern env sigma (sigma0,pat) (ok pat) L2R pat in
+  let find, conclude =
+    mk_tpattern_matcher ~all_instances:true ~raise_NoMatch:true
+      sigma None (etpat,[tpat]) in
+  let print env p c _ = ppnl (hov 1 (str"instance:" ++ spc() ++ pr_constr p ++ spc() ++ str "matches:" ++ spc() ++ pr_constr c)); c in
+  ppnl (str"BEGIN INSTANCES");
+  try
+    while true do
+      ignore(find env concl 1 ~k:print)
+    done; raise NoMatch
+  with NoMatch -> ppnl (str"END INSTANCES"); tclIDTAC gl
+
+TACTIC EXTEND ssrinstoftpat
+| [ "ssrinstancesoftpat" cpattern(arg) ] -> [ Proofview.V82.tactic (ssrinstancesof ist arg) ]
+END
 
 (* We wipe out all the keywords generated by the grammar rules we defined. *)
 (* The user is supposed to Require Import ssreflect or Require ssreflect   *)
diff -ur a/src/ssrmatching.mli b/src/ssrmatching.mli
--- a/src/ssrmatching.mli	2014-03-11 17:39:43.000000000 +0100
+++ b/src/ssrmatching.mli	2016-01-24 17:01:50.663675080 +0100
@@ -1,8 +1,10 @@
-(* (c) Copyright Microsoft Corporation and Inria.                       *)
-(* You may distribute this file under the terms of the CeCILL-B license *)
+(* (c) Copyright 2006-2015 Microsoft Corporation and Inria.                  *)
+(* Distributed under the terms of CeCILL-B.                                  *)
 
 open Genarg
+open Tacexpr
 open Environ
+open Tacmach
 open Evd
 open Proof_type
 open Term
@@ -18,15 +20,11 @@
 
 (** CS cpattern: (f _), (X in t), (t in X in t), (t as X in t) *)
 val cpattern         : cpattern Pcoq.Gram.entry
-val globwit_cpattern : (cpattern, glevel) abstract_argument_type
-val rawwit_cpattern  : (cpattern, rlevel) abstract_argument_type
-val wit_cpattern     : (cpattern, tlevel) abstract_argument_type
+val wit_cpattern     : cpattern uniform_genarg_type
 
 (** OS cpattern: f _, (X in t), (t in X in t), (t as X in t) *)
 val lcpattern         : cpattern Pcoq.Gram.entry
-val globwit_lcpattern : (cpattern, glevel) abstract_argument_type
-val rawwit_lcpattern  : (cpattern, rlevel) abstract_argument_type
-val wit_lcpattern     : (cpattern, tlevel) abstract_argument_type
+val wit_lcpattern     : cpattern uniform_genarg_type
 
 (** The type of rewrite patterns, the patterns of the [rewrite] tactic.
     These patterns also include patterns that identify all the subterms
@@ -36,9 +34,7 @@
 
 (** OS rpattern: f _, in t, X in t, in X in t, t in X in t, t as X in t *)
 val rpattern         : rpattern Pcoq.Gram.entry
-val globwit_rpattern : (rpattern, glevel) abstract_argument_type
-val rawwit_rpattern  : (rpattern, rlevel) abstract_argument_type
-val wit_rpattern     : (rpattern, tlevel) abstract_argument_type
+val wit_rpattern     : rpattern uniform_genarg_type
 
 (** Pattern interpretation and matching *)
 
@@ -59,12 +55,14 @@
 
 (** Extracts the redex and applies to it the substitution part of the pattern.
   @raise Anomaly if called on [In_T] or [In_X_In_T] *)
-val redex_of_pattern : ?resolve_typeclasses:bool -> env -> pattern -> constr
+val redex_of_pattern :
+  ?resolve_typeclasses:bool -> env -> pattern ->
+     constr Evd.in_evar_universe_context
 
 (** [interp_rpattern ise gl rpat] "internalizes" and "interprets" [rpat]
     in the current [Ltac] interpretation signature [ise] and tactic input [gl]*)
 val interp_rpattern :
-  Tacinterp.interp_sign -> goal Tacmach.sigma ->
+  Tacinterp.interp_sign -> goal sigma ->
   rpattern ->
     pattern
 
@@ -72,7 +70,7 @@
     in the current [Ltac] interpretation signature [ise] and tactic input [gl].
     [ty] is an optional type for the redex of [cpat] *)
 val interp_cpattern :
-  Tacinterp.interp_sign -> goal Tacmach.sigma ->
+  Tacinterp.interp_sign -> goal sigma ->
   cpattern -> glob_constr_and_expr option ->
     pattern
 
@@ -80,9 +78,9 @@
  *  to signal the complement of this set (i.e. {-1 3}) *)
 type occ = (bool * int list) option
 
-(** Substitution function. The [int] argument is the number of binders
-    traversed so far *)
-type subst = env -> constr -> int -> constr
+(** [subst e p t i]. [i] is the number of binders
+    traversed so far, [p] the term from the pattern, [t] the matched one *)
+type subst = env -> constr -> constr -> int -> constr
 
 (** [eval_pattern b env sigma t pat occ subst] maps [t] calling [subst] on every
     [occ] occurrence of [pat]. The [int] argument is the number of 
@@ -110,22 +108,7 @@
   ?raise_NoMatch:bool ->
   env -> evar_map -> constr ->
   pattern -> occ -> int ->
-    constr * constr
-
-(** Grammar entry to grab [Ltac] context, needed for the functions above.
-    It must appear after the last tactic argument and only once.
-    For example {[
-  TACTIC EXTEND ssrclear
-    | [ "clear" natural(n) ltacctx(ctx) ] -> [poptac ~ist:(get_ltacctx ctx) n]
-  END ]} *)
-type ltacctx
-
-val get_ltacctx : ltacctx -> Tacinterp.interp_sign
-
-val ltacctx         : ltacctx Pcoq.Gram.entry
-val globwit_ltacctx : (ltacctx, glevel) abstract_argument_type
-val rawwit_ltacctx  : (ltacctx, rlevel) abstract_argument_type
-val wit_ltacctx     : (ltacctx, tlevel) abstract_argument_type
+    constr Evd.in_evar_universe_context * constr
 
 (** *************************** Low level APIs ****************************** *)
 
@@ -138,7 +121,7 @@
 (** a pattern for a term with wildcards *)
 type tpattern
 
-(** [mk_tpattern env sigma0 sigma_t ok p_origin dir p] compiles a term [t] 
+(** [mk_tpattern env sigma0 sigma_p ok p_origin dir t] compiles a term [t] 
     living in [env] [sigma] (an extension of [sigma0]) intro a [tpattern].
     The [tpattern] can hold a (proof) term [p] and a diction [dir]. The [ok]
     callback is used to filter occurrences.
@@ -169,7 +152,8 @@
   @return the instance of the pattern, the evarmap after the pattern
     instantiation, the proof term and the ssrdit stored in the tpattern
   @raise UserEerror if too many occurrences were specified *)
-type conclude = unit -> constr * ssrdir * (evar_map * constr)
+type conclude =
+  unit -> constr * ssrdir * (evar_map * Evd.evar_universe_context * constr)
 
 (** [mk_tpattern_matcher b o sigma0 occ sigma_tplist] creates a pair 
     a function [find_P] and [conclude] with the behaviour explained above.
@@ -178,6 +162,7 @@
     be passed to tune the [UserError] eventually raised (useful if the 
     pattern is coming from the LHS/RHS of an equation) *)
 val mk_tpattern_matcher :
+  ?all_instances:bool ->
   ?raise_NoMatch:bool ->
   ?upats_origin:ssrdir * constr ->
   evar_map -> occ -> evar_map * tpattern list ->
@@ -209,8 +194,7 @@
 (* convenience shortcut: [pf_fill_occ_term gl occ (sigma,t)] returns
  * the conclusion of [gl] where [occ] occurrences of [t] have been replaced
  * by [Rel 1] and the instance of [t] *)
-val pf_fill_occ_term :
-  goal Tacmach.sigma -> occ -> evar_map * constr -> constr * constr
+val pf_fill_occ_term : goal sigma -> occ -> evar_map * constr -> constr * constr
 
 (* It may be handy to inject a simple term into the first form of cpattern *)
 val cpattern_of_term : char * glob_constr_and_expr -> cpattern
@@ -233,19 +217,19 @@
     In case of failure they raise [NoMatch] *)
 
 val unify_HO : env -> evar_map -> constr -> constr -> evar_map
-val pf_unify_HO : goal Tacmach.sigma -> constr -> constr -> goal Tacmach.sigma
+val pf_unify_HO : goal sigma -> constr -> constr -> goal sigma
 
 (** Some more low level functions needed to implement the full SSR language
     on top of the former APIs *)
 val tag_of_cpattern : cpattern -> char
-val loc_of_cpattern : cpattern -> Util.loc
-val id_of_cpattern : cpattern -> Names.variable option
+val loc_of_cpattern : cpattern -> Loc.t
+val id_of_pattern : pattern -> Names.variable option
 val is_wildcard : cpattern -> bool
 val cpattern_of_id : Names.variable -> cpattern
-val rawltacctx : ltacctx
 val cpattern_of_id : Names.variable -> cpattern
-val rawltacctx : ltacctx
 val pr_constr_pat : constr -> Pp.std_ppcmds
+val pf_merge_uc : Evd.evar_universe_context -> goal Evd.sigma -> goal Evd.sigma
+val pf_unsafe_merge_uc : Evd.evar_universe_context -> goal Evd.sigma -> goal Evd.sigma
 
 (* One can also "Set SsrMatchingDebug" from a .v *)
 val debug : bool -> unit
